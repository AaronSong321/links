# empty type
typename Zero = [||];

# abstract computation over effect row e with return values of type a
typename Comp(e::Row, a) = () ~e~> a;

# abstract computation over Choice, Failure + other stuff
typename CF(e::Row, a) = Comp({Choice : Bool, Failure : Zero|e}, a);

# helper functions for invoking Choice and Failure operations
sig choice : Comp({Choice:Bool|_}, Bool)
fun choice() {do Choice}

sig choose : (a, a) {Choice:Bool|_}~> a
fun choose(x,y) {if (choice()) {x} else {y}}

sig fail : Comp({Failure:Zero|_}, a)
fun fail() {switch (do Failure) { }}

# drunk coin tossing
typename Toss = [|Heads|Tails|];

# one drunk toss
sig drunkToss : CF({ |_}, Toss)
fun drunkToss() {
  if (choice()) {
    choose(Heads, Tails)
  } else {
    fail()
  }
}

# n drunk tosses
sig drunkTosses : (Int) -> CF({ |_}, [Toss])
fun drunkTosses(n)() {
  for (_ <- [1..n]) [drunkToss()]
}

# closed CF handler that returns a list of all possible results
sig allResults : (CF({}, a)) {}~> [a]
fun allResults(m) {
  handle(m) {
    case Return(x)  -> [x]
    case Choice(k)  -> k(true) ++ k(false)
    case Failure(k) -> []
  }
}

# closed CF handler that chooses at random and returns Nothing in the
# event of failure
fun sampleMaybe0(m) {
  handle(m) {
    case Return(x)  -> Just(x)
    case Choice(k)  -> k (random() < 0.5)
    case Failure(k) -> Nothing
  }
}

# open failure handler that returns an option type
#
# row typing requires that we explicitly mention Failure in the output
# type
sig maybeResult : (Comp({Failure:Zero|e}, a)) ->
                   Comp({Failure{_}  |e}, Maybe(a))
fun maybeResult(m)() {
  open handle(m) {
    case Return(x)  -> Just(x)
    case Failure(k) -> Nothing
  }
}

# abstracting over random number generation
sig rand : Comp({Rand:Float|_}, Float)
fun rand() {do Rand}

# open handler that interprets Choice using Rand (assuming rand
# generates a Float in the interval [0,1], this models an unbiased
# random choice)
#
# row typing requires that we explicitly mention the type of Rand in
# the input type
sig randomResult :
  (Comp({Choice:Bool, Rand:Float|e}, a)) ->
   Comp({Choice{_},   Rand:Float|e}, a)
fun randomResult(m)() {
  open handle(m) {
    case Return(x) -> x
    case Choice(k) -> k (rand() < 0.5)
  }
}

# open failure handler that recursively calls itself until it succeeds
sig persevere : (Comp({Failure:Zero|e}, a)) ->
                 Comp({Failure{_}  |e}, a)
fun persevere(m)() {
  open handle(m) {
    case Return(x)  -> x
    case Failure(k) -> persevere(m)()
  }
}

# closed handler for Rand that uses the Links built-in random number
# generator
sig handleRandom : (Comp({Rand:Float}, a)) {}~> a
fun handleRandom(m) {
  handle(m) {
    case Return(x) -> x
    case Rand(k)   -> k (random())
  }
}

# infix composition operator
op g -<- f {fun (x) {g(f(x))}}

# random sampling; return Nothing in the case of failure
fun sampleMaybe(m)  {(handleRandom -<- maybeResult -<- randomResult)(m)}
fun sampleMaybe2(m) {(handleRandom -<- randomResult -<- maybeResult)(m)}



# random sampling; start again in the case of failure
fun sample(m)  {(handleRandom -<- persevere -<- randomResult)(m)}
fun sample2(m) {(handleRandom -<- randomResult -<- persevere)(m)}


### examples
#
# allResults(drunkTosses(3))
# sampleMaybe(drunkTosses(2))
# sampleMaybe2(drunkTosses(2))
# sample(drunkTosses(5))
# sample2(drunkTosses(5))
