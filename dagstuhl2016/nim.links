# Nim game (https://en.wikipedia.org/wiki/Nim)
# This example is adapted from Kammar et al. (2013) (https://github.com/slindley/effect-handlers)

# A game begins with n sticks on the table. The game has two players: Alice and Bob.
# Alice goes first. Alice takes between one and three sticks, then it is Bob's turn
# and similary Bob takes between one and three sticks. They alternate turns until
# there are no more sticks left. The player, who takes the last stick, wins.


#
# The game
#

typename Player = [|Alice|Bob|];

# String of player
sig showPlayer : (Player) -> String
fun showPlayer(player) {
  switch (player) {
    case Alice -> "Alice"
    case Bob   -> "Bob"
  }
}

# The 'Move' operation represents a move by a player in the game. The
# parameter is a pair of the player and the number of sticks
# remaining. The return value is the number of sticks the player
# chooses to take.
sig move : (Player, Int) {Move : (Player, Int) {}-> Int|_}~> Int
fun move(player, sticks) {do Move(player, sticks)}

# We model the rules of the game as an abstract computation over the
# Move operation that returns the winner.

# a game is parameterised by the number of starting sticks
sig game : (Int) -> Comp ({Move: (Player, Int) {}-> Int|_}, Player)
fun game(n)() {aliceTurn(n)}

fun aliceTurn(n) {
  if (n == 0) {
    Bob    # Bob wins
  } else { 
    bobTurn(n - move(Alice, n))
  }
}

fun bobTurn(n) {
  if (n == 0) {
    Alice    # Alice wins 
  } else {
    aliceTurn(n - move(Bob, n))
  }
}

# Note that this implementation does not check that each player takes
# between one and three sticks on each turn. We will add such a check
# later.

#
# Strategies
#

# a handler that assigns the perfect strategy to both players
sig perfect :
  (Comp ({Move:(Player, Int) {}-> Int}, a)) {}~> a
fun perfect(m) {
  handle(m) {
    case Return(x)     -> x
    case Move(_, n, k) -> k(maximum(mod(n, 4), 1))
  }
}


# construct a closed handler that assigns strategy s(p) to player p
sig strategy :
  ((Player) {}~> (Int, (Int) {}~> r) {}~> r) ->
    (Comp ({Move:(Player, Int) {}-> Int}, r)) {}~> r
fun strategy(s) {
  handler {
    case Return(x)     -> x
    case Move(p, n, k) -> s(p)(n, k)
  }
}

# naive strategy: always pick one stick
fun ns(n, k) {k(1)}

# perfect strategy
fun ps(n, k) {k(maximum(mod(n, 4), 1))}

# both players adopt a naive strategy
fun nn(n) {
  strategy(fun (_) {ns})(game(n))
}

# both players adopt a perfect strategy
fun pp(n) {
  strategy(fun (_) {ps})(game(n))
}

# list of valid moves given n sticks remaining
fun validMoves(n) {
  filter(fun(m) { m <= n }, [1,2,3])
}

# brute force strategy: enumerate all possible moves
fun bfs(player)(n, k) {
  var winners = map(k, validMoves(n));
  var hasPlayerWon = elemIndex(player, winners);
  switch (hasPlayerWon) {
    case Nothing -> k(1)
    case Just(i) -> k(i+1)
  }
}

# Bob brute force vs Alice perfect
fun bp(n) {
  strategy(fun (p) {switch (p) {case Bob   -> bfs(Bob)
                                case Alice -> ps}})(game(n))
}

# Instead of simply evaluating the winner according to some strategy,
# we can also compute other data. For instance, we can compute a tree
# representing the possible moves of each player.


#
# Move tree
#
typename MoveTree =
  [| Take : (Player, [(Int, MoveTree)])
   | Winner : Player
   |];

# reify a move as part of the move tree
sig reifyMove : (Player, Int, (Int) ~e~> MoveTree) ~e~> MoveTree
fun reifyMove(player, n, k) {
  var moves = map(k, validMoves(n));
  var subgames = zip([1..length(moves)], moves);
  Take(player, subgames)
}

# Complete move tree generator
sig mtGen : (Comp({Move:(Player, Int) {}-> Int}, Player)) ~> MoveTree
handler mtGen {
  case Return(x)          -> Winner(x)
  case Move(player, n, k) -> reifyMove(player, n, k)
}

sig mt : (Int) ~> MoveTree
fun mt(n) {
  mtGen(game(n))
}

# links> mt(3)
#  Take((Alice(), [(1, Take((Bob(), [(1, Take((Alice(), [(1, Winner(Alice()))]))),
#                                    (2, Winner(Bob()))]))),
#                  (2, Take((Bob(), [(1, Winner(Bob()))]))),
#                  (3, Winner(Alice()))]))

# generate the move tree for a game in which Bob plays a perfect
# strategy

open handler forwardBob {
  case Return(x)         -> Winner(x)
  case Move(Alice, n, k) -> reifyMove(Alice, n, k)
  case Move(Bob,   n, k) ->
    var take = move(Bob, n);
    Take(Bob, [(take, k(take))])
}

# Note: we reuse the perfect vs perfect handler; it only ever gets to
# handle Move(Bob, n) even though it is defined for Move(Alice, n) as
# well.
fun mp(n) {
  strategy(fun (_) {ps})(forwardBob(game(n)))
}

# links> mp(3);
#    Take((Alice(), [(1, Take((Bob(), [(2, Winner(Bob()))]))),
#                    (2, Take((Bob(), [(1, Winner(Bob()))]))),
#                    (3, Winner(Alice()))]))

#
# Cheating
# 

# Cheat (p, m) is invoked when player p cheats by attempting to take
# m sticks (for m < 1 or 3 < m)
sig cheat : (Player, Int) {Cheat : (Player, Int) {}-> Zero|_}~> a
fun cheat(p, m) {switch (do Cheat(p, m)) { }}

# Check whether a given player cheated
fun checkMove(player, n, k) {
  var take = move(player, n);
  if (take < 1 || 3 < take) { # Cheater detected!
    cheat(player, take)
  } else {                    # Otherwise OK
    k(take)
  }
}

sig check :
  (Comp ({Cheat:(Player, Int) {}-> Zero, Move:(Player, Int) {}-> Int|e}, a)) ->
  (Comp ({Cheat:(Player, Int) {}-> Zero, Move:(Player, Int) {}-> Int|e}, a))
open handler check {
  case Move(player, n, k) -> checkMove(player, n, k)
  case Return(x)          -> x
}

fun checkedGame(n) {check(game(n))}

# a cheating strategy: take all of the sticks, no matter how many
# remain
fun cheater(n, k) {
  k(n)
}

# Alice cheats against Bob's perfect strategy
fun aliceCheats(m) {
  strategy(fun (p) {switch (p) {case Bob -> ps case Alice -> cheater}})(m)
}

# in an unchecked game Alice always wins
fun cpUnchecked(n) {
  aliceCheats(game(n))
}

# if a player cheats then halt the game and report the cheater
sig cheatReport : (Comp ({Cheat:(Player, Int) {}-> Zero|e}, a)) ->
                   Comp ({Cheat-                       |e}, a)
open handler cheatReport {
  case Cheat(Alice, n, k) -> error("Cheater Alice took " ^^ intToString(n) ^^ " sticks")
  case Cheat(Bob,   n, k) -> error("Cheater Bob took " ^^ intToString(n) ^^ " sticks")
  case Return(x)          -> x
}

# if a player cheats then the opponent wins immediately
sig cheatLose : (Comp ({Cheat:(Player, Int) {}-> Zero|e}, Player)) ->
                 Comp ({Cheat-                       |e}, Player)
open handler cheatLose {
  case Cheat(player, n, k) -> player
  case Return(x)           -> x
}

# Alice cheats against Bob's perfect strategy
#
# (If n < 4 then Alice wins, otherwise the game is abandoned because
# Alices cheats.)
fun cpReport(n) {
  aliceCheats(cheatReport(checkedGame(n))) 
}

# Alice cheats against Bob's perfect strategy
# 
# (If n < 4 then Alice wins, otherwise Bob wins because Alice
# cheats.)
fun cpLose(n) {
  aliceCheats(cheatLose(checkedGame(n)))
}





# an random operation
sig rand : Comp ({Rand:a|_}, a)
fun rand() {do Rand}

fun ms(n,k) {
  var r = floatToInt(rand() *. 65536.0);
  var take = (r `mod` 3) + 1; # Make sure take is in {1,2,3}
  if (take <= n) {k(take)}    # Make sure it is a legal move...
  else {k(1)}                 # ... otherwise just pick one
}

# mixed strategy handler assigns a random strategy to both players
sig mixed : (Comp({Move:(Player,Int) {}-> Int, Rand:Float|e}, a)) ->
             Comp({Move{_},                    Rand:Float|e}, a)
open handler mixed {
  case Move(p,n,k) -> ms(n,k)
  case Return(x)   -> x
}


# randomFloat handler uses Links' builtin random number generator
sig randomFloat : (Comp({Rand:Float|e}, a)) ->
                   Comp({Rand{_}   |e}, a)
open handler randomFloat {
  case Return(x) -> x
  case Rand(k)   -> k(random())
}



#
# A stateful game
#
# We are going to create a highscore board for Nim.
# In order to achieve this we need to introduce some notion of state.

# The game state is an association list
# where a player is associated with its number of wins
typename GameState = [(Player,Int)];

# Initially both players have zero victories
var initialState = [(Alice,0), (Bob,0)] : GameState;

sig get : (Comp({Get:s|_}, s))
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}~> ()
fun put(s) {do Put(s)}


# The state handler is parameterised by a state s
# which is threaded through the handler during evaluation
sig state : (s) ->                                  # Initial state
            (Comp({Get:s,  Put:(s) {}-> ()|e}, a)) ->
             Comp({Get{_}, Put{_}         |e}, a)
open handler state(s) {
     case Get(k)    -> k(s)(s)
     case Put(p,k)  -> k(())(p)
     case Return(x) -> x
}



# a simple handler which records
# the winner of a single game
sig scoreRecorder : (Comp({Get:GameState, Put:(GameState) {}-> ()|e}, Player)) ->
                     Comp({Get:GameState, Put:(GameState) {}-> ()|e}, Player)
open handler scoreRecorder {
  case Return(x) -> {
    var s = updateScore(x, get()); # Update the game state
    put(s);                        # Commit the change
    x
  }
}


# The board printer handler prints the scoreboard
sig boardPrinter : (Comp({Get:GameState|e}, a)) ->
                    Comp({Get:GameState|e}, ())
open handler boardPrinter {
     case Return(x) -> printBoard(get())
}

# Finally, we define repeatGame which repeats
# a given game r times
sig repeatGame : (Int, Comp({Move:(Player, Int) {}-> Int|e},  a)) ->
                       Comp({Move:(Player, Int) {}-> Int|e}, [a])
fun repeatGame(r, m)() {
    for (_ <- [1..r]) {
    	[m()]
    }
}



#(state(initialState) -<- boardPrinter -<- randomFloat -< repeatGame(10, scoreRecorder -< mixed(game(33))))();







#
# Auxiliary functions
#

# Auxiliary function
# Increment the given player's number of wins by one
sig updateScore : (Player, GameState) ~> GameState
fun updateScore(p,s) {
  map(fun(e) {
    if (p == first(e)) {
       (p, second(e)+1)
    } else { e }
  }, s)
}

# Auxiliary function
# Pretty prints the scoreboard.
sig printBoard : (GameState) ~> ()
fun printBoard(s) {
    var xs = map(fun(p) {
    	var player = showPlayer(first(p));
	var wins   = intToString(second(p));
	var ws_c1 = 12 - strlen(player);
	var ws_c2 = 10 - strlen(wins);
	"| " ^^ player ^^ makeWhitespace(11 - strlen(player)) ^^ "|" ^^ makeWhitespace(8 - strlen(wins)) ^^ wins ^^ " |"
    }, sort(s));

    print("/======================\\");
    print("|     NIM HIGHSCORE    |");
    print("|======================|");
    print("|   Player   |  #Wins  |");
    print("|============|=========|");
    print(xs !! 0);
    print("|============|=========|");
    print(xs !! 1);
    print("\\======================/");
}

# Auxiliary function
# Ranks Alice and Bob
sig sort : ([(2:a|p)]) ~> [(2:a|p)]
fun sort(s) {
  if (second(s !! 1) > second(s !! 0)) {
     (s !! 1) :: (s !! 0) :: []
  } else {s}
}

# Auxiliary function
# Creates whitespace
sig makeWhitespace : (Int) ~> String
fun makeWhitespace(n) {
    implode(replicate(n, ' '))
}

# Handler composition operator
# Data flows from right to left (or inside-out)
sig -<- : ((a) -e-> b, (c) -e-> a) -> (c) -e-> b
op g -<- f {fun (x) {g(f(x))}}

# Combine a sequence of handlers with a computation m
sig -< : ((a) -e-> b, a) -e-> b
op f -< m  {f(m)}

# Alternative pipeline operator; data flows from left-to-right
# Maybe more natural?
op m >> f {f(m)}

