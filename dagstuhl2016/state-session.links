# Links can implement ML-style state using built-in effects in various
# ways: here we use session types
typename State(a) = AP (!a.End);

sig snew : forall a::Any.(a) ~> State(a)
fun snew(v) {
  var x = new();
  var _ = spawn {send(v, accept(x))};
  x
}

sig sput : (State(a), a) ~> ()
fun sput(x, v) {
  var _ = receive(request(x)).1;
  var _ = spawn {send(v, accept(x))};
  ()
}

sig sget : (State(a)) ~> a
fun sget(x) {
  var v = receive(request(x)).1;
  var _ = spawn {send(v, accept(x))};
  v
}

# helper functions for invoking Get and Put operations
sig get : () {Get:s|_}-> s
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}-> ()
fun put(s) {do Put(s)}

# bit toggling example
sig toggle : () {Get:Bool, Put:(Bool) {}-> ()|_}-> Bool
fun toggle() {
  var x = get();
  put(not(x));
  x
}


# we can use the imperative implementation directly - each operation
# clause turns into a tail call
sig evalState : (s) ->
  (Comp ({Get:s,  Put:(s) {}-> ()|e}, a)) ->
   Comp ({Get{_}, Put{_}         |e}, a)
fun evalState(s)(m)() {
  var c = snew(s);
  open handle(m) {
    case Return(x) -> x
    case Get(k)    -> k(sget(c))
    case Put(t, k) -> k(sput(c,t))
  }
}

# or we can instrument it
sig logState : (s) ->
 (Comp ({Get:s,  Put:(s) {}-> ()|e}, a)) ->
  Comp ({Get{_}, Put{_}         |e}, (a, [s]))
fun logState(s)(m)() {
  var c = snew(s);
  open handle(m) {
    case Return(x) -> (x, [s])
    case Get(k)    -> k(sget(c))
    case Put(t, k) -> var (x, ss) = k(sput(c, t));
                      (x, s::ss)
  }
}

var x1 = evalState(true)(toggle)();
var x2 = logState(true)(toggle)();
