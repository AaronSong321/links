# Aspect-oriented programming using handlers.

# Inspired by Oliveira, Shrijvers, and Cook's JFP paper: Modular
# reasoning about interference in incremental programming

# helper functions for invoking Get, Put, and Tell
sig get : () {Get:s|_}~> s
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}~> ()
fun put(s) {do Put(s)}

sig tell : (String) {Tell:(String) {}-> ()|_}~> ()
fun tell(s) {do Tell(s)}

### some basic handlers for Get, Put, and Tell

# parameterised open evalState handler
sig evalState : (s) ->
  (Comp ({Get:s,  Put:(s) {}-> ()|e}, a)) ->
   Comp ({Get{_}, Put{_}         |e}, a)
open handler evalState(s) {
  case Return(x) -> x
  case Get(k)    -> k(s)(s)
  case Put(t, k) -> k(())(t)
}

# like evalState but returns the final state with the return value
sig runState : (s) ->
  (Comp ({Get:s,  Put:(s) {}-> ()|e}, a)) ->
   Comp ({Get{_}, Put{_}         |e}, (a, s))
open handler runState(s) {
  case Return(x) -> (x, s)
  case Get(k)    -> k(s)(s)
  case Put(t, k) -> k(())(t)
}

# tell interpreted as string concatenation
sig runStringWriter : (String) ->
 (Comp ({Tell:(String) {}-> ()|e}, a)) ->
  Comp ({Tell{_}              |e}, (a, String))
open handler runStringWriter(s) {
  case Return(x) -> (x, s)
  case Tell(t,k) -> k(())(s ^^ t)
}

# tell interpreted as printing to stdio
sig printer :
  (Comp ({Tell:(String) {}-> ()}, a)) {}~> a
handler printer {
  case Return(x) -> x
  case Tell(s,k) -> print(s); k(())
}

### integer expressions extended with various imperative operations
typename Expr =
  [| Lit : Int
   | Var : String
   | Plus : (Expr, Expr)
   | Assign : (String, Expr)
   | Sequence : [Expr]
   | While : (Expr, Expr)
   |];

fun showExpr(e) {
  switch (e) {
    case Lit(i)        -> intToString(i)
    case Var(x)        -> x
    case Plus(l, r)    -> "(" ^^ showExpr(l) ^^ ")+(" ^^ showExpr(r) ^^ ")"
    case Assign(x, e)  -> x ^^ " := " ^^ showExpr(e)
    case Sequence(es)  ->
      fun showExprs(es) {
        switch (es) {
          case []      -> ""
          case [e]     -> showExpr(e)
          case (e::es) -> showExpr(e) ^^ ", " ^^ showExprs(es)
        }
      }
      "[" ^^ showExprs(es) ^^ "]"
    case While(c, b)   -> "while (" ^^ showExpr(c) ^^ ") {" ^^ showExpr(b) ^^ "}"
  }
}

# special suspend operation that we will use as a hook

# Suspend is interesting because it includes computations over itself
# as a parameter. So the computation tree becomes a hypertree - each
# Suspend node includes another tree, whose Suspend nodes can also
# include more trees, ad inifitum

# suspend computations
typename SComp(e::Row, a) =
  Comp ({Suspend:(Expr, SComp(e, a)) {}-> a|e}, a);

# helper function for invoking Suspend
sig suspend :
  forall e::Row, a.
    (Expr) ->
      (SComp({ |e}, a))
        {Suspend:(Expr, SComp({ |e}, a)) {}-> a|e}~> a
fun suspend(e)(m) {do Suspend(e, m)}

# value environment and pretty printer
typename Env = [(String, Int)];
fun showEnv(env) {
  fun showEntry((x, i)) {x ^^ "=" ^^ intToString(i)}

  fun showEntries(es) {
    switch(es) {
      case []      -> ""
      case [e]     -> showEntry(e)
      case (e::es) -> showEntry(e) ^^ "; " ^^ showEntries(es)
    }
  }
  "{" ^^ showEntries(env) ^^ "}"
}

## an expression evaluator that produces abstract computations

# one step
sig bevalStep :
  (Expr) -> SComp ({Get:Env, Put: (Env) {}-> ()|e}, Int)
fun bevalStep(exp)() {
  switch(exp) {
    case Lit(x) -> x
    case Var(x) ->
      switch (lookup(x, get())) {
        case Just(v) -> v
        case Nothing -> error("variable: " ^^ x ^^ " not found!")
      }
    case Plus(l, r) -> bevalRec(l) + bevalRec(r)
    case Assign(x, e) ->
      var v = bevalRec(e);
      put ((x, v) :: get());
      v
    case Sequence([])    -> 0
    case Sequence([e])   -> bevalRec(e)
    case Sequence(e::es) ->
      ignore(bevalRec(e)); bevalRec (Sequence(es))
    case While(c, b)     ->
      if (bevalRec(c) == 0) {
        0
      } else {
        ignore(bevalRec(b)); bevalRec(exp)
      }
  }
}
# recurse, marking with suspend
fun bevalRec(e) {suspend(e)(bevalStep(e))}

# the evaluator
sig beval : (Expr) -> SComp({Get:Env, Put: (Env) {}-> ()|e}, Int)
fun beval(e)() {bevalRec(e)}

# recursively erase all Suspend operations
sig force :
(SComp({         |e}, a)) ~>
  Comp({Suspend- |e}, a)
open handler force {
  case Return(x)        -> x
  case Suspend(e, m, k) -> k (force(m)())
}

# logging subexpression evaluation at each Suspend
sig logger : (String) ->
  (SComp ({Tell:(String) {}-> ()|e}, Int)) ->
   SComp ({Tell:(String) {}-> ()|e}, Int)
open handler logger(name) {
  case Return(x)        -> x
  case Suspend(e, m, k) ->
    tell("Entering " ^^ name ^^ " with " ^^ showExpr(e) ^^ "\n");
    var y = suspend(e)(logger(name)(m));
    tell("Exiting " ^^ name ^^ " with " ^^ intToString(y) ^^ "\n");
    k(y)(name)
}

# dump the environment at each Suspend
sig dump : (SComp ({Get:Env, Tell:(String) {}-> ()|e}, Int)) ->
           (SComp ({Get:Env, Tell:(String) {}-> ()|e}, Int))
fun dump(m)() {
  open handle(m) {
     case Return(x)        -> x
     case Suspend(e, m, k) ->
       tell(showEnv(get()));
       k(suspend(e)(dump(m)))
  }
}

sig e1 : Expr
var e1 = Plus (Lit(3), Lit(4));
sig e2 : Expr
var e2 = Plus (Assign("x", Lit(3)), Assign("y", Lit(4)));
sig e3 : Expr
var e3 = Plus (Plus(Assign ("x", Lit(3)), Assign("y", Lit(4))), Plus (Var("x"), Var("y")));

var test0 = printer -<- evalState([]) -<- force -<- beval;
var test1 = printer -<- evalState([]) -<- force -<- logger("eval") -<- beval;
var test2 = printer -<- evalState([]) -<- force -<- dump -<- beval;
var test3 = printer -<- evalState([]) -<- force -<- dump -<- logger("eval") -<- beval;


# One can go further. If we reflect expressions as abstract
# constructors then we can override the behaviour of individual
# constructors using a handler - just like in Bob Atkey's algebraic
# approach to type checking / elaboration presented at HOPE 2015.
