Linear function annotation
sig h : ((a::Any) -e-@ a::Any, a::Any) -e-> a::Any fun h(f, x) {f(x)}
stdout : () : ()
exit : 0

Non-linear use of linear function
sig h : ((a::Any) -e-@ a::Any, a::Any) -e-> a::Any fun h(f, x) {f(f(x))}
stderr : @..*
exit : 1

Linear identity
fun (x) {x}
stdout : fun : (a::Any) -> a::Any
exit : 0

Non-linear dup
fun (x) {(x, x)}
stdout : fun : (a) -> (a, a)
exit : 0

Grab value
fun (c) {grab(c).1}
stdout : fun : (?a::Any._::Session) ~> a::Any
exit : 0

Grab channel
fun (c) {grab(c).2}
stdout : fun : (?_.b::Any Session) ~> b::Any Session
exit : 0

Ignore give
fun (c) {ignore(give(42, c))}
stdout : fun : (!Int._::Session) ~> ()
exit : 0

Non-linear generalisation (1)
{var x = A; ()}
stdout : () : ()
exit : 0

Non-linear generalisation (2)
fun (r) {var (x=42|q) = r; ()}
stdout : @fun..*
exit : 0
