var db = database "links";

typename Where = (String, String, Int);

sig recorded_prov : ((origin_table: String,
                      origin_column: String,
                      origin_row: Int |_)) -> Where
fun recorded_prov (c) {
  (c.origin_table,
   c.origin_column,
   c.origin_row)
}

var top_comments =
  table "top_comments"
  with (id: Int,
        text: String,
        origin_table: String,
        origin_column: String,
        origin_row: Int)
  where text prov recorded_prov
  from db;

fun text_data() {
  query {
    for (c <-- top_comments)
      [(text = data c.text)]
  }
}

fun text_prov() {
  query {
    for (c <-- top_comments)
      [(textp = prov c.text)]
  }
}

fun text() {
  query {
    for (c <-- top_comments)
      [(text = c.text)]
  }
}

fun text_where_id(id) {
  query {
    for (c <-- top_comments)
    where ((prov c.text).3 == id)
      [(id = c.id, text = data c.text)]
  }
}

fun test() {
  assertEq(text_data(), [(text="foo"), (text="qux"), (text="quuix")]);
  assertEq(text_prov(), [(textp=("bar", "baz", 5)),
                         (textp=("bar", "baz", 7)),
                         (textp=("fasl", "lror", 42))]);
  # We can't compare data directly, because we can't construct values
  # of type Prov(String), only the database can. Instead, we compare
  # strings. The string representation is ugly because of the
  # desugaring approach of the current implementation. We need to
  # quote the record field names data and prov because parsing is
  # hard.
  assertEq(show(text()),
           show([(text=("data"="foo","prov"=("bar", "baz", 5))),
                 (text=("data"="qux","prov"=("bar", "baz", 7))),
                 (text=("data"="quuix","prov"=("fasl", "lror", 42)))]));
  assertEq(text_where_id(42), [(id=3, text="quuix")])
}

test()
