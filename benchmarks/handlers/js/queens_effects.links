# For printing
fun intersperse(y, xs) {
   switch (xs) {
     case []      -> []    
     case [x]     -> [x]
     case x :: xs -> x :: y :: intersperse(y,xs)
   }
}

fun showList(showX)(xs) {
  var xs = fold_left(fun (acc, x) { acc ^^ x }
                    , ""
                    , intersperse(",", map(showX, xs)));
  "[" ^^ xs ^^ "]"
}

fun showMaybe(s)(m) {
   switch (m) {
      case Just(x) -> "Just(" ^^ s(x) ^^ ")"
      case Nothing -> "Nothing"
   }
}

sig showPair : forall a, b . ((a) -e-> String, (b) -e-> String) -> ((a,b)) -e-> String
fun showPair(showX,showY)((x,y)) {
    "(" ^^ showX(x) ^^ ", " ^^ showY(y) ^^ ")"
}

# The actual program

sig choose : ([a]) {Choose:([a]) {}-> a |_}-> a
fun choose(xs) { do Choose(xs) }

fun for_all(p, xs) {
  switch (xs) {
    case [] -> true
    case x :: xs -> if (p(x)) for_all(p, xs) else false
  }
}

fun noAttack((a,b))((c,d)) {
  a <> c && b <> d && abs(a - c) <> abs(b - d)
}

fun available(a, qs, l) {
  filter(fun(b) { for_all(noAttack((a,b)), qs) }
        , l)
}

fun chooseHandler(m) {
    handle(m) {
      case Return(x) -> Just(x)
      case Choose(xs,k) -> {
           fun loop(xs) {
              switch(xs) {
                case []      -> Nothing
                case x :: xs ->
                  switch (k(x)) {
                    case Nothing -> loop(xs)
                    case Just(x) -> Just(x)
                  }
              }
           }
           loop(xs)
      }
    }
}

fun findSolution(n)() {
    var l = intRange(1,n);

    fun place(x, qs) {
        if (x == n+1) qs
        else {
          var y = choose(available(x, qs, l));
          place(x+1, (x,y) :: qs)
        }
    }

    place(1, [])
}

fun b(n) client {
  var t0 = clientTime();
  var r = chooseHandler(findSolution(n));
  var t1 = clientTime();
  var showSolution = showMaybe(showList(showPair(intToString,intToString)));
  ignore $ domSetPropertyFromRef(getNodeById("result"), "value", showSolution(r));
  ignore $ domSetPropertyFromRef(getNodeById("elapsed"), "value", intToString(t1 - t0));
  domRemoveAttributeFromRef(getNodeById("run"), "disabled")
}

fun proc() client {
  var n = recv();
  b(n);
  proc()
}

fun start(worker, inputSize) client {
  var n = stringToInt(inputSize);
  ignore $ domSetPropertyFromRef(getNodeById("run"), "disabled", "disabled");
  ignore $ domSetPropertyFromRef(getNodeById("result"), "value", "");
  ignore $ domSetPropertyFromRef(getNodeById("elapsed"), "value", "");
  worker ! n
}

# Page
fun mainPage(_) {
  var p = spawnClient { proc() };
  page
    <html>
      <body>
        <form l:onsubmit="{start(p, inputSize)}">
          <table border="0" cellspacing="5">
            <tr>
              <td>Problem size:</td>
              <td><input type="text" l:name="inputSize" value="8" /></td>
            </tr>
            <tr>
              <td>Result:</td>
              <td><input type="text" id="result" readonly="readonly" value="" /></td>
            </tr>
            <tr>
              <td>Elapsed:</td>
              <td><input type="text" id="elapsed" readonly="readonly" value="" /></td>
            </tr>
            <tr>
             <td colspan="2"><input type="submit" id="run" value="Run" /></td>
            </tr>
          </table>
        </form>
      </body>
    </html>
}


fun main() {
  addRoute("/", mainPage);
  servePages()
}

main()
