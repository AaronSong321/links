# Microbenchmark monadic stateful counting

typename State (s,a) = (s) {}~> (a,s);

# state monad
sig runState : (State (s,a), s) -%-> (a,s)
fun runState(m, s) { m(s) }

sig evalState : (State(s,a), s) -%-> a
fun evalState(m, s) {
    var (a,_) = runState(m,s);
    a
}

infixl 1 >>=;
sig >>= : (State (s,a), (a) -%-> State(s,b)) -%-> State (s,b)
op m >>= k {
   fun (s1) {
       var (v,s2) = m (s1);
       runState (k(v), s2)
   }
}

sig return : (a) -> State (s,a)
fun return(a) { fun (s) { (a,s) } }

sig get : () -> State(s,s)
fun get() { fun(s) { (s,s) } }

sig put : (s) -> State(s,())
fun put(s) { fun(_) { ((), s) } }

fun count() {
    get()
        >>=
          fun(n) {
             if (n == 0) return(n)
             else put(n-1) >>= fun(_) { count() } }
}

fun b(n) {
    var x = evalState(count(), n);
    x
}

fun pow(b,e) {
  fun pow_aux(b,e,acc) {
    if (e == 0) acc
    else pow_aux(b,e-1,acc*b)
  }
  pow_aux(b,e,1)
}

print(intToString(b(pow(10,7))))
