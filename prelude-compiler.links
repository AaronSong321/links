fun concatMap(f, l) {
  switch (l) {
    case [] -> []
    case hd::tl -> f(hd) ++ concatMap(f, tl)
  }
}

fun map(f, l) {
  switch (l) {
    case []     -> []
    case hd::tl -> f(hd) :: map(f,tl)
  }
}

fun filter(p, l) {
  concatMap (fun (x) {if(p(x)) [x] else []}, l)
}

fun fold_left(p, u, l) {
  switch (l) {
    case [] -> u
    case x::xs -> fold_left(p, p(u, x), xs)
  }
}

fun fold_left1(p, l) {
  fold_left(p, hd(l), tl(l))
}

fun fold_right(f, u, l) {
  switch (l) {
    case [] -> u
    case x::xs -> f(x, fold_right(f,u,xs))
  }
}

fun replicate(n, item) {
  if (n == 0) []
  else item :: replicate(n-1, item)
}

# TBD: rename this 'sortOn' to follow Haskell usage?
sig sortBy : ((a) ~b~> c, [a]) ~b~> [a]
fun sortBy (f, l) {
  switch (l) {
    case [] -> []
    case x::xs -> {
      var lt = filter (fun (y) {f(y) < f(x)}, xs);
      var ge = filter (fun (y) {f(y) >= f(x)}, xs);
      sortBy(f, lt) ++ [x] ++ sortBy(f, ge)
    }
  }
}

# need to be careful to make sure this doesn't get
# optimised away - it does if we eta reduce it
sig sortByBase : ((a) ~b~> (| _::Base), [a]) ~b~> [a]
fun sortByBase(f, l) {sortBy(f, l)}
