#*****************************************************************************#
#* LODE's main editor file.                                                  *#
#*                                                                           *#
#* Original version written by Tom Andersson (tom.andersson@gmail.com) in    *#
#* 07/08.                                                                    *#
#*                                                                           *#
#* To get run/deploy to work, edit the section marked @@ CHANGEME @@.        *#
#*                                                                           *#
#* Note: Some functions are not used anywhere, and are kept only for reasons *#
#*       of posterity. Hopefully, comments and variable/functions names      *#
#*       make the code 'easy' to understand.. despite its size.              *#
#*                                                                           *#
#* TODO: Once Links has proper import functionality, clean up the structure  *#
#*       of this file, and move auxiliary functions elsewhere.               *#
#*****************************************************************************#

######
# JavaScript functions (in extras.js)
##
# Split lines
alien javascript splitEscapedLinesJS : (String) -> [String];

# Call the code highlighting function of the edit-box.
alien javascript highlightCode : () -> ();
alien javascript setCode: (String) -> ();
alien javascript getCode: () -> String;

# Return node.value.
alien javascript getValueFromRef : (DomNode) -> String; 

# Convert spaces to 
alien javascript convertSpaces : (String) -> String;

# Load the IDE's editor.
alien javascript loadEditor: () -> DomNode;
alien javascript getSiblings: (DomNode) -> [DomNode];

# Get the current location (ie URL)
alien javascript getLocation: () -> String;

# Create a new window using the URL passed in.
alien javascript newWindow: (String) -> ();

# Normal (un-)escaping
alien javascript jsUnescape: (String) -> String;
alien javascript jsEscape: (String) -> String;
alien javascript jsEscapeSlashes: (String) -> String;

# Get nodes from a foreign document
alien javascript getElementsByNameFromDocument: (DomNode, String) -> [DomNode];

# Get value
alien javascript getTextValue: (DomNode) -> String;

# Redirect using JavaScript to avoid having to submit form.
alien javascript redirectClient: (String) -> ();

# Given an iframe, enable contentEditable for that doc.
alien javascript enableEditable: (DomNode) -> ();

# TODO: Check why normal isNUll doesn't work.
alien javascript tmpIsNull: (DomNode) -> Bool;

# TODO: Client-side regexes are broken?
# Anchored like links regexes.
alien javascript jsMatches: (String, String) -> Bool;

# Set the page title
alien javascript setPageTitle: (String) -> ();

######
# Attribute type
typename Attribute = (attr: String, val: String);

# Things that should be in their own file
# @@ CHANGEME @@  
var cookieName = "linkside";
var fileLoc = "/home/tom/links/html/proj/";
var testDir = "test/";
var deplDir = "users/";

typename User = (name:String, password:String);
typename ProjConts = (Int, String);
typename Projects = [| Project : ProjConts | Folder : ProjConts | File : ProjConts |];

typename ProjectListing = mu proj.[| LFile : ProjConts | LProject : (ProjConts, [proj]) | LFolder : (ProjConts, [proj]) |];

# Databases to access
var users = table "users" with (
    id : Int,
    email: String,
    password: String
) from (database "ide");

var projectTable = table "projects" with (
    id : Int,
    uid : Int,
    name : String,
    dirty : Int
) from (database "ide");

var files = table "files" with (
    id : Int,
    pid : Int,
    name : String,
    last_mod : String,
    created : String, 
    data : String,
    parent : Int,
    isfolder : Int
) from (database "ide");

var sessionsTable = table "sessions" with (
    id : String,
    uid : Int,
    creation_time : Int,
    update_time : Int
) from (database "ide");

var validSessions = table "valid_sessions" with (
    id : String,
    uid : Int
) from (database "ide");

# Logout from the IDE (doesn't redirect)
sig logout : () -> ()
fun logout() server
{
  var lId = getCookie("linkside");
  delete (var sessId <-- sessionsTable)
    where (sessId.id == lId);

  # Delete temporary directory (and all its contents..)
  switch (rmdirForce(fileLoc ++ testDir ++ lId))
  {
    case Error(err) -> debug("Error on rmdir: " ++ err);
    case _ -> ()
  };

  setCookie("linkside","");
}

# Logout and redirect to login page.
sig logoutClient : () -> ()
fun logoutClient() client
{
  # Get current location, dropping the filename.
  var lLoc = reverse(dropWhile(fun (x) { x <> '/' }, reverse(getLocation())));

  # Kill the session, remove temp dir etc.
  logout();

  # Redirect
  redirectClient(lLoc ++ "login.links");
}

##
# Sorting functions for types. (Inspired by LiterateProgram's Haskell Qsort)
##

typename Pos = (finish: Int, line: Int, start: Int);
typename Type = (name: String, pos: Pos, t: String);
typename Sort = (Type, [Type], ([Type], [Type]));

# Partition a list of types around a pivot.
sig part : (Sort) -> ([Type], [Type])
fun part(xiSort) 
{
  switch (xiSort)
  {
    case (_,[],res) -> res
    case (pivot, (l::list),(less, grt) ) ->
    {
      if ((pivot.pos).line < (l.pos).line)
        part((pivot, list, (less, l::grt)))
      else if ((pivot.pos).line > (l.pos).line)
        part((pivot, list, (l::less, grt)))
      else
        # Types are on the same line - let the position decide.
        part((pivot, list, posPart(pivot, l, (less, grt))))
    }
  }
}

# Partition the given Type based on its position in a line.
sig posPart : (Type, Type, ([Type], [Type]))  -> ([Type], [Type])
fun posPart(xiPivot, xiCurr, xiParts)
{
  switch (xiParts)
  {
    case (less, grt) ->
    {
      if ((xiPivot.pos).start > (xiCurr.pos).start)
        (xiCurr::less, grt)
      else
        (less, xiCurr::grt)
    }
  }
}

# Perform quicksort on a list of types, sorting them according to position.
sig qsort : ([Type]) -> [Type]
fun qsort(xiList)
{
  switch (xiList)
  {
    case [] -> []
    case (l::list) ->
    {
      var lSort = (l, list, ([], []));
      switch (part(lSort))
      {
        case (less, grt) -> qsort(less) ++ [l] ++ qsort(grt)
      }
    }
  }
}
  
##
# Normal code.
##

# Return the uid of the current sessions' owner.
sig getUid : () -> Int
fun getUid() server
{
  debug("Getting UID");
  var uids = for (var sid <-- sessionsTable)
             where (sid.id == getCookie("linkside"))
              [sid.uid];
  if (length(uids) == 0)
    1
  else
    hd(uids)
}

# Userid of session owner
var userId = getUid();

# Check whether the user is logged in
sig isLoggedIn : () -> Bool
fun isLoggedIn() server
{
  var sessId = getCookie(cookieName);
  debug("cookie: " ++ sessId);
  # Check that the sessid exists in the database
  var p = length(for (var lSess <-- validSessions)
    where (lSess.id == sessId)
      [lSess.id]) == 1;
  (if (p)
    debug("logged in")
  else
    debug("not logged in"));
  p
}

# Perform file operations (load, save).
fun fileOp() client
{
  receive 
  {
    case SaveFile(name, toggle) -> 
    {
      if (toggle)
        toggleWaiting("Saving file..")
      else {};

      var lBody = getDocumentBody();
  
      # Get the text
      var lCode = convertSpaces(getCode());
  
      var lFileData = getFrameData();
      
      # Get types and attach if ok.
      var lTypes = storeFile(name, lFileData.pid, lCode, lCode); 

      switch (lTypes)
      {
        case Failure(err) -> debug("Type error: " ++ err)
        case Success(typ) -> attachTypes(typ);
      };

      setFrameData(lFileData.pid, name);

      # Set the page's title
      setPageTitle("LODE - " ++ name);
   
      # Enable the run/deploy menu items
      toggleMenuItem("run", true);
      toggleMenuItem("deploy", true);

      if (toggle)
        toggleWaiting("") 
      else {};

      fileOp()
    }
    case LoadFile(name, lEvent) -> 
    {
       toggleWaiting("Loading file..");
       var lFileInfo = getFileData(lEvent);
       var lProjId = lFileInfo.pid;

       # This could be done when getting the path, so
       # slightly unnecessary, but just to be sure we can 
       # choose how we want to be organised..
       var lFullName = 
         takeWhile(fun (x) { x <> '/' }, lFileInfo.path) ++ "/" ++ name;

       # Set the page's title
       setPageTitle("LODE - " ++ lFullName);

       var lFileData = getFile(lProjId, name);
       var lData = lFileData.data;
       var lTypes = lFileData.types;

       # Insert the code.
       setCode(lData);
       
       # Set current file and frame name
       debug("Set file info");
       setCurrFile(lFullName);
       setFrameData(lProjId, lFullName);
     
       # Enable editing
       debug("Enable editing");
       enableEditable(getNodeById("iframe"));

       # Enable the run/deploy menu items
       debug("toggle menu");
       toggleMenuItem("run", true);
       toggleMenuItem("deploy", true);
       toggleMenuItem("save", true);
       toggleMenuItem("save-as", true);

       # Insert types on success.
       debug("type check");
       switch (lTypes)
       {
         case Failure(err) -> debug("Type error: " ++ err); toggleWaiting("");
         case Success(typ) -> attachTypes(typ); toggleWaiting("");
       };

       fileOp()
    }
  }
}

# Session/auto-save thread.
fun sessionCheck(xiFileHandler) client
{
  receive
  {
    case Check() ->
    {
      # Sleep for 1min
      sleep(60000);
  
      # Auto save document if it's been changed.
      if ((optionEnabled("autosave")) && (docHasChanged()) && 
            (not(isFrameNew())))
      {
        debug("Auto-saving..");
        var lData = getFrameData();
        var lRealName = takeWhile(fun (x) { x <> '*' }, lData.fname);
        xiFileHandler ! SaveFile(lRealName, false);
        setFrameData(lData.pid, lRealName);
      } else {};
				
      # Check if session timeouts are turned on.
      if (optionEnabled("session"))
      {
        # Check that the session is active
        # This is done using an anonymous function due to a bug
        # in Links - see Trac ticket 89.
        fun () 
        {
          if(isLoggedIn())
          {
            debug("User is logged in");
        
            # Loop
            (self()) ! Check() 
          }
          else
          {  
            # Display message if it isn't
            debug("User's session has expired");
            toggleVisible("overlay");
            toggleVisible("session-expired")        
          }
        }();
      } 
      else
      {
        debug("Session handling disabled");

        # Loop
        (self()) ! Check() 
      };

      sessionCheck(xiFileHandler)
    }
  }
}

# Get the types from a particular piece of code.
sig getTypes : (String) -> [|Failure:String|Success:[(name:String,pos:(finish:Int,line:Int,start:Int),t:String)]|]
fun getTypes(xiCode) server
{
  # Add a space to ensure that there's _something_ to type check.
  dumpTypes(xiCode ++ " ")
}

# Attach the types to the nodes in the actual document.
sig attachTypes : ([(name:String, pos:(finish:Int, line:Int, start: Int), t:String)]) -> ()
fun attachTypes(xiList) client
{
  debug("Filtering list");

  # Remove any unwanted types (bodyP and l:-bindings)
  var lList = 
    for (var lItem <- xiList)
      if (((lItem.pos).start >= 0) && (lItem.name <> "bodyP"))
      {
        [lItem]
      }
      else
        [];

  debug("List length: " ++ intToString(length(lList)));
  debug("Sorting..");
  # Sort
  # For a large file, this call could be a performance hole.
  var lTypeList = qsort(lList);

  # Find references to functions/vars
  debug("Match types");
  var lNodes = getElementsByNameFromDocument(
                 getContentDocument(getNodeById("iframe")), 
                 "variable"
               );
  debug("Number of nodes: " ++ intToString(length(lNodes)));
  matchListTypes(lTypeList, lNodes);
}

# Assume that the lists type and node lists are ordered, and attach the 
# 'correct' types.
sig matchListTypes : ([(name:String,pos:(finish:Int,line:Int,start:Int),t:String)], [DomNode]) -> ()
fun matchListTypes(xiTypes, xiList) client
{
  if ((xiList == []) || (xiTypes == []))
    ()
  else
  {
    var lHead = hd(xiList);
    var lType = hd(xiTypes);

    # If the name of this type matches the name contained in the node
    if (lType.name == remSpace(getTextValue(firstChild(lHead))))
    {
      # Set the type, and drop both the type and the node from the lists.
      var lVoid = domSetAttributeFromRef(lHead, "title", lType.t);
      matchListTypes(tl(xiTypes), tl(xiList))
    }
    else
    {
      # Otherwise, just recurse.
      matchListTypes(tl(xiTypes), xiList)
    };
  }
}

# Match a list of types (given as (name, type)) to a list of Nodes, removing
# those nodes that don't have a type. Possibility of this failing if a 
# top-level function is overwritten by a local function of the same name?
# Disbanded.
sig matchTypes : ([(String, String)], [DomNode]) -> [DomNode]
fun matchTypes(xiTypes, xiList) client
{
  switch (xiList)
  {
    case [] -> []
    case (x::xs) -> 
    {
      var lSpaceFun = fun (c) { ord(c) <> 160 };
      var lText = remSpace(getTextValue(firstChild(x)));

      # We're doing this in a stupid way to work around the fact
      # that hd([String]) returns a char here..?
      if (lelem(lText, xiTypes))
        [x] ++ matchTypes(xiTypes, xs)
      else
      {
        debug("Dropping " ++ lText);
        matchTypes(xiTypes, xs)
      }
    }
  }
}

# Elem-function for matching against the head of a tuple.
fun lelem(x, l) {
  not(l==[]) && (x == first(hd(l)) || x `lelem` tl(l))
}

# Remove spaces from a string
fun remSpace(string) 
{
  switch (string)
  {
    case [] -> []
    case (x::xs) -> 
    {
      var lOrd = ord(x);
      # Delete spaces (160) and returns (32)
      if ((ord(x) == 160) || (ord(x) == 32))
        remSpace(xs)
      else
        [x] ++ remSpace(xs)
    }
  }
}

# Project list menu.
sig projMenu : (Event) -> ()
fun projMenu(xiEvent) client
{
  debug(intToString(getMouseButton(xiEvent)));

  # Stop the event from propagating - we don't want the normal menu
  # Broken.
  stopPropagation(xiEvent);
  ()  
}

# Update the last-access time of the session
sig updateSession : () -> ()
fun updateSession() server
{
  update (var sid <-- sessionsTable)
    where (sid.uid == userId)
    set (id = sid.id, uid = sid.uid, creation_time = 0, update_time = 0)
}

# Check whether the password given was correct, and resume session if so.
sig resumeSession : (Mailbox ([|SaveFile:(String, Bool)|LoadFile:(String, Event)|a|])) -> ()
fun resumeSession(xiHandler) client
{
  var lNode = getNodeById("resume");
  var lPass = getValueFromRef(lNode);

  if (length(lPass) == 0)
  {
    debug("Password node empty");
    alertDialog("Password field empty. Please enter password or press \"exit\" to quit.");
  }
  else
  {
    # Check password is correct
    # TODO: md5 should be applied here (need client-version)
    if(checkPass(userId, lPass))
    {
      # Session has been updated, so spawn new session thread
      var lSessionHandler = spawn { sessionCheck(xiHandler) };
      lSessionHandler ! Check();
      
      # Clean form and hide overlay
      var lVoid1 = domSetNodeValueFromRef(lNode, "");
      
      toggleVisible("overlay");
      toggleVisible("session-expired");
      ()
    }
    else
    {
      debug("Password incorrect");
      alertDialog("Password incorrect. Please re-enter your password or press \"exit\" to quit.");
      ()
    }
  }
}

# Re-authenticate a session.
sig checkPass : (Int, String) -> Bool
fun checkPass(xiUid, xiPass) server
{
  var lRes = for (var lUser <-- users)
               where ((lUser.id == xiUid) && (lUser.password == md5(xiPass)))
                 [lUser.id];

  if (length(lRes) == 1)
  {
    # Update the session
    updateSession();
    true
  }
  else
  { false }
}

# Store the code in the database
sig storeFile : (String, Int, String, String) -> 
                [|Failure:String|Success:[(name:String,pos:(finish:Int,line:Int,start:Int),t:String)]|]
fun storeFile(name, pid, escp, code) server 
{
  var lBaseDir = fileLoc ++ testDir ++ getCookie(cookieName) ++ "/";
  
  # Get the path to the file, but drop the project
  var lFilename = drop(1, dropWhile(fun (x) { x <> '/' }, name));

  # Insert if new, update otherwise
  if (not(fileExists(pid, lFilename)))
  {
    insert files values [(id=0, pid=pid, name=lFilename, last_mod="", created="", data=escp, parent = -1, isfolder = 0)];
  }
  else
  {
    update (var lFile <-- files)
      where ((lFile.pid == pid) && (lFile.name == lFilename))
      set (id = lFile.id, pid = lFile.pid, name = lFile.name, last_mod=lFile.last_mod, created = lFile.created, data = escp, parent = lFile.parent, isfolder = 0)
  };

  # Mark the project as dirty
  update (var lProj <-- projectTable)
    where (lProj.id == pid)
    set (id = pid, uid = lProj.uid, name = lProj.name, dirty = 1);
  
  # Get the folders from the filename
  var lList = split("/", name);

  # Create the directories if necessary
  var lNull = 
    for (var lCount <- range(1, (length(lList) - 1)))
    {
      var lCurrDir = lBaseDir ++ join("/", take(lCount, lList));
      if (not(isDir(lCurrDir)))
      {
        var lRes = mkdir(lCurrDir);
        switch (lRes)
        {
          case Ok() -> ()
          case Error(err) -> debug("storefile: " ++ err); ()
        }
      }
      else {};
      []
    };

  updateSession();

  # Get the types here, in order to avoid extra server-calls.
  getTypes(code)
}

# Load a file from the database
sig getFile : (Int, String) -> (data: String, types: [|Failure:String|Success:[(name:String,pos:(finish:Int,line:Int,start:Int),t:String)]|])
fun getFile(xiProjId, xiName) server
{
  var res = for (var lFile <-- files)
    where ((lFile.pid == xiProjId) && (lFile.name == xiName))
    {
      [lFile.data]
    };
  
  # Update the session while we're here
  updateSession();
 
  # Fet file data and types
  var lData = 
    if (length(res) == 0)
      "No such file '" ++ xiName ++ "'."
    else
      hd(res);

  var lTypes = getTypes(lData);

  # Dump types to debug.
  switch (lTypes)
  {
    case Success(types) ->
    {
      var lVoid = 
        (for (var lType <- qsort(types))
         { debug("Name: " ++ lType.name ++ ", type: " ++ lType.t ++ ", POS: " ++ intToString((lType.pos).start) ++ ", " ++ intToString((lType.pos).finish) ++ " - " ++ intToString((lType.pos).line));
          []});
      ()
    }
    case Failure(x) -> debug("Failure: " ++ x)
  };
  
  (data = lData, types = lTypes)
}

# Check if a file exists
sig fileExists : (Int, String) -> Bool
fun fileExists(xiPid, xiName) server
{
  var lCount = for (var lFile <-- files)
    where ((lFile.pid == xiPid) && (lFile.name == xiName))
    [lFile.pid];

  length(lCount) >= 1
}

# Get the full path of a file selected in the project browser
sig getFileData : (Event) -> (pid : Int, path : String)
fun getFileData(xiEvent) client
{
  # Get the events target
  var lOrigDiv = getTargetElement(xiEvent);

  # Find the project and folders that make out the full path to this file
  getPathFromNode(parentNode(findFirstParentDiv(lOrigDiv)))
}

# Recurse up the tree from the given node, returning the proj's id and the path.
sig getPathFromNode : (DomNode) -> (pid : Int, path : String)
fun getPathFromNode(xiNode) client
{
  # Find the next parent div
  var lParent = findFirstParentDiv(xiNode);

  # Check whether it's a project or a folder and get the path
  var lPath = (
    if (domGetAttributeFromRef(lParent, "type") == "folder")
    {
      var lPars = getPathFromNode(parentNode(lParent));
      (pid = lPars.pid, path = (lPars.path ++ (domGetAttributeFromRef(lParent, "cname")) ++ "/")) 
    }
    else
      (pid = stringToInt(domGetAttributeFromRef(lParent, "pid")), 
       path = (domGetAttributeFromRef(lParent, "cname") ++  "/"))
    );

  lPath
}

# Get the body tag containing code
sig getDocumentBody : () -> DomNode
fun getDocumentBody() client
{
  # Get the HTML: find the iframe, then the doc
  var lIfr = getContentDocument(hd(getElementsByTagName("iframe")));
  hd(getElementsByTagNameFromRef("body", lIfr))
}

# Set the current-file bit of the menu bar.
sig setCurrFile : (String) -> ()
fun setCurrFile(xiName) client
{
  var lVoid2 = replaceChildren(stringToXml(xiName), getNodeById("currfile"));
  ()
}

# Get the name of the current file (from the menu bar).
sig getCurrFile : () -> String
fun getCurrFile() client
{
  textContent(firstChild(getNodeById("currfile")))
}

# Set the name of the IFrame 
sig setFrameData : (Int, String) -> ()
fun setFrameData(xiPid, xiName) client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  var lNull1 = domSetAttributeFromRef(lIfr, "name", xiName);
  var lNull2 = domSetAttributeFromRef(lIfr, "pid", (intToString(xiPid)));
  ()
}

# Toggle iframe's 'new' flag (1 on, 0 off).
sig setFrameNew: (Int) -> ()
fun setFrameNew(xiNew) client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  var lNull = domSetAttributeFromRef(lIfr, "new", intToString(xiNew));
  ()
}

# Check whether frame is new.
sig isFrameNew: () -> Bool
fun isFrameNew() client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  domGetAttributeFromRef(lIfr, "new") == "1"
}

# Get the name of the IFrame
sig getFrameData : () -> (pid: Int, fname: String)
fun getFrameData() client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  (pid = stringToInt(domGetAttributeFromRef(lIfr, "pid")),
   fname = domGetAttributeFromRef(lIfr, "name"))
}

# Insert code into the document, then highlight it.
sig insertCode : (Xml) -> ()
fun insertCode(code) client
{
  replaceChildren(code, getDocumentBody());
  highlightCode();
}

# Create a list containing the range of numbers given
sig range : (Int, Int) -> [Int]
fun range(xiStart, xiFinish) 
{
  if (xiStart == xiFinish)
    [xiFinish]
  else if (xiStart > xiFinish)
    []
  else  
    [xiStart] ++ range((xiStart + 1), xiFinish)
}

# Convert escaped string to Xml forest
sig convertData : (String) -> Xml
fun convertData(data) client
{
  var dataList = split("\\n", data); #EscapedLinesJS(data) : [String]; 
  getXmlList(dataList)
}

# Turn a list of strings into XML.
sig getXmlList : ([String]) -> Xml
fun getXmlList(stringList) server
{
    for (var item <- stringList)
    {
      <#>{stringToXml(replace(['\\'], ['\\','\\'], item))} <br /></#>
    } : Xml
}

# Parse the HTML in the children of the reference, getting all the text nodes
sig getCodeLinks : (DomNode) -> String
fun getCodeLinks(ref) client
{
  # If this is is null, there's no text
  if (isNull(ref))
  {
    ""
  }
  else
  {
    var tagName = domGetTagNameFromRef(ref);
    var nextSib = nextSibling(ref);
    
    # Recurse
    var outText = switch (tagName)
    { 
      case "BR" -> "\n" ++ getCodeLinks(nextSib)
      case "SPAN" -> getTextContent(getChildNodes(getValue(ref))) ++ getCodeLinks(nextSib)
      case _ -> getCodeLinks(nextSib)
    };

    outText
  }
}

# Unescape a string recursively.
sig unescape : (String, Char) -> String
fun unescape(text, previous)
{
  switch (text)
  {
    case [] -> []
    case (x::xs) -> 
    {
      debug("Curr: " ++ [x]);
      if ((x == '\\') && (previous == '\\'))
      { 
        unescape(xs, ' ')
      }
      else
      {
        x :: unescape(xs, x)
      }
    }
  }
}

# Handle click events in the project browser.
sig navClick : (Event) -> ()
fun navClick(xiEvent) client
{
  # Get the appropriate nodes.
  var im = getTarget(xiEvent);
  var sndIm = nextElementSibling(nextSibling(im));
  var firstList = findFirstMatchingSibling(nextElementSibling(sndIm), "UL", []);  
  
  # Decide what to do based on the current state.
  switch (domGetAttributeFromRef(getTarget(xiEvent), "src"))
  { 
    case "images/rem-blue-box.png" -> 
    {
      var void2 = domSetAttributeFromRef(im, "src", "images/add-blue-box.png");
      var void3 = domSetAttributeFromRef(sndIm, "src", "images/proj-close.png");
      var void4 = domSetStyleAttrFromRef(firstList, "display", "none");
      ()
    }
    case "images/add-blue-box.png" ->
    {
      var void2 = domSetAttributeFromRef(im, "src", "images/rem-blue-box.png");
      var void3 = domSetAttributeFromRef(sndIm, "src", "images/proj-open.png");
      var void4 = domSetStyleAttrFromRef(firstList, "display", "");
      ()
    }
  };
}

# Given a node, find the first div above it in the tree.
sig findFirstParentDiv : (DomNode) -> DomNode
fun findFirstParentDiv(xiNode) client
{
  switch (getTagName(getValue(xiNode)))
  {
    case "DIV" ->
    {
      xiNode
    }
    case _    -> 
    {
      var parent = parentNode(xiNode);
      if (isNull(parent))
      {
        error("No div element found!")
      }
      else
      {
        findFirstParentDiv(parent)
      }
    }
  }
}

# Returns the first element sibling.
# Expects the first sibling to be the node passed in.
sig nextElementSibling : (DomNode) -> DomNode
fun nextElementSibling(xiNode) client
{
  if (isElementNode(xiNode))
  {
    xiNode
  }
  else
  {
    var sibl = nextSibling(xiNode);

    if (isNull(sibl))
    {
      sibl
    }
    else
    {
      nextElementSibling(sibl)
    }
  }
}

# Given a node, an element type, and a list of attributes, find the
# first sibling of the node that matches the type and attributes.
sig findFirstMatchingSibling : (DomNode, String, [Attribute]) -> DomNode
fun findFirstMatchingSibling(xiNode, xiType, xiConstraints) client
{
  # Check that the node is an element node of the right type and
  # that the constraints match.
  if ((isElementNode(xiNode)) && (getTagName(getValue(xiNode)) == xiType) && 
      (nodeAttributesMatch(xiNode, xiConstraints)))
  {
    # All constraints match - return
    xiNode
  } 
  else
  {
    var child = nextSibling(xiNode);
    if (tmpIsNull(child))
    {
      # Child is null - return it.
      child  
    }
    else
    {
      findFirstMatchingSibling(child, xiType, xiConstraints)
    }
  }
}

# Find all siblings of the given type matching the constraints
sig findAllMatchingSiblings : (DomNode, String, [Attribute]) -> [DomNode]
fun findAllMatchingSiblings(xiNode, xiType, xiConstraints) client
{
  # Return if null, else recurse
  if (tmpIsNull(xiNode))
    []
  else
  {
    var lFirst = findFirstMatchingSibling(xiNode, xiType, xiConstraints);
    
    if (tmpIsNull(lFirst))
      []
    else
      [lFirst] ++ findAllMatchingSiblings(nextSibling(lFirst), 
                                          xiType, 
                                          xiConstraints)
  }
}

# Check whether a list of attributes exist and match for a node.
sig nodeAttributesMatch : (DomNode, [Attribute]) -> Bool
fun nodeAttributesMatch(xiNode, xiAttrs) client
{
  and(for (var attribute <- xiAttrs)
       [domGetAttributeFromRef(xiNode, attribute.attr) == attribute.val])
}

# Look through the project files given recursively and return XML for each.
sig getLProjectList : (ProjectListing, Int, Mailbox ([| SaveFile:(String, Bool)|LoadFile:(String, Event)|a|])) -> Xml
fun getLProjectList(currItem, currLevel, opHandler) client
{
  var width = intToString(currLevel * 16);
      
  # Determine what type of file we've got
  switch (currItem)
  {
    case LProject((id, name), contents) ->
    {
      # This is a top-level node. Start a new list and find all files that
      # belong to the project.
      <li class="proj-list-item">
        <div name="closed" type="proj" cname="{name}" pid="{intToString(id)}" id="proj-{name}"  unselectable="on">
          <img name="box" src="images/add-blue-box.png" l:onclick="{navClick(event)}"/>
          <img src="images/proj-close.png" />  
          <span unselectable="on" style="cursor: default;">
            {stringToXml(name)}
          </span> 
          <ul class="proj-list" style="display: none;">
          {
            # Get the contents of this project
            #var contents = findFiles(currItem);
                       
            # Get the XML
            for (var file <- contents)
              getLProjectList(file, 1, opHandler)
          }
          </ul>
        </div>
      </li>
      
    }
    case LFolder((id, name), contents)  ->
    {
      # This is a folder. Print the folder name, then list files.
      <li class="proj-list-item">
        <div name="closed" type="folder" cname="{name}">  
          <img src="images/blank.png" style="width: {width}; height: 1px;" />
          <img name="box" src="images/add-blue-box.png"  l:onclick="{navClick(event)}" />
          <img src="images/proj-close.png" class="proj-blank" />
          <span>
            {stringToXml(name)}
          </span>
          <ul class="proj-list" style="display: none;">
          {
            #var folderData = findFiles(currItem);
            for (var file <- contents)
              getLProjectList(file, (currLevel + 1), opHandler)
          }
          </ul>
        </div>
      </li>
    }
    case LFile(id, name) ->
    {
      # This is a file. Display it.
      # 
      <li class="proj-list-item">
        <div class="proj-node"> 
          <img src="images/blank.png" style="width: {width}; height: 1px;" />
          <img src="images/blank.png" class="proj-blank" />
          <span class="proj-text"  l:onclick="{loadFile(opHandler, name, event)}">
          {stringToXml(reverse(takeWhile(fun (x) { x <> '/' }, reverse(name))))}
          </span>
        </div>
      </li>
    }
    case _ -> <#></#>
  }
}

# Get project listing
sig getProjectListing : (Projects) -> ProjectListing
fun getProjectListing(currItem) server
{
  switch (currItem)
  {
    case Project(id, name) ->
    {
      # Get the contents of this project
      var lProjData = findFiles(currItem);
                       
      # Get the listings
      var lContents =
        for (var lFile <- lProjData)
          [getProjectListing(lFile)];

      LProject((id, name), lContents)
    }
    case Folder(id, name) -> 
    {
      # Find all the subcomponents of this folder
      var lFolderData = findFiles(currItem);
      
      # Loop through them and add to this listing
      var lContents = 
        for (var lFile <- lFolderData)
          [getProjectListing(lFile)];
      
      # Return the listing
      LFolder((id, name), lContents)
    } 
    case File(id, name) -> LFile(id, name)
  }
}

# Print a debug message on the server
sig serverDbg : (String) -> ()
fun serverDbg(text) server
{
  debug(text);
}

# Get a list of files belonging to a particular container.
sig findFiles : (Projects) -> [Projects]
fun findFiles(container) server
{
  # Check what type of files we're looking for.
  switch (container)
  {
    case Project(id, name) ->
    {
      # It's a project. Only choose files without a parent.
      for (var file <-- files)
        where ((file.pid == id) && (file.parent < 0))
        orderby (file.name)
        {
          switch (file.isfolder)
          {
            case 1 -> [Folder(file.id, file.name)]
            case _ -> [File(file.id, file.name)]
          } 
        }
    }
    case Folder(id, name) ->
    {
      # It's a folder. Find all files/subfolders.
      for (var file <-- files)
        where (file.parent == id)
        orderby (file.name)
        {
          switch (file.isfolder)
          {
            case 1 -> [Folder(file.id, file.name)]
            case _ -> [File(file.id, file.name)]
          }
        } 
    }
    case _ -> error("Not folder or project")
  }
}

# Get the list of projects
sig getProjs : () -> [ProjectListing]
fun getProjs() server
{
  var lProjs = 
    for (var projs <-- projectTable)
      where (projs.uid == userId)
      orderby (projs.name)
        [Project(projs.id, projs.name)];

  for (var lProject <- lProjs)
    [getProjectListing(lProject)]
}

# Get the list of files
sig getFileList : (Int) -> [(id: Int, name: String)]
fun getFileList(projId) server
{
  for (var file <-- files)
    where (file.pid == projId)
      [(id = file.id, name = file.name)]
}

# Add a new file.
sig newFile : (Mailbox ([|SaveFile:(String, Bool)|LoadFile:(String, Event)|a|])) -> ()
fun newFile(xiHandler) client
{
  # Check if doc has changed
  if (docHasChanged())
  {
    # Show box asking if user wants to save
    toggleActionSave(fun () {toggleVisible("new-file")}, xiHandler);
  }
  else 
  {
    toggleVisible("new-file");
  }
}

# Load a file.
sig loadFile : (Mailbox ([|SaveFile:(String, Bool)|LoadFile:(String, Event)|a|]), String, Event) -> ()
fun loadFile(xiHandler, xiName, xiEvent) client
{
  if (docHasChanged())
  {
    toggleActionSave(fun () { xiHandler ! LoadFile(xiName, xiEvent) }, xiHandler);
  }
  else
  {
    xiHandler ! LoadFile(xiName, xiEvent);
  }
}

# Delete new items from the project browser.
sig discardNewFiles: () -> ()
fun discardNewFiles() client
{
  var lNewItems = getElementsByName("new-item");
  
  var lNull =
    for (var lItem <- lNewItems)
    {
      removeNode(lItem);
      []
    };
  ()
}

# Save a file under a new name.
sig saveAs: (String, Mailbox ([|SaveFile:(String, Bool)|LoadFile:(String, Event)|a|])) -> ()
fun saveAs(xiProj, xiHandler) client
{
  var lFileName = domGetNodeValueFromRef(getNodeById("filename"));
  
  if (not(jsMatches(lFileName, "[A-Za-z0-9_-]+(\\.links)?")))
  {
    alertDialog("Illegal filename: only alphanumerics and the characters '-' and '_' are allowed"); 
  }
  else
  {
    # Ensure the filename ends in '.links'.
    var lName =
      if (not(drop((length(lFileName) - 6), lFileName) == ".links"))
        lFileName ++ ".links"
      else
        lFileName;
      
    # Project names are of the form <name>-<pid>
    var lProjInfo = split("-", xiProj);
    var lProjName = hd(lProjInfo);
     
    # Get the new name
    var lRealName = lProjName ++ "/" ++ lName;

    # Set the name to be the new file.
    setFrameData(stringToInt(hd(tl(lProjInfo))), lRealName);
  
    # Set the current file name
    setCurrFile(lRealName);

    # Insert the new file in the project list
    var lProjNode = getNodeById("proj-" ++ lProjName);

    var lNewNode = 
        <li class="proj-list-item">
          <div class="proj-node"> 
            <img src="images/blank.png" style="width: 16; height: 1px;" />
            <img src="images/blank.png" class="proj-blank" />
            <span class="proj-text" l:onclick="{loadFile(xiHandler, lName, event)}">
            {stringToXml(lName)}
            </span>
          </div>
        </li>;

    # Find list node in tree.
    var lListNode = findFirstMatchingSibling(firstChild(lProjNode), "UL", []);

    var lVoid = appendChildren(lNewNode, lListNode);
    
    # Save the file
    # TODO: This gives _very_ strange errors.
    #saveFile(xiHandler, lRealName, false, true);
    xiHandler ! SaveFile(lRealName, true);
  }
}

# Delete the contents of the document, set up new one.
sig clearDoc: (String) -> ()
fun clearDoc(xiProj) client 
{
  # Get the filename
  debug("Getting filename");
  var lFileName = domGetNodeValueFromRef(getNodeById("newfile-name"));

  if (xiProj == "void")
    alertDialog("No projects exist - please create one before creating new files.")
  else if (not(jsMatches(lFileName, "[A-Za-z0-9_-]+(\\.links)?")))
  {
    alertDialog("Illegal filename: only alphanumerics and the characters '-' and '_' are allowed"); 
  }
  else
  {
    # Ensure the filename ends in '.links'.
    var lName =
      if (not(drop((length(lFileName) - 6), lFileName) == ".links"))
        lFileName ++ ".links"
      else
        lFileName;
      
    debug("In Cleardoc");
    debug("Getting doc body");
    var lBody = getDocumentBody();

    # Project names are of the form <name>-<pid>
    debug("Getting proj info");
    var lProjInfo = split("-", xiProj);
    debug("Getting proj name");
    var lProjName = hd(lProjInfo);
    debug("Proj name is: " ++ lProjName);

    var lFullName = lProjName ++ "/" ++ lName;

    # Enable editing
    debug("Enabling editing");
    enableEditable(getNodeById("iframe"));

    # Replace the contents of the document with nothing
    replaceChildren(<#></#>, lBody);
  
    # Set the name to be the new file.
    setFrameData(stringToInt(hd(tl(lProjInfo))), lFullName ++ "*");
  
    # Set the current file name
    setCurrFile(lFullName);

    # Set the title
    setPageTitle("LODE - " ++ lFullName);

    # Mark the iframe as new.
    setFrameNew(1);
 
    # Disable the run button until the file has been saved
    toggleMenuItem("run", false);

    # Ensure that the save and save as options are enabled
    toggleMenuItem("save", true);
    toggleMenuItem("save-as", true);

    # Insert the new file in the project list
    var lProjNode = getNodeById("proj-" ++ lProjName);

    var lNewNode = 
        <li class="proj-list-item" name="new-item" style="cursor: default;" id="new-item-{lName}">
          <div class="proj-node"> 
            <img src="images/blank.png" style="width: 16; height: 1px;" />
            <img src="images/blank.png" class="proj-blank" />
            <span class="proj-text" id="newnode-{lName}" l:onclick="{}" proj="{lProjName}" style="cursor: default;">
            {stringToXml(lName ++ "*")}
            </span>
          </div>
        </li>;

    # Find list node in tree.
    var lListNode = findFirstMatchingSibling(firstChild(lProjNode), "UL", []);

    var lVoid = appendChildren(lNewNode, lListNode);
    
    cleanForm("new-file");
  }
}

# Create new project unless one already exists.
sig newProject : (String) -> ()
fun newProject(xiName) client
{
  var lProjBrowser = getNodeById("proj-list");

  # Check whether a project with that name already exists
  var lProjNodes = findAllMatchingSiblings(firstChild(lProjBrowser),
                                           "LI",
                                           []);

  var lExists = 
    for (var lProj <- lProjNodes)
    {
      var lChild = nextElementSibling(firstChild(lProj));
      debug("CurrNode: " ++ domGetAttributeFromRef(lChild, "cname"));
      if (domGetAttributeFromRef(lChild, "cname") == xiName)
        [true]
      else
        []
    };

  if (length(lExists) > 0)
  {
    # Project exists: user must choose new name.
    alertDialog("A project with that name already exists. Please choose another name.");
    # Show the other popups
    toggleVisible("overlay"); 
    toggleVisible("new-file");

  }
  else if (not(jsMatches(xiName, "[A-Za-z0-9_-]+")))
  {
    # Project name not legal
    alertDialog("Illegal project name: only alphanumerics and the characters '-' and '_' are allowed.");
  
    # Hide the other popup
    toggleVisible("overlay"); 
    toggleVisible("new-file");
  }
  else
  {
    # No such project exists, so create one
    toggleWaiting("Creating project \"" ++ xiName ++ "\" ..");
    var lPid = createProject(xiName, userId);
    toggleWaiting("");
 
    # Create new list items for project browser and new file list.
    var lNewProjListItem = 
      <li class="proj-list-item">
        <div name="closed" type="proj" cname="{xiName}" pid="{intToString(lPid)}" id="proj-{xiName}"  unselectable="on">
          <img name="box" src="images/add-blue-box.png" l:onclick="{navClick(event)}"/>
          <img src="images/proj-close.png" />  
          <span unselectable="on">
            {stringToXml(xiName)}
          </span> 
          <ul class="proj-list" style="display: none;">
          </ul>
        </div>
      </li>;

    var lNewFileListItem =
      <option value="{xiName ++ "-" ++ intToString(lPid)}">{stringToXml(xiName)}</option>;

     # Append list items
    appendChildren(lNewProjListItem, lProjBrowser);
    appendChildren(lNewFileListItem, getNodeById("new-file-file-proj"));
    appendChildren(lNewFileListItem, getNodeById("save-as-proj"));

    cleanForm("new-file");    
  }  
}

# Create a new project for user with uid xiUid.
# The id is passed in rather than fetched server-side to avoid an extra db call.
sig createProject : (String, Int) -> Int
fun createProject(xiName, xiUid) server
{
  # Create the project
  insert projectTable values [(id=0, uid=xiUid, name=xiName, dirty = 0)];

  # Select it to get the pid
  hd(for (var lProj <-- projectTable)
       where ((lProj.uid == xiUid) && (lProj.name == xiName))
         [lProj.id])
}

# Run the current file.
sig runFile : (Mailbox ([|SaveFile:(String, Bool)|a|])) -> ()
fun runFile(xiHandler) client
{
  # Toggle waiting.
  toggleWaiting("Running file..");

  # Get the current location, but drop the filename.
  var lLoc = reverse(dropWhile(fun (x) { x <> '/' }, reverse(getLocation())));
  
  # Get frame data
  var lFrameData = getFrameData();

  # Write file to temp location
  var lFileLoc =  testDir ++ getCookie(cookieName) ++ "/" ++ lFrameData.fname;
  
  # Open a new window pointing to the correct location
  newWindow(lLoc ++ lFileLoc);

  # Toggle waiting.
  toggleWaiting("");
}

# Run the current file, copying all relevant files from the database
sig runFileDb : (Mailbox ([|SaveFile:(String, Bool)|a|])) -> ()
fun runFileDb(xiHandler) client
{
  var lDropFun = fun (x) { x <> '/' };

  # Get the current location, but drop the filename.
  var lLoc = reverse(dropWhile(fun (x) { x <> '/' }, reverse(getLocation())));
  
  # Get frame data
  var lFrameData = getFrameData();

  # Write project
  var lBaseDir = fileLoc ++ testDir ++ getCookie(cookieName) ++ "/";
  var lOk = 
    writeProjectFromDatabase(
      lFrameData.pid, 
      "", 
      lBaseDir
    );

  # Write file to temp location
  var lFileLoc =  testDir ++ getCookie(cookieName) ++ "/" ++ lFrameData.fname;
  
  # Open a new window pointing to the correct location
  newWindow(lLoc ++ lFileLoc);

  if (lOk)
  {
    debug("Run ok");
    ()
  }
  else
  {
    debug("Run failed");
    ()
  }
}

# Deploy the current project if dirty, writing out all files from temp to 
# the user's home dir.
sig deploy : () -> ()
fun deploy() server
{
  # Get the user name
  var lUser = hd(for (var lCurrUser <-- users)
                where (lCurrUser.id == userId)
                  [lCurrUser.email]);
  var lSrcDir = fileLoc ++ testDir ++ getCookie(cookieName) ++ "/";
  var lDstDir = fileLoc ++ deplDir ++ lUser ++ "/";
  
  debug("Src: " ++ lSrcDir);
  debug("Dst: " ++ lDstDir);

  # Get the list of files from this user's tmp dir
  var lFileList = getDirContents(lSrcDir);

  # Move the files one by one to the user's real dir
  var lOk = 
    for (var lFile <- lFileList)
    {
      var lRes = moveFile(lSrcDir ++ lFile, lDstDir ++ lFile);
      switch (lRes)
      {
        case Error(err) -> debug(err); [false]
        case _ -> [true]
      }
    };

  if (and(lOk))
    debug("Deployed successfully!")
  else
    debug("Deployment failed!")
}

# As deploy, but from database rather than temp dir.
sig deployDb : (Int) -> ()
fun deployDb(xiPid) server
{
  # Check that project is dirty
  var lDirty = hd(for (var lProj <-- projectTable)
                 where (lProj.id == xiPid)
                   [lProj.dirty]);

  if (lDirty == 0)
    ()
  else
  {
    # Get the user name
    var lUser = hd(for (var lCurrUser <-- users)
                  where (lCurrUser.id == userId)
                    [lCurrUser.email]);

    var lBaseDir = fileLoc ++ deplDir;
  
    debug("Dst: " ++ lBaseDir ++ "/" ++ lUser);

    # Move the files one by one to the user's real dir
    var lOk = writeProjectFromDatabase(xiPid, lUser, lBaseDir);

    if (lOk)
    {
      # Update the project to be non-dirty
      update (var lProj <-- projectTable)
        where (lProj.id == xiPid)
        set (id = xiPid, uid = lProj.uid, name = lProj.name, dirty = 0);

      debug("Deployed successfully!")
    }
    else
      debug("Deployment failed!")
  }
}

# Write out the contents of a whole project to disk.
sig writeProjectFromDatabase : (Int, String, String) -> Bool
fun writeProjectFromDatabase(xiPid, xiName, xiBaseDir) server
{
  # Find the project's name
  var lProjName = hd(for (var lProj <-- projectTable)
                    where (lProj.id == xiPid)
                      [lProj.name]);

  # Get the directory
  var lProjDir = xiBaseDir ++ xiName ++ "/" ++ lProjName ++ "/";

  # Create directory for project
  switch(mkdir(lProjDir))
  {
    case Ok() -> ()
    case Error(err) -> debug("mkdir " ++ lProjDir ++ ": " ++ err)
  };      
    
  # Find all the folders for this project
  var lFolders = for (var lFolder <-- files)
                   where ((lFolder.pid == xiPid) && (lFolder.isfolder == 1))
                   orderby (lFolder.name)
                     [lFolder.name];

  # Create directories for folders
  var lResFolders = 
    for (var lFolder <- lFolders)
    {
      var lRes = mkdir(lProjDir ++ lFolder);
      [switch(lRes)
      {
        case Ok() -> true
        case Error(err) -> debug("mkdir " ++ lProjDir ++ lFolder ++ ": " ++ err); false
      }]
    };

  # Find all files for this project
  var lFileList = for (var lFile <-- files)
                    where ((lFile.pid == xiPid) && (lFile.isfolder == 0))
                      [lFile.name];
  
  # Write out each file
  var lRes = for (var lFile <- lFileList)
               [writeFromDatabase(xiPid, lFile, lProjDir)];

  # Return the results
  and(lRes ++ lResFolders)
}

# Write data from the database to file on disk.
# Returns file location
sig writeFromDatabase : (Int, String, String) -> Bool
fun writeFromDatabase(xiPid, xiName, xiDir) server
{ 
  # Get the data
  var lFileData = getFile(xiPid, xiName);

  # Clean it up.
  var lCleanData = lFileData.data;

  # Write to disk
  var lRes = writeToFile(xiDir ++ xiName, lCleanData);

  # Check the result, debug and return false on error
  switch (lRes)
  {
    case Error(err) -> debug("WriteToFile: " ++ err); false
    case Ok() -> true
  }
}

# Get the list of projects owned by a user from the project browser and
# use it to populate the list in the 'Save As'-pop-up.
sig getProjectList : () -> ()
fun getProjectList() client
{
  # Check if the project list has already been fetched for this session
  var lProjectListNew  = getNodeById("new-file-file-proj");
  var lProjectListSave = getNodeById("save-as-proj");

  if (domGetAttributeFromRef(lProjectListNew, "fetched") == "no")
  {
    # Find project list
    var lProjBrowser = getNodeById("proj-list");

    # Find all UL siblings
    var lList = findAllMatchingSiblings(firstChild(lProjBrowser), "LI", []);
  
    var lProjects = 
      if (length(lList) > 0)
      {
         # Set the lists as fetched so we don't have to this again
        var lVoid = domSetAttributeFromRef(lProjectListNew, "fetched", "yes");

        <#>
          {
            for (var lItem <- lList)
            {
              var lNode = nextElementSibling(firstChild(lItem));
              var lName = domGetAttributeFromRef(lNode, "cname");
              var lId   = domGetAttributeFromRef(lNode, "pid");
              <option value="{lName ++ "-" ++ lId}">{stringToXml(lName)}</option>
            }
          }
        </#>
      }
      else
      {
        <option value="void" pid="-1">-- No Projects --</option>
      };

    # Insert the list items into the lists.
    replaceChildren(lProjects, lProjectListNew);
    replaceChildren(lProjects, lProjectListSave)
    
  }
  else {}
}

# Get the menubar. 
sig getMenu : (Mailbox ([|SaveFile:(String, Bool)|LoadFile:(String, Event)|a|])) -> Xml
fun getMenu(opHandler) client
{
  <#>
    <div id="menubar">
      <dl>
        <dt id="menu-file-cap" l:onclick="{toggleMenu("menu-file");}" class="menuhead"><span>File</span></dt>
        <dd id="menu-file" style="width: 120px;">
          <ul id="menulist" class="menulist">
            <li l:onclick="{toggleMenu("menu-file"); getProjectList(); newFile(opHandler);}" unselectable="on"><span>New..</span></li>
            <li class="disabled" id="menu-item-save-off" unselectable="on"><span>Save</span></li>
            <li class="invisible" id="menu-item-save" l:onclick="{toggleMenu("menu-file"); saveCurrent(getFrameData(), opHandler);}" unselectable="on"><span>Save</span></li>
            <li class="disabled" id="menu-item-save-as-off" unselectable="on"><span>Save as..</span></li>
            <li class="invisible" id="menu-item-save-as" l:onclick="{toggleMenu("menu-file"); getProjectList(); toggleVisible("overlay"); toggleVisible("save-file");}" unselectable="on"><span>Save as.. </span></li>
            <li style="height: 1px;"><hr style="height: 2px;" /> </li>
            <li l:onclick="{toggleMenu("menu-file"); toggleChecked("session", updateSession)}"><img src="images/check.png" style="position: relative; top: 2px;" id="session-check" enabled="yes"/><span style="margin-left: 0px; top: -1px;">Session timeouts</span></li>
            <li l:onclick="{toggleMenu("menu-file"); toggleChecked("autosave", fun () {})}"><img src="images/check.png" style="position: relative; top: 2px;" id="autosave-check" enabled="yes"/><span style="margin-left: 0px; top: -1px;">Auto-save Files</span></li>
            <li style="height: 1px;"><hr style="height: 2px;" /> </li>
            <li l:onclick="{toggleMenu("menu-file"); toggleWaiting("Logging out.."); logoutClient()}" unselectable="on"><span>Logout</span></li>
          </ul>
        </dd>
      </dl>
      <dl>
        <dt id="menu-proj-cap" l:onclick="{toggleMenu("menu-proj");}" class="menuhead"><span>Project</span></dt>
        <dd id="menu-proj">
          <ul id="menulist" class="menulist">
            <li class="disabled" id="menu-item-run-off" unselectable="on"><span>Run</span></li>
            <li class="invisible" id="menu-item-run" unselectable="on" l:onclick="{toggleMenu("menu-proj"); toggleWaiting("Running file.."); runFileDb(opHandler); toggleWaiting("");}"><span>Run</span></li>

            <li style="height: 1px;"><hr style="height: 2px;" /> </li> 
            <li class="disabled" id="menu-item-deploy-off" unselectable="on"><span>Deploy</span></li>
            <li class="invisible" id="menu-item-deploy" l:onclick="{toggleMenu("menu-proj"); toggleWaiting("Deploying project.."); deployDb((getFrameData()).pid); toggleWaiting("");}" unselectable="on"><span>Deploy</span></li>
          </ul>
        </dd>
      </dl>
    </div>
  </#>
}

# Save the current file.
sig saveCurrent : ((pid: Int, fname: String), 
                    Mailbox ([|SaveFile:(String, Bool)|LoadFile:(String, Event)|a|])) -> ()
fun saveCurrent(xiData, xiHandler) client
{
  var lMatchFun = fun (x) { x <> '*' };

  # Check if a save is needed
  if (hd(reverse(xiData.fname)) == '*')
  {
    var lRealName = takeWhile(lMatchFun, xiData.fname);

    debug("RealName: " ++ lRealName);
    
    debug("Calling saveFile");
    xiHandler ! SaveFile(lRealName, true);
   
    debug("Setting frame data");
    setFrameData(xiData.pid, lRealName);

    # Check if frame is new, replace with linked version
    var lDispName = drop(1, dropWhile(fun (x) { x <> '/' }, lRealName));
    var replaceNewItems = fun (xiName)
    {
      if (isFrameNew())
      {
        var lOldNode = getNodeById("newnode-" ++ xiName);
        var lNewNode =
            <span class="proj-text" l:onclick="{loadFile(xiHandler, xiName, event)}">
              {stringToXml(xiName)}
            </span>;
        # Set the list item to be non-new
        var lVoid = domSetAttributeFromRef(getNodeById("new-item-" ++ xiName), "id", "");

        replaceNode(lNewNode, lOldNode);
        setFrameNew(0);
      } else {}
    };

    replaceNewItems(lDispName);
  } else {};
}

# Check if the document has been altered.
sig docHasChanged : () -> Bool
fun docHasChanged() client
{
  var lFrameName = (getFrameData()).fname;
  # See if there's a star in the framename.
  length(dropWhile(fun (x) { x <> '*' }, lFrameName)) == 1
}

# Check whether an option is enabled.
sig optionEnabled : (String) -> Bool
fun optionEnabled(xiName) client
{
  var lNode = getNodeById(xiName ++ "-check");
  (domGetAttributeFromRef(lNode, "enabled")) == "yes"
}

# Turn the options on/off, and sort out the tick in the menu.
# The function passed in is to be executed when the option is enabled.
sig toggleChecked : (String, (() -> ()	   )) -> ()
fun toggleChecked(xiName, xiFn) client
{
  # If change from off -> on, update session
  var lListImage = getNodeById(xiName ++ "-check");

  var lNewImage = 
    switch (domGetAttributeFromRef(lListImage, "enabled"))
    {
      case "yes" -> <img src="images/blank.png" style="height: 16px; width: 16px;" id="{xiName ++ "-check"}" enabled="no" />
      case _   ->
      {
        # Perform pre-enabling function
        xiFn();

        <img src="images/check.png" style="position: relative; top: 2px;" id="{xiName ++ "-check"}" enabled="yes" />
      }
    };

  replaceNode(lNewImage, lListImage);
}

# (Dis/En)able an item in the menu
sig toggleMenuItem : (String, Bool) -> ()
fun toggleMenuItem(xiName, xiOn) client
{
  var lNodeOn  = getNodeById("menu-item-" ++ xiName);
  var lNodeOff = getNodeById("menu-item-" ++ xiName ++ "-off");

  if (xiOn)
  {
    # Enable the node
    var lVoid1 = domSetStyleAttrFromRef(lNodeOn, "display", "list-item");
    var lVoid2 = domSetStyleAttrFromRef(lNodeOff, "display", "none");
    ()
  }  
  else
  {
    # Disable the node
    var lVoid1 = domSetStyleAttrFromRef(lNodeOn, "display", "list-item");
    var lVoid2 = domSetStyleAttrFromRef(lNodeOff, "display", "none");
    ()
  };
}

# Toggle save-before-[action] display. Takes the action to perform as arg.
sig toggleActionSave : ((() -> ()),Mailbox ([|SaveFile:(String, Bool)|LoadFile:(String, Event)|a|]))  -> ()
fun toggleActionSave(xiFn, xiHandler) client
{
  var lSave =
   <#>
     <input type="button" name="save" l:onclick="{saveCurrent(getFrameData(), xiHandler); toggleVisible("maybe-save"); xiFn() }" value="Save" />
     <input type="button" name="discard" l:onclick="{toggleVisible("maybe-save"); setInvisible("overlay"); discardNewFiles(); xiFn()}" value="Don't Save" />
     <input type="button" name="cancel" l:onclick="{toggleVisible("maybe-save"); setInvisible("overlay");}" value="Cancel" />
   </#>;

  var lNode       = getNodeById("maybe-save");
  var lInputNode  = getNodeById("maybe-save-input");
 
  switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" ->
    {
      var lVoid1 = domSetStyleAttrFromRef(lInputNode, "display", "none");
      var lVoid2 = domSetStyleAttrFromRef(lNode, "display", "none");
      ()
    }
    case _       ->
    {
      # Set the save action
      var lButtonNode = getNodeById("maybe-save-buttons");
      replaceChildren(lSave, lButtonNode);
     
      # Display the node
      var lVoid2 = domSetStyleAttrFromRef(lNode, "display", "block");
      ()
    }
  };
  
  # Toggle the overlay
  toggleVisible("overlay");
}

# Show/hide all menu items
sig toggleMenu : (String) -> ()
fun toggleMenu(xiName) client
{
  var lNode = getNodeById(xiName);
  var lVoid = switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" -> domSetStyleAttrFromRef(lNode, "display", "none")
    case _       -> domSetStyleAttrFromRef(lNode, "display", "block")
  };

  toggleBgColour(xiName ++ "-cap", "rgb(133, 177, 255)");
}

# Toggle an element's visibility on/off
sig toggleVisible : (String) -> ()
fun toggleVisible(xiName) client
{
  var lNode = getNodeById(xiName);
  var lOverlay = getNodeById("overlay");
  var lVoid = switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" -> 
    {
      var lVoid = domSetStyleAttrFromRef(lOverlay, "display", "none");
      domSetStyleAttrFromRef(lNode, "display", "none")
    }
    case _      -> 
    {
      var lVoid = domSetStyleAttrFromRef(lOverlay, "display", "block");
      domSetStyleAttrFromRef(lNode, "display", "block")
    }
  };
  ()
}

# Toggle the background colour of the given node.
sig toggleBgColour : (String, String) -> ()
fun toggleBgColour(xiName, xiColour)
{
  var lNode = getNodeById(xiName);
  var lVoid = 
    if (length(domGetStyleAttrFromRef(lNode, "background")) > 1)
      domSetStyleAttrFromRef(lNode, "background", "")
    else
      domSetStyleAttrFromRef(lNode, "background", xiColour);
  
  ()
}

# Toggle the 'waiting' box. Text is the heading to use.
sig toggleWaiting : (String) -> ()
fun toggleWaiting(xiText) client
{
  var lNode = getNodeById("waiting");
  var lTextNode = getNodeById("waiting-text");

  # Node to use.
  var lText = 
      <span style="padding: 2px 3px 3px; font-size: 12px; height: 14px; font-weight: bold;" class="caption-text" id="waiting-text">
        {stringToXml(xiText)}
      </span>;

  switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" ->
    {
      var lVoid = domSetStyleAttrFromRef(lNode, "display", "none");
      ();
    }
    case _ ->
    {
      var lVoid  = domSetStyleAttrFromRef(lNode, "display", "block");
      replaceNode(lText, lTextNode);
    }
  };
  toggleVisible("overlay");
}

# Set a node to be invisible
sig setInvisible : (String) -> ()
fun setInvisible(xiName) client
{
  var lVoid = domSetStyleAttrFromRef(getNodeById(xiName), "display", "none");
  ();
}

# Recursive function to get a node's siblings.
# Only works for element nodes.
sig getSiblingsLinks : (DomNode) -> [DomNode]
fun getSiblingsLinks(xiNode) client
{
  var lXmlNode = getValue(xiNode);
  serverDbg("Tagname: " ++ getTagName(lXmlNode));
  serverDbg("Type? " ++ getAttribute(lXmlNode, "type"));
  if ((not(isElementNode(xiNode))) || (isNull(xiNode)))
    []
  else
    [xiNode] ++ getSiblingsLinks(nextElementSibling(xiNode))
}

# Clean the contents of a form.
# @TODO: broken. Looping doesn't work for DomNode lists?
sig cleanForm : (String) -> ()
fun cleanForm(xiName) client
{
  var lFirst = nextElementSibling(firstChild(getNodeById(xiName)));
  var lVoid = for (var lNode <- getSiblings(lFirst))
  {
    var lXmlNode = getValue(lNode);
    if ((getTagName(lXmlNode) == "INPUT") && (getAttribute(lXmlNode, "type") == "text"))
        domSetNodeValueFromRef(lNode, "")
      else {};
    []
  };
  
  # Hide the overlay and the form
  setInvisible("overlay");
  setInvisible(xiName);
}

# Returns the HTML needed for the 'hidden' objects, i.e. the various dialogs.
sig getHiddenObjects : (Mailbox ([|SaveFile:(String, Bool)|LoadFile:(String, Event)|a|])) -> Xml
fun getHiddenObjects(opHandler) client
{
  <#>
    <div class="overlay" id="overlay"></div>
    <div id="new-file" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Create New</span>
        </div>
        <div id="new-file-file">
          <div class="container-box">
            <span class="popup-text padded">
Project:<br />
              <select name="project" id="new-file-file-proj" class="input-box" fetched="no">
              </select><br /><br />
              Name:<br />
              <input type="text" class="input-box proj-items" id="newfile-name" />
            </span>
            <div>
              <span l:onclick="{setInvisible("new-file-file"); toggleVisible("new-file-proj");}" class="popup-swap padded">Create project.. </span>
            </div>
          </div>
          <div class="bottombar">
            <input type="button" name="save" l:onclick="{clearDoc(domGetNodeValueFromRef(getNodeById("new-file-file-proj")));}" value="Create new" />
            <input type="button" name="cancel" l:onclick="{cleanForm("new-file")}" value="Cancel" />
          </div>
        </div>
        <div id="new-file-proj" class="invisible">
          <div class="container-box">
            <span class="popup-text padded">
              Name:<br />
              <input type="text" class="input-box proj-items" id="newproj-name" />
            </span>
            <div>
              <span l:onclick="{setInvisible("new-file-proj"); toggleVisible("new-file-file");}" class="popup-swap padded">Create file.. </span>
            </div>
          </div>
          <div class="bottombar">
            <input type="button" name="save" l:onclick="{setInvisible("overlay");  toggleVisible("new-file"); newProject(domGetNodeValueFromRef(getNodeById("newproj-name")));}" value="Create new" />
            <input type="button" name="cancel" l:onclick="{cleanForm("new-file")}" value="Cancel" />
          </div>
        </div>
      </div>
    </div>
    <div id="save-file" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Save file</span>
        </div>
        <div class="container-box">
          <span class="popup-text padded">
            Project:<br />
            <select name="project" id="save-as-proj" class="input-box">
              </select><br /><br />
            Name:<br />
            <input type="text" class="input-box proj-items" id="filename" />
          </span>
        </div>
        <div class="bottombar">
          <input type="button" name="save" l:onclick="{saveAs(domGetNodeValueFromRef(getNodeById("save-as-proj")), opHandler); setInvisible("overlay"); setInvisible("save-file")}" value="Save" />
          <input type="button" name="cancel" l:onclick="{cleanForm("save-file")}" value="Cancel" />
        </div>
      </div>
    </div>
    <div id="maybe-save" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Save current file?</span>
        </div>
        <div id="maybe-save-input" class="container-box invisible">
          <span class="proj-items padded">
            Name:<br />
            <input type="text" class="input-box proj-items" id="save-filename" />
          </span>
        </div>
        <div class="bottombar" id="maybe-save-buttons">
          <input type="button" name="save" l:onclick="{saveCurrent(getFrameData(), opHandler); toggleVisible("maybe-save"); toggleVisible("new-file"); }" value="Save" />
          <input type="button" name="cancel" l:onclick="{toggleVisible("maybe-save"); setInvisible("overlay");}" value="Don't Save" />
        </div>
      </div>
    </div>
    <div id="waiting" class="invisible">
      <div class="centered box">
        <img src="images/waiting.gif" style="float: left; padding-right: 6px; padding-top: 2px;" />
        <span id="waiting-text"></span>
      </div>
    </div>
    <div id="session-expired" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Session expired</span>
        </div>
        <div id="session-expired-input" class="container-box">
          <span class="popup-text padded">
            Your session has expired. <br />Please re-enter your password
             to resume session, or press exit to quit.<br /><br />
              Password:<br />
            <input type="password" class="input-box proj-items" id="resume" />
          </span>
        </div>
        <div class="bottombar">
          <input type="button" name="save" l:onclick="{resumeSession(opHandler);}" value="Resume" />
          <input type="button" name="cancel" l:onclick="{logout()}" value="Exit" />
        </div>
      </div>
    </div>
  </#>
}

# Returns the HTML needed for the project browser.
sig getProjBrowser : (Mailbox ([|SaveFile:(String, Bool)|LoadFile:(String, Event)|a|])) -> Xml
fun getProjBrowser(opHandler) client
{
    <div id="proj-browser" class="proj-browser">
      <div id="proj-caption-bg" class="caption-bg">
        <span id="proj-caption" class="caption-text" unselectable="on">Project Browser</span>
      </div>
      <div id="proj-items" class="proj-items">
        <ul class="proj-list" id="proj-list">
         {
           #var lProjs = getProjs();
           for (var lProjs <- getProjs())
             getLProjectList(lProjs, 0, opHandler)
         }  
        </ul>
      </div>
    </div>
}

# Returns the HTML needed for the code editor.
sig getEditor : () -> Xml
fun getEditor() client
{
#var editor = new CodeMirror((document.getElementById("editor")), {{width: "100%", height: "100%"}});
    <div id="editor" class="editor">
      <script type="text/javascript">
        var textarea = document.getElementById("editor");
        var editor = new CodeMirror(textarea, {{
          height: "100%",
          width: "100%",
          parserfile: ["tokenizelinks.js", "parselinks.js"],
          stylesheet: "editor/highlight.css",
          path: "editor/"
        }});
        
        //window.editor = editor;
      </script>
    </div>
}

# Render the editor.
sig renderObject : () -> Xml
fun renderObject() client
{
  # Spawn file handling object.
  var opHandler = spawn { fileOp() };

  # Spawn the session handler, passing the file-handler in as an argument.
  var sessionHandler = spawn { sessionCheck(opHandler) };

  # Start it off.
  sessionHandler ! Check();
  
  <#>
    {
      getHiddenObjects(opHandler)
    }
    <div id="contain-left" class="contain-left">
      <div id="values" class="menu" style="border-right: 0px;">
      {
        getMenu(opHandler)
      }
      </div>
      {
        getProjBrowser(opHandler)
      }
      <div id="space" class="space"></div>
    </div>
    <div id="contain-right" class="contain-right">
      <div id="topbar" class="menu menu-file-cap" style="border-left: 0px none; padding-top: 6px; height: 19px; width: 90%; text-align: right;">
        <span id="currfile" style="font-family: tahoma,verdana; font-size: 11px; margin-right: 10px;"></span>
      </div>
      {
        getEditor()
      }
    </div>
  </#>
}

# Main function. 
sig main : () -> Xml
fun main() client 
{
  # Redirect to login if not logged in.
  if (not(isLoggedIn()))
  {
    logoutClient();
    <html></html>
  }
  else
  {
  <html>
    <head>
      <title>ug4proj: Links</title>
    </head>
    <script src="editor/codemirror.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="proj.css" />
    <body>
      <div id="main" style="z-index: 1;">
      {
        # Set the page title explicitly.
        setPageTitle("LODE - Links Online Development Environment");
        renderObject()
      }
      </div>
    </body>
  </html>
  }
}

page
  <#>{ main() }</#>
  
