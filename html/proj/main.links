# TODO:
#
# - Sort out right-click menu for project list.
#    * Figure out how to distinguish between left/right mouse clicks (done)
#    * Recreate stopPropagation (is it gone?) (done, but won't work)
#      -- Sam has been notified, appears to be Links issue.

# - Clean up SQL calls - there's about 5 for loading the project list..
#    * Clean up client/server calls in general. Somewhere, a server function is making a client call... (done - project list getting was silly, and opHandler requires server -> client calls if used on server).

# - 'New' menu option changes
#    * new files added to project list on creation in right project 
#      -- Project needs to be embedded in iFrame (done)
#    * add capabilities for adding new projects/folders
#    * new project creates new directory on disk
#    * new project gets added

# - Figure out why logging out doesn't work.
#    * Possibly due to calling server function direct? (done - using js now)

# - Test/Deploy configuration. Needs:
#    * Create-dir function (done)
#    * Delete-dir function (done)
#    * Account creation creates user dir
#    * Logging in needs to create new dir based on sessionId (done)
#    * Logging out needs to delete dir (done, but error?)
#    * Deploy copies from test to deploy (done)
#    * What happens when users want to test files linking to files not being tested? Maybe it's better to mark files as 'unclean' in database, then dump them out during testing, and copy them from database during deploy? (done, but need to make sure directories are created properly (done))

# - Typing information. Needs:
#    * Types retrieved on save/load (done)
#    * Find appropriate nodes, attach info (done - tho some types not returned in order?)

# - Is it possible to capture key presses from the iframe without creating node in Links? Probably not - means that 'edited file' can't be captured. Kind of sorted: run/deploy disabled on no file, run disabled on new file.

# - New files in browser need:
#    * To get LoadFile attached when saved. (no)
#    * To be deleted from browser if load happens without save. (done)

######
# JavaScript functions
##
# Split lines
alien javascript splitEscapedLinesJS : (String) -> [String];

# Call the code highlighting function of the edit-box.
alien javascript highlightCode : () -> ();

# Return node.value.
alien javascript getValueFromRef : (DomNode) -> String; 

# Convert spaces to 
alien javascript convertSpaces : (String) -> String;

# Load the IDE's editor.
alien javascript loadEditor: () -> DomNode;
alien javascript getSiblings: (DomNode) -> [DomNode];

# Get the current location (ie URL)
alien javascript getLocation: () -> String;

# Create a new window using the URL passed in.
alien javascript newWindow: (String) -> ();

# Normal (un-)escaping
alien javascript jsUnescape: (String) -> String;
alien javascript jsEscape: (String) -> String;

# Get nodes from a foreign document
alien javascript getElementsByNameFromDocument: (DomNode, String) -> [DomNode];

# Get value
alien javascript getTextValue: (DomNode) -> String;

# Redirect using JavaScript to avoid having to submit form.
alien javascript redirectClient: (String) -> ();

# Given an iframe, enable contentEditable for that doc.
alien javascript enableEditable: (DomNode) -> ();

######
# Attribute type
typename Attribute = (attr: String, val: String);

# Things that should be in their own file
var cookieName = "linkside";
var fileLoc = "/home/tom/links/html/proj/";
var testDir = "test/";
var deplDir = "users/";

typename User = (name:String, password:String);
typename ProjConts = (Int, String);
typename Projects = [| Project : ProjConts | Folder : ProjConts | File : ProjConts |];

typename ProjectListing = mu proj.[| LFile : ProjConts | LProject : (ProjConts, [proj]) | LFolder : (ProjConts, [proj]) |];

# Databases to access
var users = table "users" with (
    id : Int,
    email: String,
    password: String
) from (database "ide");

var projectTable = table "projects" with (
    id : Int,
    uid : Int,
    name : String,
    dirty : Int
) from (database "ide");

var files = table "files" with (
    id : Int,
    pid : Int,
    name : String,
    last_mod : String,
    created : String, 
    data : String,
    parent : Int,
    isfolder : Int
) from (database "ide");

var sessionsTable = table "sessions" with (
    id : String,
    uid : Int,
    creation_time : Int,
    update_time : Int
) from (database "ide");

var validSessions = table "valid_sessions" with (
    id : String,
    uid : Int
) from (database "ide");

# Count the number of elements in a list
fun numElems(lst) server
{
  switch(lst)
  {
    case [] -> 0
    case x::xs -> 1 + numElems(xs)
  }
}

# Logout from the IDE (doesn't redirect)
sig logout : () -> ()
fun logout() server
{
  var lId = getCookie("linkside");
  delete (var sessId <-- sessionsTable)
    where (sessId.id == lId);

  # Delete temporary directory (and all its contents..)
  switch (rmdirForce(fileLoc ++ testDir ++ lId))
  {
    case Error(err) -> debug("Error on rmdir: " ++ err);
    case _ -> ()
  };

  setCookie("linkside","");
}

sig logoutClient : () -> ()
fun logoutClient() client
{
  # Get current location, dropping the filename.
  var lLoc = reverse(dropWhile(fun (x) { x <> '/' }, reverse(getLocation())));

  # Kill the session, remove temp dir etc.
  logout();

  # Redirect
  redirectClient(lLoc ++ "login.links");
}
  
##
# Normal code.
##

# Return the uid of the current sessions' owner.
sig getUid : () -> Int
fun getUid() server
{
  debug("Getting UID");
  var uids = for (var sid <-- sessionsTable)
             where (sid.id == getCookie("linkside"))
              [sid.uid];
  if (length(uids) == 0)
    1
  else
    hd(uids)
}

# Userid of session owner
var userId = getUid();

# Check whether the user is logged in
sig isLoggedIn : () -> Bool
fun isLoggedIn() server
{
  var sessId = getCookie(cookieName);
  debug("cookie: " ++ sessId);
  # Check that the sessid exists in the database
  var p = length(for (var lSess <-- validSessions)
    where (lSess.id == sessId)
      [lSess.id]) == 1;
  (if (p)
    debug("logged in")
  else
    debug("not logged in"));
  #p
  true
}

# Perform file operations (load, save).
fun fileOp() client
{
  receive 
  {
    case SaveFile(name, escp, code) -> 
    {
      var lFileData = getFrameData();
      #var lTypes = getTypes(code);
      #var lVoid = if (lTypes == []) [] else {
      #  for (var lCurr <- lTypes)
      #  {
      #    debug("Name: " ++ lCurr.name ++ "; type: " ++ lCurr.t);
      #    []
      #  }};
      
      # Get types and attach if ok.
      var lTypes = storeFile(name, lFileData.pid, escp, code); 

      switch (lTypes)
      {
        case Failure(err) -> debug("Type error: " ++ err)
        case Success(typ) -> attachTypes(typ);
      };

      setFrameData(lFileData.pid, name);
   
      # Enable the run/deploy menu items
      toggleMenuItem("run", true);
      toggleMenuItem("deploy", true);

      fileOp()
    }
    case LoadFile(name, lEvent) -> 
    {
       toggleWaiting("Loading file..");
       var lFileData = getFileData(lEvent);
       var lProjId = lFileData.pid;

       # This could be done when getting the path, so
       # slightly unnecessary, but just to be sure we can 
       # choose how we want to be organised..
       var lFullName = 
         takeWhile(fun (x) { x <> '/' }, lFileData.path) ++ "/" ++ name;

       var lFileData = getFile(lProjId, name);
       var lData = lFileData.data;
       var lTypes = lFileData.types;

       #debug("Getting types");
       #var lTypes = getTypes(lData);

       debug("Convert data");
       var rval = convertData(lData) : Xml;

       debug("Insert code");
       insertCode(rval);

       switch (lTypes)
       {
         case Failure(err) -> debug("Type error: " ++ err)
         case Success(typ) -> debug("Success!"); attachTypes(typ)
#         {
#           debug("Success!");
#           var lVoid = if (typ == []) [] else {
#           for (var lCurr <- typ)
#           {
#             debug("Name: " ++ lCurr.name ++ "; type: " ++ lCurr.t);
#             []
#           }};
#           debug("Attach types"); 
#           attachTypes(typ);
#           debug("Types attached!");
#         }
       };
       
       #attachTypes(lTypes);

       # Set current file and frame name
       setCurrFile(lFullName);
       setFrameData(lProjId, lFullName);
     
       # Enable editing
       enableEditable(hd(getElementsByTagName("iframe")));

       # Enable the run/deploy menu items
       toggleMenuItem("run", true);
       toggleMenuItem("deploy", true);
              
       toggleWaiting("");
       fileOp()
    }
  }
}

fun sessionCheck(xiFileHandler) client
{
  receive
  {
    case Exit() -> ()
    case Check(xiHandler) ->
    {
      debug("Session check..");
      # Sleep for 1min
      sleep(60);
 
      # Auto save document if it's been changed.
      # TODO: Currently brings up 'Saving..' thing. Disable.
      # Also, need to remove * from filename.
      if ((docHasChanged()) && (not(isFrameNew())))
      {
        debug("Auto-saving..");
        var lData = getFrameData();
        var lRealName = takeWhile(fun (x) { x <> '*' }, lData.fname);
        saveFile(xiFileHandler, lRealName, true);
        setFrameData(lData.pid, lRealName);
      } else {};
        
      # Check if session timeouts are turned on.
      if ((domGetAttributeFromRef(
             getNodeById("session-check"), "enabled")
           ) == "yes")
      {
        # Check that the session is active
        if(isLoggedIn())
        {
          debug("User is logged in");
        
          # Loop
          xiHandler ! Check(xiHandler) 
        }
        else
        {  
          # Display message if it isn't
          debug("User's session has expired");
          toggleVisible("overlay");
          toggleVisible("session-expired")        
        };
      } 
      else
      {
        debug("Session handling disabled");

        # Loop
        xiHandler ! Check(xiHandler) 
      };

      sessionCheck(xiFileHandler)
    }
  }
}

# Get the types from a particular piece of code.
sig getTypes : (String) -> [|Failure:String|Success:[(name:String,pos:(finish:Int,line:Int,start:Int),t:String)]|]
fun getTypes(xiCode) server
{
  dumpTypes(xiCode)
}

# Attach the types to the nodes in the actual document.
sig attachTypes : ([(name:String, pos:(finish:Int, line:Int, start: Int), t:String)]) -> ()
fun attachTypes(xiList) client
{
  # Find iFrame
  var lIframe = getDocumentBody();

  #var lList = reverse(xiList);

  var lTypeNames = map(fun (x) { (x.name, x.t) }, xiList);

  # Find references to functions/vars
  debug("Match types");
  var lNodes = 
    matchTypes(lTypeNames, 
               getElementsByNameFromDocument(
                 getContentDocument(hd(getElementsByTagName("iframe"))), 
                 "variable"
               ));

  var getFromList = fun (count, list) { hd(drop(count, list)) };

  if (length(xiList) == length(lNodes))
  {
    var bla = 
      for (var lCount <- range(0, (length(xiList) - 1)))
      {
        var lVoid = domSetAttributeFromRef(hd(drop(lCount, lNodes)), 
                                           "title", 
                                           (hd(drop(lCount, xiList))).t); 
        []
       };
    ()
  }
  else 
  { 
    debug("Lists of different length.");
    debug("Num var nodes: " ++ intToString(length(lNodes)));
    debug("Num types: " ++ intToString(length(xiList)));
  };
  # Attach 
}

# Match a list of types (given as (name, type)) to a list of Nodes, removing
# those nodes that don't have a type. Possibility of this failing if a 
# top-level function is overwritten by a local function of the same name?
sig matchTypes : ([(String, String)], [DomNode]) -> [DomNode]
fun matchTypes(xiTypes, xiList) client
{
  switch (xiList)
  {
    case [] -> []
    case (x::xs) -> 
    {
      var lSpaceFun = fun (c) { ord(c) <> 160 };
      var lText = remSpace(getTextValue(firstChild(x)));

      # Allow l:events
      # We're doing this in a stupid way to work around the fact
      # that hd([String]) returns a char here..?
      if ((lelem(lText, xiTypes)) || (take(2, lText) == "l:"))
        [x] ++ matchTypes(xiTypes, xs)
      else
      {
        debug("Dropping " ++ lText);
        matchTypes(xiTypes, xs)
      }
    }
  }
}

fun lelem(x, l) {
  not(l==[]) && (x == first(hd(l)) || x `lelem` tl(l))
}

# Remove spaces from a string
fun remSpace(string) 
{
  switch (string)
  {
    case [] -> []
    case (x::xs) -> 
    {
      var lOrd = ord(x);
      # Delete spaces (160) and returns (32)
      if ((ord(x) == 160) || (ord(x) == 32))
        remSpace(xs)
      else
        [x] ++ remSpace(xs)
    }
  }
}

# Show/hide loading message
fun loading() client
{
  receive 
  {
    case Show() -> 
    {
      # Display the overlay on top of everything else
      showLoading(true);

      # Call loading as we're waiting for a hide-command
      loading()
    }
    case Hide() -> showLoading(false);
  }
}

# Project list menu.
sig projMenu : (Event) -> ()
fun projMenu(xiEvent) client
{
  debug(intToString(getMouseButton(xiEvent)));
  # Stop the event from propagating - we don't want the normal menu
  stopPropagation(xiEvent);
  ()  
}

# Update the last-access time of the session
sig updateSession : () -> ()
fun updateSession() server
{
  update (var sid <-- sessionsTable)
    where (sid.uid == userId)
    set (id = sid.id, uid = sid.uid, creation_time = 0, update_time = 0)
}

# Check whether the password given was correct, and resume session if so.
sig resumeSession : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun resumeSession(xiHandler) client
{
  var lNode = getNodeById("resume");
  var lPass = getValueFromRef(lNode);

  if (length(lPass) == 0)
  {
    debug("Password node empty");
    alertDialog("Password field empty. Please enter password or press \"exit\" to quit.");
  }
  else
  {
    # Check password is correct
    # TODO: md5 should be applied here (need client-version)
    if(checkPass(userId, lPass))
    {
      # Session has been updated, so spawn new session thread
      var lSessionHandler = spawn { sessionCheck(xiHandler) };
      lSessionHandler ! Check(lSessionHandler);
      
      # Clean form and hide overlay
      var lVoid1 = domSetNodeValueFromRef(lNode, "");
      
      toggleVisible("overlay");
      toggleVisible("session-expired");
      ()
    }
    else
    {
      debug("Password incorrect");
      alertDialog("Password incorrect. Please re-enter your password or press \"exit\" to quit.");
      ()
    }
  }
}

sig checkPass : (Int, String) -> Bool
fun checkPass(xiUid, xiPass) server
{
  var lRes = for (var lUser <-- users)
               where ((lUser.id == xiUid) && (lUser.password == md5(xiPass)))
                 [lUser.id];

  if (length(lRes) == 1)
  {
    # Update the session
    updateSession();
    true
  }
  else
  { false }
}

# Store the code in the database
sig storeFile : (String, Int, String, String) -> 
                [|Failure:String|Success:[(name:String,pos:(finish:Int,line:Int,start:Int),t:String)]|]
fun storeFile(name, pid, escp, code) server 
{
  var lBaseDir = fileLoc ++ testDir ++ getCookie(cookieName) ++ "/";
  
  # Get the path to the file, but drop the project
  var lFilename = drop(1, dropWhile(fun (x) { x <> '/' }, name));

  # Insert if new, update otherwise
  if (not(fileExists(pid, lFilename)))
  {
    insert files values [(id=0, pid=pid, name=lFilename, last_mod="", created="", data=escp, parent = -1, isfolder = 0)];
  }
  else
  {
    update (var lFile <-- files)
      where ((lFile.pid == pid) && (lFile.name == lFilename))
      set (id = lFile.id, pid = lFile.pid, name = lFile.name, last_mod=lFile.last_mod, created = lFile.created, data = escp, parent = lFile.parent, isfolder = 0)
  };

  # Mark the project as dirty
  update (var lProj <-- projectTable)
    where (lProj.id == pid)
    set (id = pid, uid = lProj.uid, name = lProj.name, dirty = 1);
  
  # Get the folders from the filename
  var lList = split("/", name);

  # Create the directories if necessary
  var lNull = 
    for (var lCount <- range(1, (length(lList) - 1)))
    {
      var lCurrDir = lBaseDir ++ join("/", take(lCount, lList));
      if (not(isDir(lCurrDir)))
      {
        var lRes = mkdir(lCurrDir);
        switch (lRes)
        {
          case Ok() -> ()
          case Error(err) -> debug("storefile: " ++ err); ()
        }
      }
      else {};
      []
    };

  updateSession();
  getTypes(code)
}

# Save the contents of the current buffer to database
sig saveFile : (Mailbox ([|SaveFile:(String, String, String)|a|]), String, Bool) -> ()
fun saveFile(handler, xiName, xiNew) client
{
  var lBody = getDocumentBody();
  
  # Get the text
  var lCode = convertSpaces(getCode(firstChild(lBody)));
  
  # Escape \ with \\ (first \ double escaped)
  var lEscapedCode = replace("\\\\", lCode, "\\\\"); #jsEscape(lCode);

  # This is potentially the name of the node containing the filename
  var lNodeName = xiName;

  # Store the code in the database
  var lFileName = 
    (if (xiNew)
      xiName
     else
      getValueFromRef(getNodeById(lNodeName))
    );

  handler ! SaveFile(lFileName, lEscapedCode, lCode);
}

# Load a file from the database
sig getFile : (Int, String) -> (data: String, types: [|Failure:String|Success:[(name:String,pos:(finish:Int,line:Int,start:Int),t:String)]|])
fun getFile(xiProjId, xiName) server
{
  var res = for (var lFile <-- files)
    where ((lFile.pid == xiProjId) && (lFile.name == xiName))
    {
      [lFile.data]
    };
  
  # Update the session while we're here
  updateSession();

  var lData = 
    if (length(res) == 0)
      "No such file '" ++ xiName ++ "'."
    else
      hd(res);

  var lTypes = getTypes(lData);

  switch (lTypes)
  {
    case Success(types) ->
    {
      var lVoid = 
        (for (var lType <- types)
         { debug("Name: " ++ lType.name ++ ", type: " ++ lType.t);
          []});
      ()
    }
    case _ -> debug("Failure?")
  };
  
  (data = lData, types = lTypes)
}

# Check if a file exists
sig fileExists : (Int, String) -> Bool
fun fileExists(xiPid, xiName) server
{
  var lCount = for (var lFile <-- files)
    where ((lFile.pid == xiPid) && (lFile.name == xiName))
    [lFile.pid];

  length(lCount) >= 1
}

# Get the full path of a file selected in the project browser
sig getFileData : (Event) -> (pid : Int, path : String)
fun getFileData(xiEvent) client
{
  # Get the events target
  var lOrigDiv = getTargetElement(xiEvent);

  # Find the project and folders that make out the full path to this file
  getPathFromNode(parentNode(findFirstParentDiv(lOrigDiv)))
}

# Recurse up the tree from the given node, returning the proj's id and the path.
sig getPathFromNode : (DomNode) -> (pid : Int, path : String)
fun getPathFromNode(xiNode) client
{
  # Find the next parent div
  var lParent = findFirstParentDiv(xiNode);

  # Check whether it's a project or a folder and get the path
  var lPath = (
    if (domGetAttributeFromRef(lParent, "type") == "folder")
    {
      var lPars = getPathFromNode(parentNode(lParent));
      (pid = lPars.pid, path = (lPars.path ++ (domGetAttributeFromRef(lParent, "cname")) ++ "/")) 
    }
    else
      (pid = stringToInt(domGetAttributeFromRef(lParent, "pid")), 
       path = (domGetAttributeFromRef(lParent, "cname") ++  "/"))
    );

  lPath
}

# Get the body tag containing code
sig getDocumentBody : () -> DomNode
fun getDocumentBody() client
{
  # Get the HTML: find the iframe, then the doc
  var lIfr = getContentDocument(hd(getElementsByTagName("iframe")));
  hd(getElementsByTagNameFromRef("body", lIfr))
}

sig setCurrFile : (String) -> ()
fun setCurrFile(xiName) client
{
  var lVoid2 = replaceChildren(stringToXml(xiName), getNodeById("currfile"));
  ()
}

sig getCurrFile : () -> String
fun getCurrFile() client
{
  textContent(firstChild(getNodeById("currfile")))
}

# Set the name of the IFrame 
sig setFrameData : (Int, String) -> ()
fun setFrameData(xiPid, xiName) client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  var lNull1 = domSetAttributeFromRef(lIfr, "name", xiName);
  var lNull2 = domSetAttributeFromRef(lIfr, "pid", (intToString(xiPid)));
  ()
}

# Toggle iframe's 'new' flag (1 on, 0 off).
sig setFrameNew: (Int) -> ()
fun setFrameNew(xiNew) client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  var lNull = domSetAttributeFromRef(lIfr, "new", intToString(xiNew));
  ()
}

# Check whether frame is new.
sig isFrameNew: () -> Bool
fun isFrameNew() client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  domGetAttributeFromRef(lIfr, "new") == "1"
}

# Get the name of the IFrame
sig getFrameData : () -> (pid: Int, fname: String)
fun getFrameData() client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  (pid = stringToInt(domGetAttributeFromRef(lIfr, "pid")),
   fname = domGetAttributeFromRef(lIfr, "name"))
}

# Insert code into the document, then highlight it.
sig insertCode : (Xml) -> ()
fun insertCode(code) client
{
  replaceChildren(code, getDocumentBody());
  highlightCode();
}

# Create a list containing the range of numbers given
sig range : (Int, Int) -> [Int]
fun range(xiStart, xiFinish) 
{
  if (xiStart == xiFinish)
    [xiFinish]
  else if (xiStart > xiFinish)
    []
  else  
    [xiStart] ++ range((xiStart + 1), xiFinish)
}

# Recursive version of splitlines. Works, but is slow.
sig splitLines : (String) -> [String]
fun splitLines(datalist)
{ 
  switch (datalist)
  { 
    case [] -> []
    case xs -> 
    {
      var listHead = takeUntilBreak(xs) : String;
      var listTail = dropUntilBreak(xs) : String;
      [listHead] ++ splitLines(listTail)
    }
  }
}

# Recursive function, taking all chars until a line break is found. Slow.
sig takeUntilBreak : (String) -> String
fun takeUntilBreak(data)
{
  switch (data)
  {
    case [] -> []
    case (x::y::zs) ->
    {
      if ((x == '\\') && (y == 'n'))
        []
      else
        x :: takeUntilBreak(y::zs)
    }
  }
}

# Recursive function, dropping all chars until a line break is found. Slow.
sig dropUntilBreak : (String) -> String
fun dropUntilBreak(data)
{
  switch (data)
  {
    case [] -> []
    case (x::y::zs) ->
    {
      if ((x == '\\') && (y == 'n'))
        zs
      else
        dropUntilBreak(y::zs)
    }
  }
}

# Convert escaped string to Xml forest
sig convertData : (String) -> Xml
fun convertData(data) client
{
  var dataList = split("\\n", data); #EscapedLinesJS(data) : [String]; 
  getXmlList(dataList)
}

# Print each member of a list to debug.
sig printEach : ([String]) -> ()
fun printEach(datalist) client
{
  var lList = datalist : [String];
  var p = for (var item <- lList)
    {debug("item: " ++ item);
    []};

  ()
}

# Turn a list of strings into XML.
sig getXmlList : ([String]) -> Xml
fun getXmlList(stringList) server
{
    for (var item <- stringList)
    {
      <#>{stringToXml(replace(['\\'], ['\\','\\'], item))} <br /></#>
    } : Xml
}

# Parse the HTML in the children of the reference, getting all the text nodes
sig getCode : (DomNode) -> String
fun getCode(ref) client
{
  # If this is is null, there's no text
  if (isNull(ref))
  {
    ""
  }
  else
  {
    var tagName = domGetTagNameFromRef(ref);
    var nextSib = nextSibling(ref);
    
    # Recurse
    var outText = switch (tagName)
    { 
      case "BR" -> "\n" ++ getCode(nextSib)
      case "SPAN" -> getTextContent(getChildNodes(getValue(ref))) ++ getCode(nextSib)
      case _ -> getCode(nextSib)
    };

    outText
  }
}

# Unescape a string recursively.
sig unescape : (String, Char) -> String
fun unescape(text, previous)
{
  switch (text)
  {
    case [] -> []
    case (x::xs) -> 
    {
      debug("Curr: " ++ [x]);
      if ((x == '\\') && (previous == '\\'))
      { 
        unescape(xs, ' ')
      }
      else
      {
        x :: unescape(xs, x)
      }
    }
  }
}

# Handle click events in the project browser.
sig navClick : (Event) -> ()
fun navClick(xiEvent) client
{
  # Get the appropriate nodes.
  var im = getTarget(xiEvent);
  var sndIm = nextElementSibling(nextSibling(im));
  var firstList = findFirstMatchingSibling(nextElementSibling(sndIm), "UL", []);  
  
  # Decide what to do based on the current state.
  switch (domGetAttributeFromRef(getTarget(xiEvent), "src"))
  { 
    case "images/rem-blue-box.png" -> 
    {
      var void2 = domSetAttributeFromRef(im, "src", "images/add-blue-box.png");
      var void3 = domSetAttributeFromRef(sndIm, "src", "images/proj-close.png");
      var void4 = domSetStyleAttrFromRef(firstList, "display", "none");
      ()
    }
    case "images/add-blue-box.png" ->
    {
      var void2 = domSetAttributeFromRef(im, "src", "images/rem-blue-box.png");
      var void3 = domSetAttributeFromRef(sndIm, "src", "images/proj-open.png");
      var void4 = domSetStyleAttrFromRef(firstList, "display", "");
      ()
    }
  };
}

sig findFirstParentDiv : (DomNode) -> DomNode
fun findFirstParentDiv(xiNode) client
{
  switch (getTagName(getValue(xiNode)))
  {
    case "DIV" ->
    {
      xiNode
    }
    case _    -> 
    {
      var parent = parentNode(xiNode);
      if (isNull(parent))
      {
        error("No div element found!")
      }
      else
      {
        findFirstParentDiv(parent)
      }
    }
  }
}

# Returns the first element sibling.
# Expects the first sibling to be the node passed in.
sig nextElementSibling : (DomNode) -> DomNode
fun nextElementSibling(xiNode) client
{
  if (isElementNode(xiNode))
  {
    xiNode
  }
  else
  {
    var sibl = nextSibling(xiNode);

    if (isNull(sibl))
    {
      sibl
    }
    else
    {
      nextElementSibling(sibl)
    }
  }
}

sig findFirstMatchingSibling : (DomNode, String, [Attribute]) -> DomNode
fun findFirstMatchingSibling(xiNode, xiType, xiConstraints) client
{
  # Check that the node is an element node of the right type and
  # that the constraints match.
  if ((isElementNode(xiNode)) && (getTagName(getValue(xiNode)) == xiType) && 
      (nodeAttributesMatch(xiNode, xiConstraints)))
  {
    # All constraints match - return
    xiNode
  } 
  else
  {
    var child = nextSibling(xiNode);
    if (isNull(child))
    {
      # Child is null - return it.
      child  
    }
    else
    {
      findFirstMatchingSibling(child, xiType, xiConstraints)
    }
  }
}

# Check whether a list of attributes exist and match for a node.
sig nodeAttributesMatch : (DomNode, [Attribute]) -> Bool
fun nodeAttributesMatch(xiNode, xiAttrs) client
{
  and(for (var attribute <- xiAttrs)
       [domGetAttributeFromRef(xiNode, attribute.attr) == attribute.val])
}

# Look through the project files given recursively and return XML for each.
sig getLProjectList : (ProjectListing, Int, Mailbox ([| SaveFile: (String, String, String)|LoadFile:(String, Event)|a|])) -> Xml
fun getLProjectList(currItem, currLevel, opHandler) client
{
  var width = intToString(currLevel * 16);
      
  # Determine what type of file we've got
  switch (currItem)
  {
    case LProject((id, name), contents) ->
    {
      # This is a top-level node. Start a new list and find all files that
      # belong to the project.
      # 
      <li class="proj-list-item">
        <div name="closed" type="proj" cname="{name}" pid="{intToString(id)}" id="proj-{name}"  unselectable="on">
          <img name="box" src="images/add-blue-box.png" l:onclick="{navClick(event)}"/>
          <img src="images/proj-close.png" />  
          <span unselectable="on">
            {stringToXml(name)}
          </span> 
          <ul class="proj-list" style="display: none;">
          {
            # Get the contents of this project
            #var contents = findFiles(currItem);
                       
            # Get the XML
            for (var file <- contents)
              getLProjectList(file, 1, opHandler)
          }
          </ul>
        </div>
      </li>
      
    }
    case LFolder((id, name), contents)  ->
    {
      # This is a folder. Print the folder name, then list files.
      <li class="proj-list-item">
        <div name="closed" type="folder" cname="{name}">  
          <img src="images/blank.png" style="width: {width}; height: 1px;" />
          <img name="box" src="images/add-blue-box.png"  l:onclick="{navClick(event)}" />
          <img src="images/proj-close.png" class="proj-blank" />
          <span>
            {stringToXml(name)}
          </span>
          <ul class="proj-list" style="display: none;">
          {
            #var folderData = findFiles(currItem);
            for (var file <- contents)
              getLProjectList(file, (currLevel + 1), opHandler)
          }
          </ul>
        </div>
      </li>
    }
    case LFile(id, name) ->
    {
      # This is a file. Display it.
      # 
      <li class="proj-list-item">
        <div class="proj-node"> 
          <img src="images/blank.png" style="width: {width}; height: 1px;" />
          <img src="images/blank.png" class="proj-blank" />
          <span class="proj-text"  l:onclick="{loadFile(opHandler, name, event)}">
          {stringToXml(reverse(takeWhile(fun (x) { x <> '/' }, reverse(name))))}
          </span>
        </div>
      </li>
    }
    case _ -> <#></#>
  }
}

# Get project listing
sig getProjectListing : (Projects) -> ProjectListing
fun getProjectListing(currItem) server
{
  switch (currItem)
  {
    case Project(id, name) ->
    {
      # Get the contents of this project
      var lProjData = findFiles(currItem);
                       
      # Get the listings
      var lContents =
        for (var lFile <- lProjData)
          [getProjectListing(lFile)];

      LProject((id, name), lContents)
    }
    case Folder(id, name) -> 
    {
      # Find all the subcomponents of this folder
      var lFolderData = findFiles(currItem);
      
      # Loop through them and add to this listing
      var lContents = 
        for (var lFile <- lFolderData)
          [getProjectListing(lFile)];
      
      # Return the listing
      LFolder((id, name), lContents)
    } 
    case File(id, name) -> LFile(id, name)
  }
}

# Print a debug message on the server
fun serverDbg(text) server
{
  debug(text);
}

# Get a list of files belonging to a particular container.
sig findFiles : (Projects) -> [Projects]
fun findFiles(container) server
{
  # Check what type of files we're looking for.
  switch (container)
  {
    case Project(id, name) ->
    {
      # It's a project. Only choose files without a parent.
      for (var file <-- files)
        where ((file.pid == id) && (file.parent < 0))
        orderby (file.name)
        {
          switch (file.isfolder)
          {
            case 1 -> [Folder(file.id, file.name)]
            case _ -> [File(file.id, file.name)]
          } 
        }
    }
    case Folder(id, name) ->
    {
      # It's a folder. Find all files/subfolders.
      for (var file <-- files)
        where (file.parent == id)
        orderby (file.name)
        {
          switch (file.isfolder)
          {
            case 1 -> [Folder(file.id, file.name)]
            case _ -> [File(file.id, file.name)]
          }
        } 
    }
    case _ -> error("Not folder or project")
  }
}

# Get the list of projects
sig getProjs : () -> ProjectListing
fun getProjs() server
{
  var lProjs = 
    for (var projs <-- projectTable)
      where (projs.uid == userId)
      orderby (projs.name)
        [Project(projs.id, projs.name)];

  hd(for (var lProject <- lProjs)
    [getProjectListing(lProject)])
}

# Get the list of files
sig getFileList : (Int) -> [(id: Int, name: String)]
fun getFileList(projId) server
{
  for (var file <-- files)
    where (file.pid == projId)
      [(id = file.id, name = file.name)]
}

# Add a new file.
sig newFile : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun newFile(xiHandler) client
{
  # Check if doc has changed
  if (docHasChanged())
  {
    # Show box asking if user wants to save
    toggleActionSave(fun () {toggleVisible("new-file")}, xiHandler);
  }
  else 
  {
    toggleVisible("new-file");
  }
}

# Load a file.
sig loadFile : (Mailbox ([|SaveFile:(String, String, String)|LoadFile:(String, Event)|a|]), String, Event) -> ()
fun loadFile(xiHandler, xiName, xiEvent) client
{
  if (docHasChanged())
  {
    toggleActionSave(fun () { xiHandler ! LoadFile(xiName, xiEvent) }, xiHandler);
  }
  else
  {
    xiHandler ! LoadFile(xiName, xiEvent);
  }
}

# Delete new items from the project browser.
sig discardNewFiles: () -> ()
fun discardNewFiles() client
{
  var lNewItems = getElementsByName("new-item");
  
  var lNull =
    for (var lItem <- lNewItems)
    {
      removeNode(lItem);
      []
    };
  ()
}

# Delete the contents of the document, set up new one.
# TODO: sort out which project to add to.
sig clearDoc: (String) -> ()
fun clearDoc(xiProj) client 
{
  var lBody = getDocumentBody();
  
  # Enable editing
  enableEditable(hd(getElementsByTagName("iframe")));

  var lName = domGetNodeValueFromRef(getNodeById("newfile-name"));

  # Replace the contents of the document with nothing
  replaceChildren(<#></#>, lBody);
  
  # Set the name to be the new file.
  setFrameData(1, (xiProj ++ "/" ++ lName ++ "*"));
  
  # Set the current file name
  setCurrFile(xiProj ++ "/" ++ lName);

  # Mark the iframe as new.
  setFrameNew(1);
 
  # Disable the run button until the file has been saved
  toggleMenuItem("run", false);

  # Insert the new file in the project list
  var lProjNode = getNodeById("proj-test");

  var lNewNode = 
      <li class="proj-list-item" style="cursor: normal;" name="new-item">
        <div class="proj-node"> 
          <img src="images/blank.png" style="width: 16; height: 1px;" />
          <img src="images/blank.png" class="proj-blank" />
          <span class="proj-text" id="newnode" l:onclick="{}" style="cursor: normal;">
          {stringToXml(lName ++ "*")}
          </span>
        </div>
      </li>;

  var lListNode = findFirstMatchingSibling(firstChild(lProjNode), "UL", []);

  var lVoid = appendChildren(lNewNode, lListNode);
    
  ()
}

# Run the current file.
sig runFile : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun runFile(xiHandler) client
{
  # Toggle waiting.
  toggleWaiting("Running file..");

  # Get the current location, but drop the filename.
  var lLoc = reverse(dropWhile(fun (x) { x <> '/' }, reverse(getLocation())));
  
  # Check if the file is saved, and request that the user saves it first
  if (docHasChanged())
  {
    () #toggleActionSave()
  }
  else {};

  # Get frame data
  var lFrameData = getFrameData();

  # Write file to temp location
  var lFileLoc =  testDir ++ getCookie(cookieName) ++ "/" ++ lFrameData.fname;
  #writeFromDatabase(getFrameName());
  
  # Open a new window pointing to the correct location
  newWindow(lLoc ++ lFileLoc);

  # Toggle waiting.
  toggleWaiting("");
}

# Run the current file, copying all relevant files from the database
sig runFileDb : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun runFileDb(xiHandler) client
{
  # Toggle waiting.
  toggleWaiting("Running file..");

  var lDropFun = fun (x) { x <> '/' };

  # Get the current location, but drop the filename.
  var lLoc = reverse(dropWhile(fun (x) { x <> '/' }, reverse(getLocation())));
  
  # Check if the file is saved, and request that the user saves it first
  if (docHasChanged())
  {
    () #toggleActionSave()
  }
  else {};

  # Get frame data
  var lFrameData = getFrameData();

  # Write project
  var lBaseDir = fileLoc ++ testDir ++ getCookie(cookieName) ++ "/";
  var lOk = 
    writeProjectFromDatabase(
      lFrameData.pid, 
      "", 
      lBaseDir
    );
  #reverse(dropWhile(fun (x) { x <> '/' }, reverse(lFrameData.fname))),
  # Write file to temp location
  var lFileLoc =  testDir ++ getCookie(cookieName) ++ "/" ++ lFrameData.fname;
  #writeFromDatabase(getFrameName());
  
  # Open a new window pointing to the correct location
  newWindow(lLoc ++ lFileLoc);

  # Toggle waiting.
  toggleWaiting("");

  if (lOk)
  {
    debug("Run ok");
    ()
  }
  else
  {
    debug("Run failed");
    ()
  }
}

sig deploy : () -> ()
fun deploy() server
{
  # Get the user name
  var lUser = hd(for (var lCurrUser <-- users)
                where (lCurrUser.id == userId)
                  [lCurrUser.email]);
  var lSrcDir = fileLoc ++ testDir ++ getCookie(cookieName) ++ "/";
  var lDstDir = fileLoc ++ deplDir ++ lUser ++ "/";
  
  debug("Src: " ++ lSrcDir);
  debug("Dst: " ++ lDstDir);

  # Get the list of files from this user's tmp dir
  var lFileList = getDirContents(lSrcDir);

  # Move the files one by one to the user's real dir
  var lOk = 
    for (var lFile <- lFileList)
    {
      var lRes = moveFile(lSrcDir ++ lFile, lDstDir ++ lFile);
      switch (lRes)
      {
        case Error(err) -> debug(err); [false]
        case _ -> [true]
      }
    };

  if (and(lOk))
    debug("Deployed successfully!")
  else
    debug("Deployment failed!")
}

sig deployDb : (Int) -> ()
fun deployDb(xiPid) server
{
  # Check that project is dirty
  var lDirty = hd(for (var lProj <-- projectTable)
                 where (lProj.id == xiPid)
                   [lProj.dirty]);

  if (lDirty == 0)
    ()
  else
  {
    # Get the user name
    var lUser = hd(for (var lCurrUser <-- users)
                  where (lCurrUser.id == userId)
                    [lCurrUser.email]);

    var lBaseDir = fileLoc ++ deplDir;
  
    debug("Dst: " ++ lBaseDir ++ "/" ++ lUser);

    # Move the files one by one to the user's real dir
    var lOk = writeProjectFromDatabase(xiPid, lUser, lBaseDir);

    if (lOk)
    {
      # Update the project to be non-dirty
      update (var lProj <-- projectTable)
        where (lProj.id == xiPid)
        set (id = xiPid, uid = lProj.uid, name = lProj.name, dirty = 0);

      debug("Deployed successfully!")
    }
    else
      debug("Deployment failed!")
  }
}

# Write out the contents of a whole project to disk.
sig writeProjectFromDatabase : (Int, String, String) -> Bool
fun writeProjectFromDatabase(xiPid, xiName, xiBaseDir) server
{
  # Find the project's name
  var lProjName = hd(for (var lProj <-- projectTable)
                    where (lProj.id == xiPid)
                      [lProj.name]);

  # Get the directory
  var lProjDir = xiBaseDir ++ xiName ++ "/" ++ lProjName ++ "/";

  # Create directory for project
  switch(mkdir(lProjDir))
  {
    case Ok() -> ()
    case Error(err) -> debug("mkdir " ++ lProjDir ++ ": " ++ err)
  };      
    
  # Find all the folders for this project
  var lFolders = for (var lFolder <-- files)
                   where ((lFolder.pid == xiPid) && (lFolder.isfolder == 1))
                   orderby (lFolder.name)
                     [lFolder.name];

  # Create directories for folders
  var lResFolders = 
    for (var lFolder <- lFolders)
    {
      var lRes = mkdir(lProjDir ++ lFolder);
      [switch(lRes)
      {
        case Ok() -> true
        case Error(err) -> debug("mkdir " ++ lProjDir ++ lFolder ++ ": " ++ err); false
      }]
    };

  # Find all files for this project
  var lFileList = for (var lFile <-- files)
                    where ((lFile.pid == xiPid) && (lFile.isfolder == 0))
                      [lFile.name];
  
  # Write out each file
  var lRes = for (var lFile <- lFileList)
               [writeFromDatabase(xiPid, lFile, lProjDir)];

  # Return the results
  and(lRes ++ lResFolders)
}

# Write data from the database to file on disk.
# Returns file location
sig writeFromDatabase : (Int, String, String) -> Bool
fun writeFromDatabase(xiPid, xiName, xiDir) server
{ 
  # Get file lo
  #var lFileLoc = testDir ++ getCookie(cookieName) ++ "/" ++ xiName;

  # Get the data
  var lFileData = getFile(xiPid, xiName);

  # Clean it up (calls client!) @TODO
  var lCleanData = lFileData.data; #join("\n", splitEscapedLinesJS(lFileData));

  # Write to disk
  var lRes = writeToFile(xiDir ++ xiName, lCleanData);

  # Check the result, debug and return false on error
  switch (lRes)
  {
    case Error(err) -> debug("WriteToFile: " ++ err); false
    case Ok() -> true
  }
}

# Get the menubar. Currently a drop-down style thing, perhaps a button set
# would be better as there's not a lot of options to change?
sig getMenu : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> Xml
fun getMenu(opHandler) client
{
  <#>
    <div id="menubar">
      <dl>
        <dt id="menu-file-cap" l:onclick="{toggleMenu("menu-file");}" class="menuhead"><span>File</span></dt>
        <dd id="menu-file" style="width: 120px;">
          <ul id="menulist" class="menulist">
            <li l:onclick="{toggleMenu("menu-file"); newFile(opHandler);}" unselectable="on"><span>New file</span></li>
            <li l:onclick="{toggleMenu("menu-file"); maybeSaveFile(opHandler);}" unselectable="on"><span>Save</span></li>
            <li l:onclick="{toggleMenu("menu-file"); toggleVisible("overlay"); toggleVisible("save-file");}" unselectable="on"><span>Save as.. </span></li>
            <li style="height: 1px;"><hr style="height: 2px;" /> </li>
            <li l:onclick="{toggleMenu("menu-file"); toggleSession(event)}"><img src="images/check.png" style="position: relative; top: 2px;" id="session-check" enabled="yes"/><span style="margin-left: 0px; top: -1px;">Session timeouts</span></li>
            <li style="height: 1px;"><hr style="height: 2px;" /> </li>
            <li l:onclick="{toggleMenu("menu-file"); toggleWaiting("Logging out.."); logoutClient()}" unselectable="on"><span>Logout</span></li>
          </ul>
        </dd>
      </dl>
      <dl>
        <dt id="menu-proj-cap" l:onclick="{toggleMenu("menu-proj");}" class="menuhead"><span>Project</span></dt>
        <dd id="menu-proj">
          <ul id="menulist" class="menulist">
            <li class="disabled" id="menu-item-run-off" unselectable="on"><span>Run</span></li>
            <li class="invisible" id="menu-item-run" unselectable="on" l:onclick="{toggleMenu("menu-proj"); toggleWaiting("Running file.."); runFileDb(opHandler); toggleWaiting("");}"><span>Run</span></li>

            <li style="height: 1px;"><hr style="height: 2px;" /> </li> 
            <li class="disabled" id="menu-item-deploy-off" unselectable="on"><span>Deploy</span></li>
            <li class="invisible" id="menu-item-deploy" l:onclick="{toggleMenu("menu-proj"); toggleWaiting("Deploying project.."); deployDb((getFrameData()).pid); toggleWaiting("");}" unselectable="on"><span>Deploy</span></li>
          </ul>
        </dd>
      </dl>
    </div>
  </#>
}

sig maybeSaveFile : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun maybeSaveFile(xiHandler) client
{
  # Check if the iFrame is named - 'save as' if it isn't
  var lFrameData = getFrameData();
  switch (lFrameData.fname)
  {
    case "*" -> toggleVisible("overlay"); toggleVisible("save-file")
    case ""  -> debug("No name!")
    case _   -> saveCurrent(lFrameData, xiHandler)
  }
}

# Save the current file.
sig saveCurrent : ((pid: Int, fname: String), 
                    Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun saveCurrent(xiData, xiHandler) client
{
  var lMatchFun = fun (x) { x <> '*' };

  # Check if a save is needed
  if (length(dropWhile(lMatchFun, xiData.fname)) == 1)
  {
    toggleWaiting("Saving file..");
    var lRealName = takeWhile(lMatchFun, xiData.fname);
    saveFile(xiHandler, lRealName, true);
    setFrameData(xiData.pid, lRealName);

    # Check if frame is new, replace with linked version
    if (isFrameNew())
    {
      var lDispName = drop(1, dropWhile(fun (x) { x <> '/' }, lRealName));
      var lNewNode =
          <span class="proj-text">
            {stringToXml(lDispName)}
          </span>;
      # Set the list item to be non-new
      var lVoid = domSetAttributeFromRef(getNodeById("new-item"), "name", "");

      replaceNode(lNewNode, getNodeById("newnode"));
      setFrameNew(0);
    } else {};
  
    toggleWaiting("");
  } else {};
}

# Check if the document has been altered.
sig docHasChanged : () -> Bool
fun docHasChanged() client
{
  var lFrameName = (getFrameData()).fname;
  # See if there's a star in the framename.
  length(dropWhile(fun (x) { x <> '*' }, lFrameName)) == 1
}

# TODO: This is broken.
sig docChanged : () -> ()
fun docChanged() client
{
  if (hd(reverse(getCurrFile())) == '*')
    ()
  else
    setCurrFile(getCurrFile() ++ "*")
}

# TODO: Check how to access checkbox status
sig toggleSession : (Event) -> ()
fun toggleSession(xiEvent) client
{
  # If change from off -> on, update session
  var lListImage = getNodeById("session-check");

  var lNewImage = 
    switch (domGetAttributeFromRef(lListImage, "enabled"))
    {
      case "yes" -> <img src="images/blank.png" style="height: 16px; width: 16px;" id="session-check" enabled="no" />
      case _   ->
      {
        # Update session to ensure user's not logged out straight away.
        updateSession();

        <img src="images/check.png" style="position: relative; top: 2px;" id="session-check" enabled="yes" />
      }
    };

  replaceNode(lNewImage, lListImage);
}

# (Dis/En)able an item in the menu
sig toggleMenuItem : (String, Bool) -> ()
fun toggleMenuItem(xiName, xiOn) client
{
  var lNodeOn  = getNodeById("menu-item-" ++ xiName);
  var lNodeOff = getNodeById("menu-item-" ++ xiName ++ "-off");

  if (xiOn)
  {
    # Enable the node
    var lVoid1 = domSetStyleAttrFromRef(lNodeOn, "display", "list-item");
    var lVoid2 = domSetStyleAttrFromRef(lNodeOff, "display", "none");
    ()
  }  
  else
  {
    # Disable the node
    var lVoid1 = domSetStyleAttrFromRef(lNodeOn, "display", "list-item");
    var lVoid2 = domSetStyleAttrFromRef(lNodeOff, "display", "none");
    ()
  };
}

# Toggle save-before-[action] display. Takes the action to perform as arg.
sig toggleActionSave : ((() -> ()),Mailbox ([|SaveFile:(String, String, String)|a|]))  -> ()
fun toggleActionSave(xiFn, xiHandler) client
{
  var lSave =
   <#>
     <input type="button" name="save" l:onclick="{saveCurrent(getFrameData(), xiHandler); toggleVisible("maybe-save"); xiFn() }" value="Save" />
     <input type="button" name="cancel" l:onclick="{toggleVisible("maybe-save"); setInvisible("overlay"); discardNewFiles(); xiFn()}" value="Don't Save" />
   </#>;

  var lNode       = getNodeById("maybe-save");
  var lInputNode  = getNodeById("maybe-save-input");
 
  switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" ->
    {
      var lVoid1 = domSetStyleAttrFromRef(lInputNode, "display", "none");
      var lVoid2 = domSetStyleAttrFromRef(lNode, "display", "none");
      ()
    }
    case _       ->
    {
      # Set the save action
      var lButtonNode = getNodeById("maybe-save-buttons");
      replaceChildren(lSave, lButtonNode);
     
      # Display the node
      var lVoid2 = domSetStyleAttrFromRef(lNode, "display", "block");
      ()
    }
  };
  
  # Toggle the overlay
  toggleVisible("overlay");
}

# Hide all menu items
sig toggleMenu : (String) -> ()
fun toggleMenu(xiName) client
{
  var lNode = getNodeById(xiName);
  var lVoid = switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" -> domSetStyleAttrFromRef(lNode, "display", "none")
    case _       -> domSetStyleAttrFromRef(lNode, "display", "block")
  };

  toggleBgColour(xiName ++ "-cap", "rgb(133, 177, 255)");
}

# Toggle an element's visibility on/off
sig toggleVisible : (String) -> ()
fun toggleVisible(xiName) client
{
  var lNode = getNodeById(xiName);
  var lOverlay = getNodeById("overlay");
  var lVoid = switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" -> 
    {
      var lVoid = domSetStyleAttrFromRef(lOverlay, "display", "none");
      domSetStyleAttrFromRef(lNode, "display", "none")
    }
    case _      -> 
    {
      var lVoid = domSetStyleAttrFromRef(lOverlay, "display", "block");
      domSetStyleAttrFromRef(lNode, "display", "block")
    }
  };
  ()
}

# Toggle the background colour of the given node.
sig toggleBgColour : (String, String) -> ()
fun toggleBgColour(xiName, xiColour)
{
  var lNode = getNodeById(xiName);
  var lVoid = 
    if (length(domGetStyleAttrFromRef(lNode, "background")) > 1)
      domSetStyleAttrFromRef(lNode, "background", "")
    else
      domSetStyleAttrFromRef(lNode, "background", xiColour);
  
  ()
}

# Toggle the "waiting" box
sig toggleWaiting : (String) -> ()
fun toggleWaiting(xiText) client
{
  var lNode = getNodeById("waiting");
  var lTextNode = nextElementSibling(firstChild(getNodeById("waiting-text")));

  # Node to use.
  var lText = <span class="proj-list-item">{stringToXml(xiText)}</span>;

  switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" ->
    {
      var lVoid = domSetStyleAttrFromRef(lNode, "display", "none");
      ();
    }
    case _ ->
    {
      var lVoid  = domSetStyleAttrFromRef(lNode, "display", "block");
      replaceNode(lText, lTextNode);
    }
  };
  toggleVisible("overlay");
}

# Set a node to be invisible
sig setInvisible : (String) -> ()
fun setInvisible(xiName) client
{
  var lVoid = domSetStyleAttrFromRef(getNodeById(xiName), "display", "none");
  ();
}

# Recursive function to get a node's siblings.
# Only works for element nodes.
sig getSiblingsLinks : (DomNode) -> [DomNode]
fun getSiblingsLinks(xiNode) client
{
  var lXmlNode = getValue(xiNode);
  serverDbg("Tagname: " ++ getTagName(lXmlNode));
  serverDbg("Type? " ++ getAttribute(lXmlNode, "type"));
  if ((not(isElementNode(xiNode))) || (isNull(xiNode)))
    []
  else
    [xiNode] ++ getSiblingsLinks(nextElementSibling(xiNode))
}

# Clean the contents of a form.
# @TODO: broken. Looping doesn't work for DomNode lists?
sig cleanForm : (String) -> ()
fun cleanForm(xiName) client
{
  var lFirst = nextElementSibling(firstChild(getNodeById(xiName)));
  var lVoid = for (var lNode <- getSiblings(lFirst))
  {
    var lXmlNode = getValue(lNode);
    var lVoid = (if ((getTagName(lXmlNode) == "INPUT") && (getAttribute(lXmlNode, "type") == "text"))
        domSetAttributeFromRef(lNode, "value", "")
      else
        "");
    []
  };
  
  # Hide the overlay and the form
  setInvisible("overlay");
  setInvisible(xiName);
}

# Show/Hide the loading window
sig showLoading : (Bool) -> ()
fun showLoading(xiToggle) client
{
  var lNode = getNodeById("loading");
  var lState = 
    if (xiToggle)
      "block"
    else
      "none";
  var lVoid = domSetStyleAttrFromRef(lNode, "display", lState);
  ()
}

# Returns the HTML needed for the 'hidden' objects, i.e. the various dialogs.
sig getHiddenObjects : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> Xml
fun getHiddenObjects(opHandler) client
{
  <#>
    <div class="overlay" id="overlay"></div>
    <div id="new-file" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">New file</span>
        </div>
        <div class="container-box">
          <span class="popup-text padded">
            Name:<br />
            <input type="text" class="input-box proj-items" id="newfile-name" />
          </span>
        </div>
        <div class="bottombar">
          <input type="button" name="save" l:onclick="{clearDoc("test"); cleanForm("new-file")}" value="Create new" />
          <input type="button" name="cancel" l:onclick="{cleanForm("new-file")}" value="Cancel" />
        </div>
      </div>
    </div>
    <div id="save-file" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Save file</span>
        </div>
        <div class="container-box">
          <span class="proj-items padded">
            Name:<br />
            <input type="text" class="input-box proj-items" id="filename" />
          </span>
        </div>
        <div class="bottombar">
          <input type="button" name="save" l:onclick="{saveFile(opHandler, "filename", false); setInvisible("overlay"); setInvisible("save-file")}" value="Save" />
          <input type="button" name="cancel" l:onclick="{cleanForm("save-file")}" value="Cancel" />
        </div>
      </div>
    </div>
    <div id="maybe-save" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Save current file?</span>
        </div>
        <div id="maybe-save-input" class="container-box invisible">
          <span class="proj-items padded">
            Name:<br />
            <input type="text" class="input-box proj-items" id="save-filename" />
          </span>
        </div>
        <div class="bottombar" id="maybe-save-buttons">
          <input type="button" name="save" l:onclick="{saveCurrent(getFrameData(), opHandler); toggleVisible("maybe-save"); toggleVisible("new-file"); }" value="Save" />
          <input type="button" name="cancel" l:onclick="{toggleVisible("maybe-save"); setInvisible("overlay");}" value="Don't Save" />
        </div>
      </div>
    </div>
    <div id="waiting" class="invisible">
      <div class="centered box" id="waiting-text">
        <span></span>
      </div>
    </div>
    <div id="session-expired" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Session expired</span>
        </div>
        <div id="session-expired-input" class="container-box">
          <span class="popup-text padded">
            Your session has expired. <br />Please re-enter your password
             to resume session, or press exit to quit.<br /><br />
              Password:<br />
            <input type="password" class="input-box proj-items" id="resume" />
          </span>
        </div>
        <div class="bottombar">
          <input type="button" name="save" l:onclick="{resumeSession(opHandler);}" value="Resume" />
          <input type="button" name="cancel" l:onclick="{logout()}" value="Exit" />
        </div>
      </div>
    </div>
  </#>
}

# Returns the HTML needed for the project browser.
sig getProjBrowser : (Mailbox ([|SaveFile:(String, String, String)|LoadFile:(String, Event)|a|])) -> Xml
fun getProjBrowser(opHandler) client
{
    <div id="proj-browser" class="proj-browser">
      <div id="proj-caption-bg" class="caption-bg">
        <span id="proj-caption" class="caption-text" unselectable="on">Project Browser</span>
      </div>
      <div id="proj-items" class="proj-items">
        <ul class="proj-list">
         {
           var lProjs = getProjs();
           getLProjectList(lProjs, 0, opHandler)
         }  
        </ul>
      </div>
    </div>
}

# Returns the HTML needed for the code editor.
sig getEditor : () -> Xml
fun getEditor() client
{
    <div id="editor" class="editor">
      <script type="text/javascript">
        var editor = new CodeMirror((document.getElementById("editor")), {{width: "100%", height: "100%"}});
        window.document.editor = editor;
      </script>
    </div>
}

# Render the editor.
sig renderObject : () -> Xml
fun renderObject() client
{
  # Spawn file handling object.
  var opHandler = spawn { fileOp() };
  var sessionHandler = spawn { sessionCheck(opHandler) };
  sessionHandler ! Check(sessionHandler);
  <#>
    {
      getHiddenObjects(opHandler)
    }
    <div id="contain-left" class="contain-left">
      <div id="values" class="menu" style="border-right: 0px;">
      {
        getMenu(opHandler)
      }
      </div>
      {
        getProjBrowser(opHandler)
      }
      <div id="space" class="space"></div>
    </div>
    <div id="contain-right" class="contain-right">
      <div id="topbar" class="menu menu-file-cap" style="border-left: 0px none; padding-top: 6px; height: 19px; width: 100%; text-align: right;">
        <span id="currfile" style="font-family: tahoma,verdana; font-size: 11px; margin-right: 10px;"></span>
      </div>
      {
        getEditor()
      }
    </div>
  </#>
}

# Redirect to login. 
# TODO: Broken.
sig redir : () -> Xml
fun redir() server 
{
  redirect("login.links");
  <div>not redirected</div>
}

# Main function. 
sig main : () -> Xml
fun main() client 
{
  if (not(isLoggedIn()))
  {
    #<div><a href="login.links">Not logged in</a></div>
    logoutClient();
    <#></#>
  }
  else
  {
    # Could possibly introduce a loading bar - but how to do so without
    # rendering everything first? CodeMirror needs the editor div.
  <html>
    <head>
      <title>ug4proj: Links</title>
    </head>
    <script src="CodeMirror/Mochi.js" type="text/javascript"></script>
    <script src="CodeMirror/util.js" type="text/javascript"></script>
    <script src="CodeMirror/tokenizelinks.js" type="text/javascript"></script>
    <script src="CodeMirror/parselinks.js" type="text/javascript"></script>
    <script src="CodeMirror/stringstream.js" type="text/javascript"></script>
    <script src="CodeMirror/select.js" type="text/javascript"></script>
    <script src="CodeMirror/codemirror.js" type="text/javascript"></script>
    
    <link rel="stylesheet" type="text/css" href="proj.css" />
    <body>
      <div id="main" style="z-index: 1;">
      {
        renderObject()
      }
      </div>
    </body>
  </html>
  }
}

page
  <#>{ main() }</#>
  
