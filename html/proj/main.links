# TODO:
#
# - Sort out right-click menu for project list.
#    * Figure out how to distinguish between left/right mouse clicks (done)
#    * Recreate stopPropagation (is it gone?) (done, but won't work)
#      -- Sam has been notified, appears to be Links issue.

# - Clean up SQL calls - there's about 5 for loading the project list..
#    * Clean up client/server calls in general. Somewhere, a server function is making a client call... (done - project list getting was silly, and opHandler requires server -> client calls if used on server.

# - 'New' menu option changes
#    * new files added to project list on creation in right project 
#      -- Project needs to be embedded in iFrame
#    * add capabilities for adding new projects
#    * new project creates new directory on disk
#    * new project gets added

# - Figure out why logging out doesn't work.
#    * Possibly due to calling server function direct?
# - Test/Deploy configuration. Needs:
#    * Create-dir function (done)
#    * Delete-dir function (done)
#    * Account creation creates user dir
#    * Logging in needs to create new dir based on sessionId (done)
#    * Logging out needs to delete dir (done)
#    * Deploy copies from test to deploy (done)
#    * What happens when users want to test files linking to files not being tested? Maybe it's better to mark files as 'unclean' in database, then dump them out during testing, and copy them from database during deploy?

######
# JavaScript functions
##
# Split lines
alien javascript splitEscapedLinesJS : (String) -> [String];

# Call the code highlighting function of the edit-box.
alien javascript highlightCode : () -> ();

# Return node.value.
alien javascript getValueFromRef : (DomNode) -> String; 

# Functions for (un-)escaping HTML
alien javascript escapeHtml : (String) -> String;
alien javascript unescapeHtml: (String) -> String;

# Convert spaces to 
alien javascript convertSpaces : (String) -> String;

# Load the IDE's editor.
alien javascript loadEditor: () -> DomNode;
alien javascript getSiblings: (DomNode) -> [DomNode];

# Get the current location (ie URL)
alien javascript getLocation: () -> String;

# Create a new window using the URL passed in.
alien javascript newWindow: (String) -> ();

# Normal (un-)escaping
alien javascript jsUnescape: (String) -> String;
alien javascript jsEscape: (String) -> String;

alien javascript testFn: (Event) -> ();

######
# Attribute type
typename Attribute = (attr: String, val: String);

# Things that should be in their own file
var cookieName = "linkside";
var fileLoc = "/home/tom/links/html/proj/";
var testDir = "test/";
var deplDir = "users/";

typename User = (name:String, password:String);
typename ProjConts = (Int, String);
typename Projects = [| Project : ProjConts | Folder : ProjConts | File : ProjConts |];

typename ProjectListing = mu proj.[| LFile : ProjConts | LProject : (ProjConts, [proj]) | LFolder : (ProjConts, [proj]) |];

# Databases to access
var users = table "users" with (
    id : Int,
    email: String,
    password: String
) from (database "ide");

var projectTable = table "projects" with (
    id : Int,
    uid : Int,
    name : String
) from (database "ide");

var files = table "files" with (
    id : Int,
    pid : Int,
    name : String,
    last_mod : String,
    created : String, 
    data : String,
    parent : Int,
    isfolder : Int
) from (database "ide");

var sessionsTable = table "sessions" with (
    id : String,
    uid : Int,
    creation_time : Int,
    update_time : Int
) from (database "ide");

var validSessions = table "valid_sessions" with (
    id : String,
    uid : Int
) from (database "ide");

# Count the number of elements in a list
fun numElems(lst) server
{
  switch(lst)
  {
    case [] -> 0
    case x::xs -> 1 + numElems(xs)
  }
}

# Logout from the IDE
sig logout : () -> ()
fun logout() server
{
  var lId = getCookie("linkside");
  delete (var sessId <-- sessionsTable)
    where (sessId.id == lId);

  # Delete temporary directory (and all its contents..)
  switch (rmdirForce(fileLoc ++ testDir ++ lId))
  {
    case Error(err) -> debug("Error on rmdir: " ++ err);
    case _ -> ()
  };

  setCookie("linkside","");
  redirect("login.links");
}

##
# Normal code.
##

# Return the uid of the current sessions' owner.
sig getUid : () -> Int
fun getUid() server
{
  debug("Getting UID");
  var uids = for (var sid <-- sessionsTable)
             where (sid.id == getCookie("linkside"))
              [sid.uid];
  if (numElems(uids) == 0)
    1
  else
    hd(uids)
}

# Userid of session owner
var userId = getUid();

# Check whether the user is logged in
sig isLoggedIn : () -> Bool
fun isLoggedIn() server
{
  var sessId = getCookie(cookieName);
  debug("cookie: " ++ sessId);
  # Check that the sessid exists in the database
  var p = numElems(for (var lSess <-- validSessions)
    where (lSess.id == sessId)
      [lSess.id]) == 1;
  (if (p)
    debug("logged in")
  else
    debug("not logged in"));
  #p
  true
}

# Perform file operations (load, save).
fun fileOp() client
{
  receive 
  {
    case SaveFile(name, escp, code) -> 
    {
      toggleWaiting("Saving file..");
      var lFileData = getFrameData();
      var lTypes = getTypes(code);

       var lVoid = 
         for (var lCurr <- lTypes)
         {
           debug("Name: " ++ lCurr.name ++ "; type: " ++ lCurr.t);
           []
         };

      storeFile(name, lFileData.pid, escp, code); 
      #updateSession();
      setFrameData(lFileData.pid, name);
      toggleWaiting("");
      fileOp()
    }
    case LoadFile(name, lEvent) -> 
    {
       toggleWaiting("Loading file..");
       var lFileData = getFileData(lEvent);
       var lProjId = lFileData.pid;
       var lFullName = lFileData.path ++ name;
       var lData = getFile(lProjId, name);
       var rval = convertData(lData) : Xml;

       insertCode(rval);
       #updateSession();
       setFrameData(lProjId, lFullName);
       toggleWaiting("");
       fileOp()
    }
  }
}

sig getTypes : (String) -> [(name:String,pos:(finish:Int,line:Int,start:Int),t:String)]
fun getTypes(xiCode) server
{
  dumpTypes(xiCode)
}

# Show/hide loading message
fun loading() client
{
  receive 
  {
    case Show() -> 
    {
      # Display the overlay on top of everything else
      showLoading(true);

      # Call loading as we're waiting for a hide-command
      loading()
    }
    case Hide() -> showLoading(false);
  }
}

# Project list menu.
sig projMenu : (Event) -> ()
fun projMenu(xiEvent) client
{
  debug(intToString(getMouseButton(xiEvent)));
  # Stop the event from propagating - we don't want the normal menu
  stopPropagation(xiEvent);
  ()  
}

# Update the last-access time of the session
sig updateSession : () -> ()
fun updateSession() server
{
  update (var sid <-- sessionsTable)
    where (sid.uid == 1)
    set (id = sid.id, uid = userId, creation_time = 0, update_time = 0)
}

# Store the code in the database
sig storeFile : (String, Int, String, String) -> ()
fun storeFile(name, pid, escp, code) server 
{
  var lBaseDir = fileLoc ++ testDir ++ getCookie(cookieName) ++ "/";
  var lFilename = reverse(takeWhile(fun (x) { x <> '/' }, reverse(name)));

  # Insert if new, update otherwise
  if (not(fileExists(pid, lFilename)))
  {
    insert files values [(id=0, pid=pid, name=lFilename, last_mod="", created="", data=escp, parent = -1, isfolder = 0)];
  }
  else {
    update (var lFile <-- files)
     where ((lFile.pid == pid) && (lFile.name == lFilename))
     set (id = lFile.id, pid = lFile.pid, name = lFile.name, last_mod=lFile.last_mod, created = lFile.created, data = escp, parent = lFile.parent, isfolder = 0)
  };
  
  # Get the folders from the filename
  debug("Getting folder list");
  var lList = split('/', name);

  debug("Checking directories");
  var lNull = 
    for (var lCount <- range(1, (length(lList) - 1)))
    {
      var lCurrDir = lBaseDir ++ join("/", take(lCount, lList));
      debug("Checking for dir " ++ lCurrDir);
      if (not(isDir(lCurrDir)))
      {
        var lRes = mkdir(lCurrDir);
        debug("Creating dir " ++ lCurrDir);
        switch (lRes)
        {
          case Ok() -> ()
          case Error(err) -> debug(err); ()
        }
      }
      else {};
      []
    };

  # @TODO: Do we want to save the file here? No real need if test/depl,
  # but useful for knowing which files are to be changed. The other 
  # option is to mark modified files in the db.
  writeToFile(lBaseDir ++ name, code);
  updateSession();
}

# Save the contents of the current buffer to database
sig saveFile : (Mailbox ([|SaveFile:(String, String, String)|a|]), String, Bool) -> ()
fun saveFile(handler, xiName, xiNew) client
{
  var lBody = getDocumentBody();
  
  # Get the text
  var lCode = convertSpaces(getCode(firstChild(lBody)));
  var lEscapedCode = escapeHtml(lCode);

  # This is potentially the name of the node containing the filename
  var lNodeName = xiName;

  # Store the code in the database
  var lFileName = 
    (if (xiNew)
      xiName
     else
      getValueFromRef(getNodeById(lNodeName))
    );

  handler ! SaveFile(lFileName, lEscapedCode, lCode);
}

# Load a file from the database
sig getFile : (Int, String) -> String
fun getFile(xiProjId, xiName) server
{
  var res = for (var lFile <-- files)
    where ((lFile.pid == xiProjId) && (lFile.name == xiName))
    {
      [lFile.data]
    };
  
  # Update the session while we're here
  updateSession();

  if (numElems(res) == 0)
    "No such file '" ++ xiName ++ "'."
  else
   hd(res)
}

# Check if a file exists
sig fileExists : (Int, String) -> Bool
fun fileExists(xiPid, xiName) server
{
  var lCount = for (var lFile <-- files)
    where ((lFile.pid == xiPid) && (lFile.name == xiName))
    [lFile.pid];

  numElems(lCount) >= 1
}

# Get the full path of a file selected in the project browser
sig getFileData : (Event) -> (pid : Int, path : String)
fun getFileData(xiEvent) client
{
  # Get the events target
  var lOrigDiv = getTargetElement(xiEvent);

  # Find the project and folders that make out the full path to this file
  getPathFromNode(parentNode(findFirstParentDiv(lOrigDiv)))
}

# Recurse up the tree from the given node, returning the proj's id and the path.
sig getPathFromNode : (DomNode) -> (pid : Int, path : String)
fun getPathFromNode(xiNode) client
{
  # Find the next parent div
  var lParent = findFirstParentDiv(xiNode);

  # Check whether it's a project or a folder and get the path
  var lPath = (if (domGetAttributeFromRef(lParent, "type") == "folder")
    (getPathFromNode(lParent)).path ++ (domGetAttributeFromRef(lParent, "cname")) ++ "/" 
  else
    domGetAttributeFromRef(lParent, "cname") ++ "/");

  (pid = stringToInt(domGetAttributeFromRef(lParent, "pid")), path = lPath)
}

# Get the body tag containing code
sig getDocumentBody : () -> DomNode
fun getDocumentBody() client
{
  # Get the HTML: find the iframe, then the doc
  var lIfr = getContentDocument(hd(getElementsByTagName("iframe")));
  hd(getElementsByTagNameFromRef("body", lIfr))
}

# Set the name of the IFrame 
sig setFrameData : (Int, String) -> ()
fun setFrameData(xiPid, xiName) client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  var lNull1 = domSetAttributeFromRef(lIfr, "name", xiName);
  var lNull2 = domSetAttributeFromRef(lIfr, "pid", (intToString(xiPid)));
  ()
}

# Get the name of the IFrame
sig getFrameData : () -> (pid: Int, fname: String)
fun getFrameData() client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  (pid = stringToInt(domGetAttributeFromRef(lIfr, "pid")),
   fname = domGetAttributeFromRef(lIfr, "name"))
}

# Insert code into the document, then highlight it.
sig insertCode : (Xml) -> ()
fun insertCode(code) client
{
  replaceChildren(code, getDocumentBody());
  highlightCode();
}

# Recursive string handling. Fast enough for small strings.
sig split : (Char, String) -> [String]
fun split(xiChr, xiString)
{
  debug("Split at " ++ [xiChr] ++ " : " ++ xiString);
  switch (xiString)
  {
    case [] -> []
    case xs -> 
    {
      var lHead = takeWhile(fun (x) {x <> xiChr}, xiString);
      var lTail = dropWhile(fun (x) {x <> xiChr}, xiString);
        
      # Recurse, dropping the split-char.
      if (lTail <> [])
        [lHead] ++ split(xiChr, tl(lTail))
      else
        [lHead]
    }
  }
}

# Create a list containing the range of numbers given
sig range : (Int, Int) -> [Int]
fun range(xiStart, xiFinish) 
{
  if (xiStart == xiFinish)
    [xiFinish]
  else
    [xiStart] ++ range((xiStart + 1), xiFinish)
}

# Recursive version of splitlines. Works, but is slow.
sig splitLines : (String) -> [String]
fun splitLines(datalist)
{ 
  switch (datalist)
  { 
    case [] -> []
    case xs -> 
    {
      var listHead = takeUntilBreak(xs) : String;
      var listTail = dropUntilBreak(xs) : String;
      [listHead] ++ splitLines(listTail)
    }
  }
}

# Recursive function, taking all chars until a line break is found. Slow.
sig takeUntilBreak : (String) -> String
fun takeUntilBreak(data)
{
  switch (data)
  {
    case [] -> []
    case (x::y::zs) ->
    {
      if ((x == '\\') && (y == 'n'))
        []
      else
        x :: takeUntilBreak(y::zs)
    }
  }
}

# Recursive function, dropping all chars until a line break is found. Slow.
sig dropUntilBreak : (String) -> String
fun dropUntilBreak(data)
{
  switch (data)
  {
    case [] -> []
    case (x::y::zs) ->
    {
      if ((x == '\\') && (y == 'n'))
        zs
      else
        dropUntilBreak(y::zs)
    }
  }
}

# Convert escaped string to Xml forest
sig convertData : (String) -> Xml
fun convertData(data) client
{
  var dataList = splitEscapedLinesJS(data) : [String]; 
  getXmlList(dataList)
}

# Print each member of a list to debug.
sig printEach : ([String]) -> ()
fun printEach(datalist) client
{
  var lList = datalist : [String];
  var p = for (var item <- lList)
    {debug("item: " ++ item);
    []};

  ()
}

# Turn a list of strings into XML.
sig getXmlList : ([String]) -> Xml
fun getXmlList(stringList) server
{
    for (var item <- stringList)
    {
      <#>{stringToXml(replace(['\\'], ['\\','\\'], item))} <br /></#>
    } : Xml
}

# Parse the HTML in the children of the reference, getting all the text nodes
sig getCode : (DomNode) -> String
fun getCode(ref) client
{
  # If this is is null, there's no text
  if (isNull(ref))
  {
    ""
  }
  else
  {
    var tagName = domGetTagNameFromRef(ref);
    var nextSib = nextSibling(ref);
    
    # Recurse
    var outText = switch (tagName)
    { 
      case "BR" -> "\n" ++ getCode(nextSib)
      case "SPAN" -> getTextContent(getChildNodes(getValue(ref))) ++ getCode(nextSib)
      case _ -> getCode(nextSib)
    };

    outText
  }
}

# Unescape a string recursively.
sig unescape : (String, Char) -> String
fun unescape(text, previous)
{
  switch (text)
  {
    case [] -> []
    case (x::xs) -> 
    {
      debug("Curr: " ++ [x]);
      if ((x == '\\') && (previous == '\\'))
      { 
        unescape(xs, ' ')
      }
      else
      {
        x :: unescape(xs, x)
      }
    }
  }
}

# Handle click events in the project browser.
sig navClick : (Event) -> ()
fun navClick(xiEvent) client
{
  # Get the appropriate nodes.
  var im = getTarget(xiEvent);
  var sndIm = nextElementSibling(nextSibling(im));
  var firstList = findFirstMatchingSibling(nextElementSibling(sndIm), "UL", []);  
  
  # Decide what to do based on the current state.
  switch (domGetAttributeFromRef(getTarget(xiEvent), "src"))
  { 
    case "images/rem-blue-box.png" -> 
    {
      var void2 = domSetAttributeFromRef(im, "src", "images/add-blue-box.png");
      var void3 = domSetAttributeFromRef(sndIm, "src", "images/proj-close.png");
      var void4 = domSetStyleAttrFromRef(firstList, "display", "none");
      ()
    }
    case "images/add-blue-box.png" ->
    {
      var void2 = domSetAttributeFromRef(im, "src", "images/rem-blue-box.png");
      var void3 = domSetAttributeFromRef(sndIm, "src", "images/proj-open.png");
      var void4 = domSetStyleAttrFromRef(firstList, "display", "");
      ()
    }
  };
}

sig findFirstParentDiv : (DomNode) -> DomNode
fun findFirstParentDiv(xiNode) client
{
  switch (getTagName(getValue(xiNode)))
  {
    case "DIV" ->
    {
      xiNode
    }
    case _    -> 
    {
      var parent = parentNode(xiNode);
      if (isNull(parent))
      {
        error("No div element found!")
      }
      else
      {
        findFirstParentDiv(parent)
      }
    }
  }
}

# Returns the first element sibling.
# Expects the first sibling to be the node passed in.
sig nextElementSibling : (DomNode) -> DomNode
fun nextElementSibling(xiNode) client
{
  if (isElementNode(xiNode))
  {
    xiNode
  }
  else
  {
    var sibl = nextSibling(xiNode);

    if (isNull(sibl))
    {
      sibl
    }
    else
    {
      nextElementSibling(sibl)
    }
  }
}

sig findFirstMatchingSibling : (DomNode, String, [Attribute]) -> DomNode
fun findFirstMatchingSibling(xiNode, xiType, xiConstraints) client
{
  # Check that the node is an element node of the right type and
  # that the constraints match.
  if ((isElementNode(xiNode)) && (getTagName(getValue(xiNode)) == xiType) && 
      (nodeAttributesMatch(xiNode, xiConstraints)))
  {
    # All constraints match - return
    xiNode
  } 
  else
  {
    var child = nextSibling(xiNode);
    if (isNull(child))
    {
      # Child is null - return it.
      child  
    }
    else
    {
      findFirstMatchingSibling(child, xiType, xiConstraints)
    }
  }
}

# Check whether a list of attributes exist and match for a node.
sig nodeAttributesMatch : (DomNode, [Attribute]) -> Bool
fun nodeAttributesMatch(xiNode, xiAttrs) client
{
  and(for (var attribute <- xiAttrs)
       [domGetAttributeFromRef(xiNode, attribute.attr) == attribute.val])
}
# Look through the project files given recursively and return XML for each.
sig getLProjectList : (ProjectListing, Int, Mailbox ([| SaveFile: (String, String, String)|LoadFile: (String, Event)|])) -> Xml
fun getLProjectList(currItem, currLevel, opHandler) client
{
  var width = intToString(currLevel * 16);
      
  # Determine what type of file we've got
  switch (currItem)
  {
    case LProject((id, name), contents) ->
    {
      # This is a top-level node. Start a new list and find all files that
      # belong to the project.
      # 
      <li class="proj-list-item">
        <div name="closed" type="proj" cname="{name}" pid="{intToString(id)}" l:onclick="{navClick(event)}">
          <img name="box" src="images/add-blue-box.png"/>
          <img src="images/proj-close.png" />  
          <span>
            {stringToXml(name)}
          </span> 
          <ul class="proj-list" style="display: none;">
          {
            # Get the contents of this project
            #var contents = findFiles(currItem);
                       
            # Get the XML
            for (var file <- contents)
              getLProjectList(file, 1, opHandler)
          }
          </ul>
        </div>
      </li>
      
    }
    case LFolder((id, name), contents)  ->
    {
      # This is a folder. Print the folder name, then list files.
      <li class="proj-list-item">
        <div name="closed" type="folder" cname="{name}" l:onclick="{navClick(event)}" >  
          <img src="images/blank.png" style="width: {width}; height: 1px;"/>
          <img name="box" src="images/add-blue-box.png"/>
          <img src="images/proj-close.png" class="proj-blank" />
          <span class="proj-text">
            {stringToXml(name)}
          </span>
          <ul class="proj-list" style="display: none;">
          {
            #var folderData = findFiles(currItem);
            for (var file <- contents)
              getLProjectList(file, (currLevel + 1), opHandler)
          }
          </ul>
        </div>
      </li>
    }
    case LFile(id, name) ->
    {
      # This is a file. Display it.
      # 
      <li class="proj-list-item">
        <div class="proj-node"> 
          <img src="images/blank.png" style="width: {width}; height: 1px;" />
          <img src="images/blank.png" class="proj-blank" />
          <span class="proj-text"  l:onclick="{opHandler ! LoadFile(name, event)}">
          {stringToXml(name)}
          </span>
        </div>
      </li>
    }
    case _ -> <#></#>
  }
}

# Get project listing
sig getProjectListing : (Projects) -> ProjectListing
fun getProjectListing(currItem) server
{
  switch (currItem)
  {
    case Project(id, name) ->
    {
      # Get the contents of this project
      var lProjData = findFiles(currItem);
                       
      # Get the listings
      var lContents =
        for (var lFile <- lProjData)
          [getProjectListing(lFile)];

      LProject((id, name), lContents)
    }
    case Folder(id, name) -> 
    {
      # Find all the subcomponents of this folder
      var lFolderData = findFiles(currItem);
      
      # Loop through them and add to this listing
      var lContents = 
        for (var lFile <- lFolderData)
          [getProjectListing(lFile)];
      
      # Return the listing
      LFolder((id, name), lContents)
    } 
    case File(id, name) -> LFile(id, name)
  }
}

# Print a debug message on the server
fun serverDbg(text) server
{
  debug(text);
}

# Get a list of files belonging to a particular container.
sig findFiles : (Projects) -> [Projects]
fun findFiles(container) server
{
  # Check what type of files we're looking for.
  switch (container)
  {
    case Project(id, name) ->
    {
      # It's a project. Only choose files without a parent.
      for (var file <-- files)
        where ((file.pid == id) && (file.parent < 0))
        orderby (file.name)
        {
          switch (file.isfolder)
          {
            case 1 -> [Folder(file.id, file.name)]
            case _ -> [File(file.id, file.name)]
          } 
        }
    }
    case Folder(id, name) ->
    {
      # It's a folder. Find all files/subfolders.
      for (var file <-- files)
        where (file.parent == id)
        orderby (file.name)
        {
          switch (file.isfolder)
          {
            case 1 -> [Folder(file.id, file.name)]
            case _ -> [File(file.id, file.name)]
          }
        } 
    }
    case _ -> error("Not folder or project")
  }
}

# Get the list of projects
sig getProjs : () -> ProjectListing
fun getProjs() server
{
  var lProjs = 
    for (var projs <-- projectTable)
      where (projs.uid == userId)
      orderby (projs.name)
        [Project(projs.id, projs.name)];

  hd(for (var lProject <- lProjs)
    [getProjectListing(lProject)])
}

# Get the list of files
sig getFileList : (Int) -> [(id: Int, name: String)]
fun getFileList(projId) server
{
  for (var file <-- files)
    where (file.pid == projId)
      [(id = file.id, name = file.name)]
}

# Add a new file.
# @TODO: How to add to project tree? Wherever, or in folder?
sig newFile : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun newFile(xiHandler) client
{
  # Check if doc has changed
  if (docHasChanged())
  {
    # Show box asking if user wants to save
    #toggleActionSave();
  }
  else {};

  # Replace the contents of the document with nothing
  replaceChildren(<#></#>, getDocumentBody());
  
  # Set the name to be nothing
  setFrameData(1, "");
}

# Run the current file.
sig runFile : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun runFile(xiHandler) client
{
  # Toggle waiting.
  toggleWaiting("Running file..");

  # Get the current location, but drop the filename.
  var lLoc = reverse(dropWhile(fun (x) { x <> '/' }, reverse(getLocation())));
  
  # Check if the file is saved, and request that the user saves it first
  if (docHasChanged())
  {
    () #toggleActionSave()
  }
  else {};

  # Get frame data
  var lFrameData = getFrameData();

  # Write file to temp location
  var lFileLoc =  testDir ++ getCookie(cookieName) ++ "/" ++ lFrameData.fname;
  #writeFromDatabase(getFrameName());
  
  # Open a new window pointing to the correct location
  newWindow(lLoc ++ lFileLoc);

  # Toggle waiting.
  toggleWaiting("");
}

sig deploy : () -> ()
fun deploy() server
{
  # Get the user name
  var lUser = hd(for (var lCurrUser <-- users)
                where (lCurrUser.id == userId)
                  [lCurrUser.email]);
  var lSrcDir = fileLoc ++ testDir ++ getCookie(cookieName) ++ "/";
  var lDstDir = fileLoc ++ deplDir ++ lUser ++ "/";
  
  debug("Src: " ++ lSrcDir);
  debug("Dst: " ++ lDstDir);

  # Get the list of files from this user's tmp dir
  var lFileList = getDirContents(lSrcDir);

  # Move the files one by one to the user's real dir
  var lOk = 
    for (var lFile <- lFileList)
    {
      var lRes = moveFile(lSrcDir ++ lFile, lDstDir ++ lFile);
      switch (lRes)
      {
        case Error(err) -> debug(err); [false]
        case _ -> [true]
      }
    };

  if (and(lOk))
    debug("Deployed successfully!")
  else
    debug("Deployment failed!")
}

# Write data from the database to file on disk.
# Returns file location
sig writeFromDatabase : (Int, String) -> String
fun writeFromDatabase(xiPid, xiName) server
{ 
  # Get session ID
  var lFileLoc = testDir ++ getCookie(cookieName) ++ "/" ++ xiName;

  # Get the data
  var lFileData = getFile(xiPid, xiName);

  # Clean it up (calls client!)
  var lCleanData = join("\n", splitEscapedLinesJS(lFileData));

  # Write to disk
  writeToFile(fileLoc ++ lFileLoc, lCleanData);

  lFileLoc
}

# Get the menubar. Currently a drop-down style thing, perhaps a button set
# would be better as there's not a lot of options to change?
sig getMenu : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> Xml
fun getMenu(opHandler) client
{
  <#>
    <div id="menubar">
      <dl>
        <dt id="menu-file-cap" l:onclick="{toggleMenu("menu-file");}" class="menuhead"><span>File</span></dt>
        <dd id="menu-file">
          <ul id="menulist" class="menulist">
            <li l:onclick="{toggleMenu("menu-file"); newFile(opHandler);}" unselectable="on"><span>New file</span></li>
            <li l:onclick="{toggleMenu("menu-file"); maybeSaveFile(opHandler);}" unselectable="on"><span>Save</span></li>
            <li l:onclick="{toggleMenu("menu-file"); toggleVisible("overlay"); toggleVisible("save-file");}" unselectable="on"><span>Save as.. </span></li>
            <li style="height: 1px;"><hr style="height: 2px;" /> </li>
            <li l:onclick="{toggleMenu("menu-file"); runFile(opHandler);}" unselectable="on"><span>Run</span></li>

            <li style="height: 1px;"><hr style="height: 2px;" /> </li> 
            <li l:onclick="{toggleMenu("menu-file"); deploy();}" unselectable="on"><span>Deploy</span></li>

            <li style="height: 1px;"><hr style="height: 2px;" /> </li>
            <li l:onclick="{logout();}" unselectable="on"><span>Logout</span></li>
          </ul>
        </dd>
      </dl>
    </div>
  </#>
}

sig maybeSaveFile : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun maybeSaveFile(xiHandler) client
{
  # Check if the iFrame is named - 'save as' if it isn't
  var lFrameData = getFrameData();
  switch (lFrameData.fname)
  {
    case "*" -> toggleVisible("overlay"); toggleVisible("save-file")
    case ""  -> debug("No name!")
    case _   ->
    {
      var lMatchFun = fun (x) { x <> '*' };

      # Check if a save is needed
      if (length(dropWhile(lMatchFun, lFrameData.fname)) == 1)
      {
        var lRealName = takeWhile(lMatchFun, lFrameData.fname);
        saveFile(xiHandler, lRealName, true);
        setFrameData(lFrameData.pid, lRealName);
      }
      else {};
      ()
    }
  }
}

# Check if the document has been altered.
sig docHasChanged : () -> Bool
fun docHasChanged() client
{
  var lFrameName = (getFrameData()).fname;
  # See if there's a star in the framename.
  length(dropWhile(fun (x) { x <> '*' }, lFrameName)) == 1
}

# Toggle save-before-[action] display
sig toggleActionSave : () -> ()
fun toggleActionSave() client
{
  var lNode      = getNodeById("maybe-save");
  var lInputNode = getNodeById("maybe-save-input");
 
  switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" ->
    {
      var lVoid1 = domSetStyleAttrFromRef(lInputNode, "display", "none");
      var lVoid2 = domSetStyleAttrFromRef(lNode, "display", "none");
      ()
    }
    case _       ->
    {
      # Check if this is a new file
      if(length(takeWhile(fun (x) { x <> '*' }, (getFrameData()).fname)) == 0)
      {
        # Set the filename-box to visible
        var lVoid1 = domSetStyleAttrFromRef(lInputNode, "display", "block");
        ()
      } else {};
      
      # Display the node
      var lVoid2 = domSetStyleAttrFromRef(lNode, "display", "block");
      ()
    }
  };
  
  # Toggle the overlay
  toggleVisible("overlay");
}

# Hide all menu items
sig toggleMenu : (String) -> ()
fun toggleMenu(xiName) client
{
  var lNode = getNodeById(xiName);
  var lVoid = switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" -> domSetStyleAttrFromRef(lNode, "display", "none")
    case _       -> domSetStyleAttrFromRef(lNode, "display", "block")
  };

  toggleBgColour(xiName ++ "-cap", "rgb(133, 177, 255)");
}

# Toggle an element's visibility on/off
sig toggleVisible : (String) -> ()
fun toggleVisible(xiName) client
{
  var lNode = getNodeById(xiName);
  var lOverlay = getNodeById("overlay");
  var lVoid = switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" -> 
    {
      var lVoid = domSetStyleAttrFromRef(lOverlay, "display", "none");
      domSetStyleAttrFromRef(lNode, "display", "none")
    }
    case _      -> 
    {
      var lVoid = domSetStyleAttrFromRef(lOverlay, "display", "block");
      domSetStyleAttrFromRef(lNode, "display", "block")
    }
  };
  ()
}

# Toggle the background colour of the given node.
sig toggleBgColour : (String, String) -> ()
fun toggleBgColour(xiName, xiColour)
{
  var lNode = getNodeById(xiName);
  var lVoid = 
    if (length(domGetStyleAttrFromRef(lNode, "background")) > 1)
      domSetStyleAttrFromRef(lNode, "background", "")
    else
      domSetStyleAttrFromRef(lNode, "background", xiColour);
  
  ()
}

# Toggle the "waiting" box
sig toggleWaiting : (String) -> ()
fun toggleWaiting(xiText) client
{
  var lNode = getNodeById("waiting");
  var lTextNode = nextElementSibling(firstChild(getNodeById("waiting-text")));

  # Node to use.
  var lText = <span class="proj-list-item">{stringToXml(xiText)}</span>;

  switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" ->
    {
      var lVoid = domSetStyleAttrFromRef(lNode, "display", "none");
      ();
    }
    case _ ->
    {
      var lVoid  = domSetStyleAttrFromRef(lNode, "display", "block");
      replaceNode(lText, lTextNode);
    }
  };
  toggleVisible("overlay");
}

# Set a node to be invisible
sig setInvisible : (String) -> ()
fun setInvisible(xiName) client
{
  var lVoid = domSetStyleAttrFromRef(getNodeById(xiName), "display", "none");
  ();
}

# Recursive function to get a node's siblings.
# Only works for element nodes.
sig getSiblingsLinks : (DomNode) -> [DomNode]
fun getSiblingsLinks(xiNode) client
{
  var lXmlNode = getValue(xiNode);
  serverDbg("Tagname: " ++ getTagName(lXmlNode));
  serverDbg("Type? " ++ getAttribute(lXmlNode, "type"));
  if ((not(isElementNode(xiNode))) || (isNull(xiNode)))
    []
  else
    [xiNode] ++ getSiblingsLinks(nextElementSibling(xiNode))
}

# Clean the contents of a form.
# @TODO: broken. Looping doesn't work for DomNode lists?
sig cleanForm : (String) -> ()
fun cleanForm(xiName) client
{
  var lFirst = nextElementSibling(firstChild(getNodeById(xiName)));
  var lVoid = for (var lNode <- getSiblings(lFirst))
  {
    var lXmlNode = getValue(lNode);
    var lVoid = (if ((getTagName(lXmlNode) == "INPUT") && (getAttribute(lXmlNode, "type") == "text"))
        domSetAttributeFromRef(lNode, "value", "")
      else
        "");
    []
  };
  
  # Hide the overlay and the form
  setInvisible("overlay");
  setInvisible(xiName);
}

# Show/Hide the loading window
sig showLoading : (Bool) -> ()
fun showLoading(xiToggle) client
{
  var lNode = getNodeById("loading");
  var lState = 
    if (xiToggle)
      "block"
    else
      "none";
  var lVoid = domSetStyleAttrFromRef(lNode, "display", lState);
  ()
}

# Returns the HTML needed for the 'hidden' objects, i.e. the various dialogs.
sig getHiddenObjects : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> Xml
fun getHiddenObjects(opHandler) client
{
  <#>
    <div class="overlay" id="overlay"></div>
    <div id="save-file" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Save file</span>
        </div>
        <div class="container-box">
          <span class="proj-items padded">
            Name:<br />
            <input type="text" class="input-box proj-items" id="filename" />
          </span>
        </div>
        <div class="bottombar">
          <input type="button" name="save" l:onclick="{saveFile(opHandler, "filename", false); cleanForm("save-file")}" value="Save" />
          <input type="button" name="cancel" l:onclick="{cleanForm("save-file")}" value="Cancel" />
        </div>
      </div>
    </div>
    <div id="maybe-save" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Save current file?</span>
        </div>
        <div id="maybe-save-input" class="container-box invisible">
          <span class="proj-items padded">
            Name:<br />
            <input type="text" class="input-box proj-items" id="save-filename" />
          </span>
        </div>
        <div class="bottombar">
          <input type="button" name="save" l:onclick="{saveFile(opHandler, "save-filename", false); cleanForm("save-file")}" value="Save" />
          <input type="button" name="cancel" l:onclick="{cleanForm("maybe-save")}" value="Don't Save" />
        </div>
      </div>
    </div>
    <div id="waiting" class="invisible">
      <div class="centered box" id="waiting-text">
        <span></span>
      </div>
    </div>
  </#>
}

# Returns the HTML needed for the project browser.
sig getProjBrowser : (Mailbox ([|SaveFile:(String, String, String)|LoadFile:(String, Event)|])) -> Xml
fun getProjBrowser(opHandler) client
{
    <div id="proj-browser" class="proj-browser">
      <div id="proj-caption-bg" class="caption-bg">
        <span id="proj-caption" class="caption-text" unselectable="on">Project Browser</span>
      </div>
      <div id="proj-items" class="proj-items">
        <ul class="proj-list">
         {
           var lProjs = getProjs();
           getLProjectList(lProjs, 0, opHandler)
         }  
        </ul>
      </div>
    </div>
}

# Returns the HTML needed for the code editor.
sig getEditor : () -> Xml
fun getEditor() client
{
    <div id="editor" class="editor">
      <script type="text/javascript">
        var editor = new CodeMirror((document.getElementById("editor")), {{width: "480", height: "400"}});
        window.document.editor = editor;
      </script>
    </div>
}

# Render the editor.
sig renderObject : () -> Xml
fun renderObject() client
{
  # Spawn file handling object.
  var opHandler = spawn { fileOp() };
  <#>
    {
      getHiddenObjects(opHandler)
    }
    <div id="values" class="menu">
      {
        getMenu(opHandler)
      }
    </div>
    {
      getProjBrowser(opHandler)
    }
    <div id="space" class="space"></div>
    {
      getEditor()
    }
  </#>
}

# Redirect to login. 
# TODO: Broken.
sig redir : () -> Xml
fun redir() server 
{
  redirect("login.links");
  <div>not redirected</div>
}

# Main function. 
sig main : () -> Xml
fun main() client 
{
  if (not(isLoggedIn()))
  {
    #<div><a href="login.links">Not logged in</a></div>
    redir()
  }
  else
  {
    # Could possibly introduce a loading bar - but how to do so without
    # rendering everything first? CodeMirror needs the editor div.
  <html>
    <head>
      <title>ug4proj: Links</title>
    </head>
    <script src="CodeMirror/Mochi.js" type="text/javascript"></script>
    <script src="CodeMirror/util.js" type="text/javascript"></script>
    <script src="CodeMirror/tokenizelinks.js" type="text/javascript"></script>
    <script src="CodeMirror/parselinks.js" type="text/javascript"></script>
    <script src="CodeMirror/stringstream.js" type="text/javascript"></script>
    <script src="CodeMirror/select.js" type="text/javascript"></script>
    <script src="CodeMirror/codemirror.js" type="text/javascript"></script>
    
    <link rel="stylesheet" type="text/css" href="proj.css" />
    <body>
      <div id="main" style="z-index: 1;">
      {
        renderObject()
      }
      </div>
    </body>
  </html>
  }
}

page
  <#>{ main() }</#>
  
