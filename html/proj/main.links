# TODO:
#
# - Sort out right-click menu for project list.
# - Figure out how to distinguish between left/right mouse clicks (done)
# - Recreate stopPropagation (is it gone?) (done, but won't work)
# - Clean up SQL calls - there's about 5 for loading the project list..
# - Add new files to project list on creation.
# - Figure out why logging out doesn't work.
# - Test/Deploy configuration. Needs:
#    * Create-dir function (done)
#    * Delete-dir function (done)
#    * Account creation creates user dir
#    * Logging in needs to create new dir based on sessionId (done)
#    * Logging out needs to delete dir (done)
#    * Deploy copies from test to deploy (done)

######
# JavaScript functions
##
# Split lines
alien javascript splitEscapedLinesJS : (String) -> [String];

# Call the code highlighting function of the edit-box.
alien javascript highlightCode : () -> ();

# Return node.value.
alien javascript getValueFromRef : (DomNode) -> String; 

# Functions for (un-)escaping HTML
alien javascript escapeHtml : (String) -> String;
alien javascript unescapeHtml: (String) -> String;

# Convert spaces to 
alien javascript convertSpaces : (String) -> String;

# Load the IDE's editor.
alien javascript loadEditor: () -> DomNode;
alien javascript getSiblings: (DomNode) -> [DomNode];

# Get the current location (ie URL)
alien javascript getLocation: () -> String;

# Create a new window using the URL passed in.
alien javascript newWindow: (String) -> ();

alien javascript testFn: (Event) -> ();
######
# Attribute type
typename Attribute = (attr: String, val: String);

# Things that should be in their own file
var cookieName = "linkside";
var fileLoc = "/home/tom/links/html/proj/";
var testDir = "test/";
var deplDir = "users/";

typename User = (name:String, password:String);
typename ProjConts = (Int, String);
typename Projects = [| Project : ProjConts | Folder : ProjConts | File : ProjConts |];

# Databases to access
var users = table "users" with (
    id : Int,
    email: String,
    password: String
) from (database "ide");

var projectTable = table "projects" with (
    id : Int,
    uid : Int,
    name : String
) from (database "ide");

var files = table "files" with (
    id : Int,
    pid : Int,
    name : String,
    last_mod : String,
    created : String, 
    data : String,
    parent : Int,
    isfolder : Int
) from (database "ide");

var sessionsTable = table "sessions" with (
    id : String,
    uid : Int,
    creation_time : Int,
    update_time : Int
) from (database "ide");

var validSessions = table "valid_sessions" with (
    id : String,
    uid : Int
) from (database "ide");

# Count the number of elements in a list
fun numElems(lst) server
{
  switch(lst)
  {
    case [] -> 0
    case x::xs -> 1 + numElems(xs)
  }
}

# Logout from the IDE
sig logout : () -> ()
fun logout() server
{
  var lId = getCookie("linkside");
  delete (var sessId <-- sessionsTable)
    where (sessId.id == lId);

  # Delete temporary directory (and all its contents..)
  switch (rmdirForce(fileLoc ++ testDir ++ lId))
  {
    case Error(err) -> debug("Error on rmdir: " ++ err);
    case _ -> ()
  };

  setCookie("linkside","");
  redirect("login.links");
}

##
# Normal code.
##

# Return the uid of the current sessions' owner.
sig getUid : () -> Int
fun getUid() server
{
  var uids = for (var sid <-- sessionsTable)
             where (sid.id == getCookie("linkside"))
              [sid.uid];
  if (numElems(uids) == 0)
    1
  else
    hd(uids)
}

# Userid of session owner
var userId = getUid();

# Check whether the user is logged in
fun isLoggedIn() server
{
  var sessId = getCookie(cookieName);
  debug("cookie: " ++ sessId);
  # Check that the sessid exists in the database
  var p = numElems(for (var lSess <-- validSessions)
    where (lSess.id == sessId)
      [lSess.id]) == 1;
  (if (p)
    debug("logged in")
  else
    debug("not logged in"));
  #p
  true
}

# Perform file operations (load, save).
fun fileOp() client
{
  receive 
  {
    case SaveFile(name, escp, code) -> 
    {
      toggleWaiting("Saving file..");
      storeFile(name, escp, code); 
      #updateSession();
      setFrameName(name);
      toggleWaiting("");
      fileOp()
    }
    case LoadFile(name) -> 
    {
       toggleWaiting("Loading file..");
       var lData = getFile(name);
       var rval = convertData(lData) : Xml;
       
       insertCode(rval);
       #updateSession();
       setFrameName(name);
       toggleWaiting("");
       fileOp()
    }
  }
}

# Show/hide loading message
fun loading() client
{
  receive 
  {
    case Show() -> 
    {
      # Display the overlay on top of everything else
      showLoading(true);

      # Call loading as we're waiting for a hide-command
      loading()
    }
    case Hide() -> showLoading(false);
  }
}

# Project list menu.
sig projMenu : (Event) -> ()
fun projMenu(xiEvent) client
{
  debug(intToString(getMouseButton(xiEvent)));
  # Stop the event from propagating - we don't want the normal menu
  stopPropagation(xiEvent);
  ()  
}

# Update the last-access time of the session
sig updateSession : () -> ()
fun updateSession() server
{
  update (var sid <-- sessionsTable)
    where (sid.uid == 1)
    set (id = sid.id, uid = userId, creation_time = 0, update_time = 0)
}

# Store the code in the database
sig storeFile : (String, String, String) -> ()
fun storeFile(name, escp, code) server 
{
  # Insert if new, update otherwise
  if (not(fileExists(name)))
  {
    insert files values [(id=0, pid=1, name=name, last_mod="", created="", data=escp, parent = -1, isfolder = 0)];
  }
  else {
    update (var lFile <-- files)
     where ((lFile.pid == 1) && (lFile.name == name))
     set (id = lFile.id, pid = lFile.pid, name = lFile.name, last_mod=lFile.last_mod, created = lFile.created, data = escp, parent = lFile.parent, isfolder = 0)
  };
  
  # @TODO: Do we want to save the file here? No real need if test/depl,
  # but useful for knowing which files are to be changed. The other 
  # option is to mark modified files in the db.
  writeToFile(fileLoc ++ testDir ++ getCookie(cookieName) ++ "/" ++ name, code);
  updateSession();
}

# Save the contents of the current buffer to database
sig saveFile : (Mailbox ([|SaveFile:(String, String, String)|a|]), String, Bool) -> ()
fun saveFile(handler, xiName, xiNew) client
{
  var lBody = getDocumentBody();
  
  # Get the text
  var lCode = convertSpaces(getCode(firstChild(lBody)));
  var lEscapedCode = escapeHtml(lCode);

  # This is potentially the name of the node containing the filename
  var lNodeName = xiName;

  # Store the code in the database
  var lFileName = 
    (if (xiNew)
      xiName
     else
      getValueFromRef(getNodeById(lNodeName))
    );

  handler ! SaveFile(lFileName, lEscapedCode, lCode);
}

# Load a file from the database
sig getFile : (String) -> String
fun getFile(name) server
{
  var res = for (var lFile <-- files)
    where ((lFile.pid == 1) && (lFile.name == name))
    {
      [lFile.data]
    };
  
  # Update the session while we're here
  updateSession();

  if (numElems(res) == 0)
    "No such file '" ++ name ++ "'."
  else
   hd(res)
}

# Check if a file exists
sig fileExists : (String) -> Bool
fun fileExists(name) server
{
  var lCount = for (var lFile <-- files)
    where ((lFile.pid == 1) && (lFile.name == name))
    [lFile.pid];

  numElems(lCount) >= 1
}

# Get the body tag containing code
sig getDocumentBody : () -> DomNode
fun getDocumentBody() client
{
  # Get the HTML: find the iframe, then the doc
  var lIfr = getContentDocument(hd(getElementsByTagName("iframe")));
  hd(getElementsByTagNameFromRef("body", lIfr))
}

# Set the name of the IFrame 
sig setFrameName : (String) -> ()
fun setFrameName(xiName) client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  var lNull = domSetAttributeFromRef(lIfr, "name", xiName);
  ()
}

# Get the name of the IFrame
sig getFrameName : () -> String
fun getFrameName() client
{
  var lIfr = hd(getElementsByTagName("iframe"));
  domGetAttributeFromRef(lIfr, "name")
}

# Insert code into the document, then highlight it.
sig insertCode : (Xml) -> ()
fun insertCode(code) client
{
  replaceChildren(code, getDocumentBody());
  highlightCode();
}

# Recursive version of splitlines. Works, but is slow.
sig splitLines : (String) -> [String]
fun splitLines(datalist)
{ 
  switch (datalist)
  { 
    case [] -> []
    case xs -> 
    {
      var listHead = takeUntilBreak(xs) : String;
      var listTail = dropUntilBreak(xs) : String;
      [listHead] ++ splitLines(listTail)
    }
  }
}

# Recursive function, taking all chars until a line break is found. Slow.
sig takeUntilBreak : (String) -> String
fun takeUntilBreak(data)
{
  switch (data)
  {
    case [] -> []
    case (x::y::zs) ->
    {
      if ((x == '\\') && (y == 'n'))
        []
      else
        x :: takeUntilBreak(y::zs)
    }
  }
}

# Recursive function, dropping all chars until a line break is found. Slow.
sig dropUntilBreak : (String) -> String
fun dropUntilBreak(data)
{
  switch (data)
  {
    case [] -> []
    case (x::y::zs) ->
    {
      if ((x == '\\') && (y == 'n'))
        zs
      else
        dropUntilBreak(y::zs)
    }
  }
}

# Convert escaped string to Xml forest
sig convertData : (String) -> Xml
fun convertData(data) client
{
  var dataList = splitEscapedLinesJS(data) : [String]; 
  getXmlList(dataList)
}

# Print each member of a list to debug.
sig printEach : ([String]) -> ()
fun printEach(datalist) client
{
  var lList = datalist : [String];
  var p = for (var item <- lList)
    {debug("item: " ++ item);
    []};

  ()
}

# Turn a list of strings into XML.
sig getXmlList : ([String]) -> Xml
fun getXmlList(stringList) server
{
    for (var item <- stringList)
    {
      <#>{stringToXml(replace(['\\'], ['\\','\\'], item))} <br /></#>
    } : Xml
}

# Parse the HTML in the children of the reference, getting all the text nodes
sig getCode : (DomNode) -> String
fun getCode(ref) client
{
  # If this is is null, there's no text
  if (isNull(ref))
  {
    ""
  }
  else
  {
    var tagName = domGetTagNameFromRef(ref);
    var nextSib = nextSibling(ref);
    
    # Recurse
    var outText = switch (tagName)
    { 
      case "BR" -> "\n" ++ getCode(nextSib)
      case "SPAN" -> getTextContent(getChildNodes(getValue(ref))) ++ getCode(nextSib)
      case _ -> getCode(nextSib)
    };

    outText
  }
}

# Unescape a string recursively.
sig unescape : (String, Char) -> String
fun unescape(text, previous)
{
  switch (text)
  {
    case [] -> []
    case (x::xs) -> 
    {
      debug("Curr: " ++ [x]);
      if ((x == '\\') && (previous == '\\'))
      { 
        unescape(xs, ' ')
      }
      else
      {
        x :: unescape(xs, x)
      }
    }
  }
}

# Handle click events in the project browser.
sig navClick : (Event) -> ()
fun navClick(xiEvent) client
{
  # Get the appropriate nodes.
  var im = getTarget(xiEvent);
  var sndIm = nextElementSibling(nextSibling(im));
  var firstList = findFirstMatchingSibling(nextElementSibling(sndIm), "UL", []);  
  
  # Decide what to do based on the current state.
  switch (domGetAttributeFromRef(getTarget(xiEvent), "src"))
  { 
    case "images/rem-blue-box.png" -> 
    {
      var void2 = domSetAttributeFromRef(im, "src", "images/add-blue-box.png");
      var void3 = domSetAttributeFromRef(sndIm, "src", "images/proj-close.png");
      var void4 = domSetStyleAttrFromRef(firstList, "display", "none");
      ()
    }
    case "images/add-blue-box.png" ->
    {
      var void2 = domSetAttributeFromRef(im, "src", "images/rem-blue-box.png");
      var void3 = domSetAttributeFromRef(sndIm, "src", "images/proj-open.png");
      var void4 = domSetStyleAttrFromRef(firstList, "display", "");
      ()
    }
  };
}

sig findFirstParentDiv : (DomNode) -> DomNode
fun findFirstParentDiv(xiNode) client
{
  switch (getTagName(getValue(xiNode)))
  {
    case "DIV" ->
    {
      xiNode
    }
    case _    -> 
    {
      var parent = parentNode(xiNode);
      if (isNull(parent))
      {
        error("No div element found!")
      }
      else
      {
        findFirstParentDiv(parent)
      }
    }
  }
}

# Returns the first element sibling.
# Expects the first sibling to be the node passed in.
sig nextElementSibling : (DomNode) -> DomNode
fun nextElementSibling(xiNode) client
{
  if (isElementNode(xiNode))
  {
    xiNode
  }
  else
  {
    var sibl = nextSibling(xiNode);

    if (isNull(sibl))
    {
      sibl
    }
    else
    {
      nextElementSibling(sibl)
    }
  }
}

sig findFirstMatchingSibling : (DomNode, String, [Attribute]) -> DomNode
fun findFirstMatchingSibling(xiNode, xiType, xiConstraints) client
{
  # Check that the node is an element node of the right type and
  # that the constraints match.
  if ((isElementNode(xiNode)) && (getTagName(getValue(xiNode)) == xiType) && 
      (nodeAttributesMatch(xiNode, xiConstraints)))
  {
    # All constraints match - return
    xiNode
  } 
  else
  {
    var child = nextSibling(xiNode);
    if (isNull(child))
    {
      # Child is null - return it.
      child  
    }
    else
    {
      findFirstMatchingSibling(child, xiType, xiConstraints)
    }
  }
}

# Check whether a list of attributes exist and match for a node.
sig nodeAttributesMatch : (DomNode, [Attribute]) -> Bool
fun nodeAttributesMatch(xiNode, xiAttrs) client
{
  and(for (var attribute <- xiAttrs)
       [domGetAttributeFromRef(xiNode, attribute.attr) == attribute.val])
}

# Recursive function. Takes a Project at a particular level, looks 
# at its type and either tries to find more files/folders or returns
# the XML gathered.
sig getProjectList : (Projects, Int, Mailbox ([| LoadFile: String|a|])) -> Xml
fun getProjectList(currItem, currLevel, opHandler) client
{
  var width = intToString(currLevel * 16);
      
  # Determine what type of file we've got
  switch (currItem)
  {
    case Project(id, name) ->
    {
      # This is a top-level node. Start a new list and find all files that
      # belong to the project.
      <li class="proj-list-item">
        <div name="closed">
          <img name="box" src="images/add-blue-box.png" l:onclick="{navClick(event)}" />
          <img src="images/proj-close.png" />  
          <span>
            {stringToXml(name)}
          </span> 
          <ul class="proj-list" style="display: none;">
          {
            # Get the contents of this project
            var contents = findFiles(currItem);
                       
            # Get the XML
            for (var file <- contents)
              getProjectList(file, 1, opHandler)
          }
          </ul>
        </div>
      </li>
      
    }
    case Folder(id, name)  ->
    {
      serverDbg("Folder: " ++ name);
      # This is a folder. Print the folder name, then list files.
      <li class="proj-list-item">
        <div name="closed"> 
          <img src="images/blank.png" style="width: {width}; height: 1px;"/>
          <img name="box" src="images/add-blue-box.png" l:onclick="{navClick(event)}"/>
          <img src="images/proj-close.png" class="proj-blank" />
          <span class="proj-text">
            {stringToXml(name)}
          </span>
          <ul class="proj-list" style="display: none;">
          {
            var folderData = findFiles(currItem);
            for (var file <- folderData)
            {
              switch (file)
              {
                case File(id, name) -> 
                {
                  debug("folder-file.name: " ++ name);
                  getProjectList(file, (currLevel + 1), opHandler)
                }
                case _ -> 
                {
                  debug("Error!!");
                  <li>error</li>
                }
              }
            } 
          }
          </ul>
        </div>
      </li>
    }
    case File(id, name) ->
    {
      serverDbg("File: " ++ name);
    
      # This is a file. Display it.
      <li class="proj-list-item">
        <div class="proj-node"> 
          <img src="images/blank.png" style="width: {width}; height: 1px;" />
          <img src="images/blank.png" class="proj-blank" />
          <span class="proj-text" l:onclick="{opHandler ! LoadFile(name)}">
          {stringToXml(name)}
          </span>
        </div>
      </li>
    }
  }
}

# Print a debug message on the server
fun serverDbg(text) server
{
  debug(text);
}

# Get a list of files belonging to a particular container.
sig findFiles : (Projects) -> [Projects]
fun findFiles(container) server
{
  # Check what type of files we're looking for.
  switch (container)
  {
    case Project(id, name) ->
    {
      # It's a project. Only choose files without a parent.
      for (var file <-- files)
        where ((file.pid == id) && (file.parent < 0))
        orderby (file.name)
        {
          debug("Looking at file " ++ file.name);
          switch (file.isfolder)
          {
            case 1 -> [Folder(file.id, file.name)]
            case _ -> [File(file.id, file.name)]
          } 
        }
    }
    case Folder(id, name) ->
    {
      # It's a folder. Find all files/subfolders.
      for (var file <-- files)
        where (file.parent == id)
        orderby (file.name)
        {
          switch (file.isfolder)
          {
            case 1 -> [Folder(file.id, file.name)]
            case _ -> [File(file.id, file.name)]
          }
        } 
    }
    case _ -> error("Not folder or project")
  }
}

# Get the project list.
sig getProjList : () -> [(id: Int, name: String)]
fun getProjList() server
{
  for (var projs <-- projectTable)
    where (projs.uid == userId)
      [(id = projs.id, name = projs.name)]
}

# Get the list of projects
sig getProjs : () -> [Projects]
fun getProjs() server
{
  for (var projs <-- projectTable)
    where (projs.uid == userId)
    orderby (projs.name)
      [Project(projs.id, projs.name)]
}

# Get the list of files
sig getFileList : (Int) -> [(id: Int, name: String)]
fun getFileList(projId) server
{
  for (var file <-- files)
    where (file.pid == projId)
      [(id = file.id, name = file.name)]
}

# Add a new file.
# @TODO: How to add to project tree? Wherever, or in folder?
sig newFile : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun newFile(xiHandler) client
{
  # Check if doc has changed
  if (docHasChanged())
  {
    # Show box asking if user wants to save
    #toggleActionSave();
  }
  else {};

  # Replace the contents of the document with nothing
  replaceChildren(<#></#>, getDocumentBody());
  
  # Set the name to be nothing
  setFrameName("");
}

# Run the current file.
sig runFile : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun runFile(xiHandler) client
{
  # Toggle waiting.
  toggleWaiting("Running file..");

  # Get the current location, but drop the filename.
  var lLoc = reverse(dropWhile(fun (x) { x <> '/' }, reverse(getLocation())));
  
  # Check if the file is saved, and request that the user saves it first
  if (docHasChanged())
  {
    () #toggleActionSave()
  }
  else {};

  # Write file to temp location
  var lFileLoc =  testDir ++ getCookie(cookieName) ++ "/" ++ getFrameName();
  #writeFromDatabase(getFrameName());
  
  # Open a new window pointing to the correct location
  newWindow(lLoc ++ lFileLoc);

  # Toggle waiting.
  toggleWaiting("");
}

sig deploy : () -> ()
fun deploy() server
{
  # Get the user name
  var lUser = hd(for (var lCurrUser <-- users)
                where (lCurrUser.id == userId)
                  [lCurrUser.email]);
  var lSrcDir = fileLoc ++ testDir ++ getCookie(cookieName) ++ "/";
  var lDstDir = fileLoc ++ deplDir ++ lUser ++ "/";
  
  debug("Src: " ++ lSrcDir);
  debug("Dst: " ++ lDstDir);

  # Get the list of files from this user's tmp dir
  var lFileList = getDirContents(lSrcDir);

  # Move the files one by one to the user's real dir
  var lOk = 
    for (var lFile <- lFileList)
    {
      var lRes = moveFile(lSrcDir ++ lFile, lDstDir ++ lFile);
      switch (lRes)
      {
        case Error(err) -> debug(err); [false]
        case _ -> [true]
      }
    };

  if (and(lOk))
    debug("Deployed successfully!")
  else
    debug("Deployment failed!")
}

#
# Write data from the database to file on disk.
# Returns file location
sig writeFromDatabase : (String) -> String
fun writeFromDatabase(xiName) server
{ 
  # Get session ID
  var lFileLoc = testDir ++ getCookie(cookieName) ++ "/" ++ xiName;

  # Get the data
  var lFileData = getFile(xiName);

  # Clean it up (calls client!)
  var lCleanData = join("\n", splitEscapedLinesJS(lFileData));

  # Write to disk
  writeToFile(fileLoc ++ lFileLoc, lCleanData);

  lFileLoc
}

# Get the menubar. Currently a drop-down style thing, perhaps a button set
# would be better as there's not a lot of options to change?
sig getMenu : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> Xml
fun getMenu(opHandler) client
{
  <#>
    <div id="menubar">
      <dl>
        <dt id="menu-file-cap" l:onclick="{toggleMenu("menu-file");}" class="menuhead"><span>File</span></dt>
        <dd id="menu-file">
          <ul id="menulist" class="menulist">
            <li l:onclick="{toggleMenu("menu-file"); newFile(opHandler);}" unselectable="on"><span>New file</span></li>
            <li l:onclick="{toggleMenu("menu-file"); maybeSaveFile(opHandler);}" unselectable="on"><span>Save</span></li>
            <li l:onclick="{toggleMenu("menu-file"); toggleVisible("overlay"); toggleVisible("save-file");}" unselectable="on"><span>Save as.. </span></li>
            <li style="height: 1px;"><hr style="height: 2px;" /> </li>
            <li l:onclick="{toggleMenu("menu-file"); runFile(opHandler);}" unselectable="on"><span>Run</span></li>

            <li style="height: 1px;"><hr style="height: 2px;" /> </li> 
            <li l:onclick="{toggleMenu("menu-file"); deploy();}" unselectable="on"><span>Deploy</span></li>

            <li style="height: 1px;"><hr style="height: 2px;" /> </li>
            <li l:onclick="{logout();}" unselectable="on"><span>Logout</span></li>
          </ul>
        </dd>
      </dl>
    </div>
  </#>
}

sig maybeSaveFile : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> ()
fun maybeSaveFile(xiHandler) client
{
  # Check if the iFrame is named - 'save as' if it isn't
  var lFrameName = getFrameName();
  switch (lFrameName)
  {
    case "*" -> toggleVisible("overlay"); toggleVisible("save-file")
    case ""  -> debug("No name!")
    case _   ->
    {
      var lMatchFun = fun (x) { x <> '*' };

      # Check if a save is needed
      if (length(dropWhile(lMatchFun, lFrameName)) == 1)
      {
        var lRealName = takeWhile(lMatchFun, lFrameName);
        saveFile(xiHandler, lRealName, true);
        setFrameName(lRealName);
      }
      else {};
      ()
    }
  }
}

# Check if the document has been altered.
sig docHasChanged : () -> Bool
fun docHasChanged() client
{
  # See if there's a star in the framename.
  length(dropWhile(fun (x) { x <> '*' }, getFrameName())) == 1
}

# Toggle save-before-[action] display
sig toggleActionSave : () -> ()
fun toggleActionSave() client
{
  var lNode      = getNodeById("maybe-save");
  var lInputNode = getNodeById("maybe-save-input");
 
  switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" ->
    {
      var lVoid1 = domSetStyleAttrFromRef(lInputNode, "display", "none");
      var lVoid2 = domSetStyleAttrFromRef(lNode, "display", "none");
      ()
    }
    case _       ->
    {
      # Check if this is a new file
      if(length(takeWhile(fun (x) { x <> '*' }, getFrameName())) == 0)
      {
        # Set the filename-box to visible
        var lVoid1 = domSetStyleAttrFromRef(lInputNode, "display", "block");
        ()
      } else {};
      
      # Display the node
      var lVoid2 = domSetStyleAttrFromRef(lNode, "display", "block");
      ()
    }
  };
  
  # Toggle the overlay
  toggleVisible("overlay");
}

# Hide all menu items
sig toggleMenu : (String) -> ()
fun toggleMenu(xiName) client
{
  var lNode = getNodeById(xiName);
  var lVoid = switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" -> domSetStyleAttrFromRef(lNode, "display", "none")
    case _       -> domSetStyleAttrFromRef(lNode, "display", "block")
  };

  toggleBgColour(xiName ++ "-cap", "rgb(133, 177, 255)");
}

# Toggle an element's visibility on/off
sig toggleVisible : (String) -> ()
fun toggleVisible(xiName) client
{
  var lNode = getNodeById(xiName);
  var lOverlay = getNodeById("overlay");
  var lVoid = switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" -> 
    {
      var lVoid = domSetStyleAttrFromRef(lOverlay, "display", "none");
      domSetStyleAttrFromRef(lNode, "display", "none")
    }
    case _      -> 
    {
      var lVoid = domSetStyleAttrFromRef(lOverlay, "display", "block");
      domSetStyleAttrFromRef(lNode, "display", "block")
    }
  };
  ()
}

# Toggle the background colour of the given node.
sig toggleBgColour : (String, String) -> ()
fun toggleBgColour(xiName, xiColour)
{
  var lNode = getNodeById(xiName);
  var lVoid = 
    if (length(domGetStyleAttrFromRef(lNode, "background")) > 1)
      domSetStyleAttrFromRef(lNode, "background", "")
    else
      domSetStyleAttrFromRef(lNode, "background", xiColour);
  
  ()
}

# Toggle the "waiting" box
sig toggleWaiting : (String) -> ()
fun toggleWaiting(xiText) client
{
  var lNode = getNodeById("waiting");
  var lTextNode = nextElementSibling(firstChild(getNodeById("waiting-text")));

  # Node to use.
  var lText = <span class="proj-list-item">{stringToXml(xiText)}</span>;

  switch (domGetStyleAttrFromRef(lNode, "display"))
  {
    case "block" ->
    {
      var lVoid = domSetStyleAttrFromRef(lNode, "display", "none");
      ();
    }
    case _ ->
    {
      var lVoid  = domSetStyleAttrFromRef(lNode, "display", "block");
      replaceNode(lText, lTextNode);
    }
  };
  toggleVisible("overlay");
}

# Set a node to be invisible
sig setInvisible : (String) -> ()
fun setInvisible(xiName) client
{
  var lVoid = domSetStyleAttrFromRef(getNodeById(xiName), "display", "none");
  ();
}

# Recursive function to get a node's siblings.
# Only works for element nodes.
sig getSiblingsLinks : (DomNode) -> [DomNode]
fun getSiblingsLinks(xiNode) client
{
  var lXmlNode = getValue(xiNode);
  serverDbg("Tagname: " ++ getTagName(lXmlNode));
  serverDbg("Type? " ++ getAttribute(lXmlNode, "type"));
  if ((not(isElementNode(xiNode))) || (isNull(xiNode)))
    []
  else
    [xiNode] ++ getSiblingsLinks(nextElementSibling(xiNode))
}

# Clean the contents of a form.
# @TODO: broken. Looping doesn't work for DomNode lists?
sig cleanForm : (String) -> ()
fun cleanForm(xiName) client
{
  var lFirst = nextElementSibling(firstChild(getNodeById(xiName)));
  var lVoid = for (var lNode <- getSiblings(lFirst))
  {
    var lXmlNode = getValue(lNode);
    var lVoid = (if ((getTagName(lXmlNode) == "INPUT") && (getAttribute(lXmlNode, "type") == "text"))
        domSetAttributeFromRef(lNode, "value", "")
      else
        "");
    []
  };
  
  # Hide the overlay and the form
  setInvisible("overlay");
  setInvisible(xiName);
}

# Show/Hide the loading window
sig showLoading : (Bool) -> ()
fun showLoading(xiToggle) client
{
  var lNode = getNodeById("loading");
  var lState = 
    if (xiToggle)
      "block"
    else
      "none";
  var lVoid = domSetStyleAttrFromRef(lNode, "display", lState);
  ()
}

# Returns the HTML needed for the 'hidden' objects, i.e. the various dialogs.
sig getHiddenObjects : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> Xml
fun getHiddenObjects(opHandler) client
{
  <#>
    <div class="overlay" id="overlay"></div>
    <div id="save-file" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Save file</span>
        </div>
        <div class="container-box">
          <span class="proj-items padded">
            Name:<br />
            <input type="text" class="input-box proj-items" id="filename" />
          </span>
        </div>
        <div class="bottombar">
          <input type="button" name="save" l:onclick="{saveFile(opHandler, "filename", false); cleanForm("save-file")}" value="Save" />
          <input type="button" name="cancel" l:onclick="{cleanForm("save-file")}" value="Cancel" />
        </div>
      </div>
    </div>
    <div id="maybe-save" class="invisible">
      <div class="centered box">
        <div class="topbar">
          <span class="caption-text" unselectable="on">Save current file?</span>
        </div>
        <div id="maybe-save-input" class="container-box invisible">
          <span class="proj-items padded">
            Name:<br />
            <input type="text" class="input-box proj-items" id="save-filename" />
          </span>
        </div>
        <div class="bottombar">
          <input type="button" name="save" l:onclick="{saveFile(opHandler, "save-filename", false); cleanForm("save-file")}" value="Save" />
          <input type="button" name="cancel" l:onclick="{cleanForm("maybe-save")}" value="Don't Save" />
        </div>
      </div>
    </div>
    <div id="waiting" class="invisible">
      <div class="centered box" id="waiting-text">
        <span></span>
      </div>
    </div>
  </#>
}

# Returns the HTML needed for the project browser.
sig getProjBrowser : (Mailbox ([|SaveFile:(String, String, String)|a|])) -> Xml
fun getProjBrowser(opHandler) client
{
    <div id="proj-browser" class="proj-browser">
      <div id="proj-caption-bg" class="caption-bg">
        <span id="proj-caption" class="caption-text" unselectable="on">Project Browser</span>
      </div>
      <div id="proj-items" class="proj-items" l:onmouseup="{testFn(event);}">
        <ul class="proj-list">
         {
           var projects = []; #getProjs();
           
           if (length(projects) > 0)
           {
             for (var project <- projects)
               getProjectList(project, 0, opHandler)
           }
           else
             <#></#>
           }   
        </ul>
      </div>
    </div>
}

# Returns the HTML needed for the code editor.
sig getEditor : () -> Xml
fun getEditor() client
{
    <div id="editor" class="editor">
      <script type="text/javascript">
        var editor = new CodeMirror((document.getElementById("editor")), {{width: "480", height: "400"}});
        window.document.editor = editor;
      </script>
    </div>
}

# Render the editor.
sig renderObject : () -> Xml
fun renderObject() client
{
  # Spawn file handling object.
  var opHandler = spawn { fileOp() };
  <#>
    {
      getHiddenObjects(opHandler)
    }
    <div id="values" class="menu">
      {
        getMenu(opHandler)
      }
    </div>
    {
      getProjBrowser(opHandler)
    }
    <div id="space" class="space"></div>
    {
      getEditor()
    }
  </#>
}

# Redirect to login. 
# TODO: Broken.
sig redir : () -> Xml
fun redir() server 
{
  redirect("login.links");
  <div>not redirected</div>
}

# Main function. 
sig main : () -> Xml
fun main() client 
{
  if (not(isLoggedIn()))
  {
    #<div><a href="login.links">Not logged in</a></div>
    redir()
  }
  else
  {
    # Could possibly introduce a loading bar - but how to do so without
    # rendering everything first? CodeMirror needs the editor div.
  <html>
    <head>
      <title>ug4proj: Links</title>
    </head>
    <script src="CodeMirror/Mochi.js" type="text/javascript"></script>
    <script src="CodeMirror/util.js" type="text/javascript"></script>
    <script src="CodeMirror/tokenizelinks.js" type="text/javascript"></script>
    <script src="CodeMirror/parselinks.js" type="text/javascript"></script>
    <script src="CodeMirror/stringstream.js" type="text/javascript"></script>
    <script src="CodeMirror/select.js" type="text/javascript"></script>
    <script src="CodeMirror/codemirror.js" type="text/javascript"></script>
    
    <link rel="stylesheet" type="text/css" href="proj.css" />
    <body>
      <div id="main" style="z-index: 1;">
      {
        renderObject()
      }
      </div>
    </body>
  </html>
  }
}

page
  <#>{ main() }</#>
  
