#
# Interpreting of state via parameterised handlers
#

#
# Convenient type alias for stateful computations
#
typename SComp(e::Row, s, a) = Comp({Get:s, Put:(s) {}-> () |e}, a);

#
# Operations
#
sig get : Comp({Get:s |_}, s)
fun get() {do Get}

sig put : (s) {Put:(s) {}-> () |_}~> ()
fun put(s) {do Put(s)}


#
# Parameterised state handler
# The list of parameters is curried.
#
sig state : (SComp({ }, s, a)) -> (s) ~> a
handler state(m)(s) {
     case Get(k)   -> k(s)(s)
     case Put(p,k) -> k(())(p)
     case Return(x)-> x
}


# Equivalent to the above, but the operation Put(s,k) shadows the state parameter s
sig stateShadow : (SComp({ }, s, a)) -> (s) ~> a
handler stateShadow(m)(s) {
     case Get(k)   -> k(s)(s)
     case Put(p,k) -> k(())(p)
     case Return(x)-> x
}

# Similarly, we can shadow the state parameter via aliasing
sig stateAlias : (SComp({ }, s, a)) -> (s) ~> a
handler stateAlias(m)(s) {
     case Get(k)   -> k(s)(s)
     case Put(p as s,k) -> k(())(s)
     case Return(x)-> x
}

# ... works the other way around as well!
sig stateAlias2 : (SComp({ }, s, a)) -> (s) ~> a
handler stateAlias2(m)(s) {
     case Get(k)   -> k(s)(s)
     case Put(s as p,k) -> k(())(p)
     case Return(x)-> x
}

# A stateful computation.
# First it retrieves the current state and increments it by one.
# Thereafter it retrieves the updated state and doubles it.
# Finally, the final state is returned.
sig scomp : SComp({ |_}, Int, Int)
fun scomp() {
    var s = get(); put(s + 1);
    var s = get(); put(s + s);
    get()
}

# links> state(scomp)(0);
# 2 : Int
#
# links> state(scomp)(2);
# 6 : Int
#
# links> state(scomp)(-2);
# -2 : Int
#
#
# links> (state(scomp)(0) == stateShadow(scomp)(0)) == (stateAlias(scomp)(0) == stateAlias2(scomp)(0));
# true : Bool


#
# Desugaring the state handler
# Parameterised handlers are syntax sugar, that save some typing.
# For example the state handler desugars into
sig stateDesugared : (SComp({ }, s, a)) ~e~> (s) ~e~> a
handler stateDesugared(m) {
  case Get(k)    -> fun(s) { k(s)(s)  }
  case Put(s,k)  -> fun(_) { k(())(s) }
  case Return(x) -> fun(s) { x }
}


# links> state(scomp)(0) == stateDesugared(scomp)(0);
# true : Bool
