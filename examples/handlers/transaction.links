# Transaction example

# Closed state handler
handler state(m) {
     case Get(_,k)  -> fun(s) { k(s)(s)  }
     case Put(p,k)  -> fun(s) { k(())(p) }
     case Return(x) -> fun(s) { x }
}

# State runner
fun runState(m, s0) {
    state(m)(s0)
}

# The transaction handler utilitises state API to maintain the transaction-state.
open handler transaction(m) {
     case Commit(p,k) -> { do Put(p); k(p) }
     case Abort(p,k)  -> (do Get(), "Aborted: " ^^ p)
     case Return(x)   -> (do Get(), "Committed")
}

# Returns whether the transaction was successful.
open handler transBool(m) {
     case Return((x,"Committed")) -> true
     case Return((x,_))           -> false
}

# Some computation
fun comp() {
    var s = do Get();
    # Some critical work
    # Check computation state
    if (s == 2) {
       do Abort("Unexpected state.")
    } else {
       do Commit(s+2)
    }
}
