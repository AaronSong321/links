# Parsing
handler parser(m) {
	case Token((p,s),k) -> {
	     switch (s) {
	     	    case (x :: xs) -> { k((x,(x :: p,xs))) }
		    case [] -> Nothing
	     }
	}
	case Choose(_,k) -> {
	     switch (k(true)) {
	     	    case Nothing -> k(false)
		    case Just(x) -> Just(x)
	     }
	}
	case Fail(_,_)  -> Nothing
	case Return((p,[]))  -> Just(reverse(p))
	case Return(_)       -> Nothing
}

fun parse(source) {
    var inp = explode(source);
    var s = ([], inp);
    var r = parser(fun() { grammar(s) });
    switch (r) {
       case Just(p) -> Just(implode(p))
       case Nothing -> Nothing
    }
}

fun stop(s) {
    s
}

fun token(t, s) {
    fun(s) {
        var c = do Token(s);
    	var t1 = first(c);
	    if (t == t1) {
	      second(c)
	    } else {
	      do Fail()
	    }
    }
}

fun either(p,q,s) {
    fun(s) {
    	   if (do Choose()) {
	     p(s)
	   } else {
	     q(s)
	   }
    }
}

fun seq(x, y, s) {
    fun(s) { y(x(s)) }
}

fun grammar(s) {
   var a = token('a', s);
   var b = token('b', s);
   var apa = seq(a, seq(grammar, a, s), s);
   var bpb = seq(b, seq(grammar, b, s), s);
   var lang = either(apa,
                either(bpb,
                   either(a,
		     either(b, stop, s)
		   , s)
		, s)
	      , s);
   lang(s)	      
}
