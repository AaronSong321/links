# Stateful parser

typename PState = ([Char],[Char]);

handler state(m) {
	case Get(_,k)  -> fun(s) { k(s)(s)  }
	case Put(p,k)  -> fun(s) { k(())(p) }
	case Return(x) -> fun(s) { x }
}

#sig parser : (() ~> ()) -> Maybe(String)
open handler parser(m) {
	case Token(_,k) -> {
	     var s = (do Get()) : PState;
	     var stream = second(s);
	     switch (stream) {
	     	    case (x :: xs) -> { do Put((x :: first(s), xs)); k(x) }
		    case [] -> Nothing
	     }
	}
	case Choose(_,k) -> {
	     var s = (do Get()) : PState;
	     switch (k(true)) {
	     	    case Nothing -> { do Put(s); k(false) }
		    case Just(x) -> Just(x) : Maybe([Char])
	     }
	}
	case Fail(_,_)  -> Nothing
	case Return(x)  -> {
	     var s = (do Get()) : PState;
	     var stream = second(s);
	     switch(stream) {
	        case []    -> Just(reverse(first(s))) : Maybe([Char])
		case other -> Nothing
	     }
	}
}

sig parse : (String) ~> Maybe(String)
fun parse(source) {
    var inp = explode(source);
    var s = ([], inp);
    var r = state(parser(grammar))(s);  
    switch (r) {
       case Just(p) -> Just(implode(p))
       case Nothing -> Nothing
    }
}

fun empty() {
    ()
}

fun token(t) {
    fun() {
        var c = do Token();
	    if (t == c) {
	      empty()
	    } else {
	      do Fail()
	    }
    }
}

fun either(p,q) {
    fun() {
    	   if (do Choose()) {
	     p()
	   } else {
	     q()
	   }
    }
}

fun seq(p, q) {
    fun() { p(); q() }
}

fun grammar() {
   var a    = token('a');
   var b    = token('b');
   var apa  = a `seq` (grammar `seq` a);
   var bpb  = b `seq` (grammar `seq` b);
   var lang = apa `either`
                (bpb `either`
                   (a `either`
		     (b `either` empty)
		   )
		);	      
   lang()	      
}

