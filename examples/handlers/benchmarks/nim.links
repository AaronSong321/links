# Microbenchmark Nim game tree generation (handlers)
fun aliceTurn(n) {
    if (n == 0) {
       Bob      # Bob wins
    } else { 
      var take = do Move((Alice,n)); # Make move
      var n = n - take;              # Update no. sticks
      bobTurn(n)                     # Bob's turn
    }
}

fun bobTurn(n) {
    if (n == 0) {
       Alice
    } else {
      var take = do Move((Bob,n));
      var n = n - take;
      aliceTurn(n)
    }
}

fun play(h, n) {
    h(fun() {
    	    aliceTurn(n)
    })
}

fun validMoves(n) {
    filter(fun(m) { m <= n }, [1,2,3])
}

# make a move a part of the move tree
fun reifyMove(player, n, k) {
    var moves = map(k, validMoves(n));
    Take(player, zip([1..length(moves)], moves))
}

# Complete move tree generator
handler mtGen(m) {
    case Move((player,n),k) -> reifyMove(player,n,k)
    case Return(x) -> Winner(x)
}

fun b(n) {
    var x = play(mtGen, n);
    ()
}

b(20)
