fun enumerate(x) {
    handle(x) {
    	      case Choose(_,k)  -> k(true) ++ k(false)
    	      case Return(x)    -> [x]
    }
}

fun positive(x) {
    handle(x) {
    	      case Choose(_,k) -> k(true)
	      case Return(x)   -> x
    }
}

fun comp() {
    var x = if (do Choose()) { 40 } else { 30 };
    var y = if (do Choose()) {  2 } else {  0 };
    var z = x + y;
    do Return(z)
}

# enumerate(comp) should yield [42, 40, 32, 30]

# General enumeration
fun chooseAll(x) {
    handle(x) {
    	      case Choose((p,q),k) -> k(p) ++ k(q)
	      case Failure(_,_)    -> []
	      case Return(x)       -> [x]
    }
}

#sig drunkToss : forall a, b . () {Choose:(a,a) {}-> a,Failure:(()) {}-> a | p} -> b
#fun drunkToss() {
#    var caught = do Choose(true,false); # Rank-2-polymorphism?
#    if (caught) {
#       do Choose(Heads,Tails)
#    } else {
#      do Failure()
#    }
#}
