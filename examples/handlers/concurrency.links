# Concurrency encoded in Links



#open handler queuer(m)(q) {
#  case Enqueue(e,k) -> k(())(q ++ [e])
#  case Dequeue(k)   -> { var e = hd(q); k(e)(tl(q)) }
#  case Return(x)    -> x
#}

#open handler scheduler(m) {
#  case Fork(t,k) -> { do Enqueue(k); scheduler(fun() { t })() }
#  case Yield(k)  -> { var t = do Dequeue; do Enqueue(k); t(()) }
#  case Return(x) -> x
#}

sig fork_t : (a) {Fork:(a) {}-> b|_}-> b
fun fork_t(t) { do Fork(t) }

sig sched : (Comp({Fork: (() -e-> _) {}-> Process({ |e}) | p}, d)) -> Comp({Fork{_}|p}, d)
open handler sched(m) {
  case Fork(t,k) -> { var pid = spawn { t() }; k(pid) }
  case Return(x) -> x
}

fun comp() {
    fun echoer() {
    	var msg = recv();
	switch (msg) {
	   case "quit" -> print("[Echoer] Goodbye!");
	   case other  -> print("[Echoer] Echoing: " ^^ msg); echoer();
	}
    }
    
    var pid = fork_t(echoer);
    var _   = fork_t(fun() { pid ! "Hello from another thread!"; pid ! "quit"; });
    ()
}

open handler channel(m) {
  case Send(pid,msg,k) -> { pid ! msg; k(()) }
  case Recv(k)         -> { k(recv()) }
  case Return(x)       -> x
}

#(() {Fork:(() {Recv:a,Send:(Process ({ hear:b|_ }), b) {}-> (),hear:a|_}~> _) {}-> Process ({ |_::Any })|g}~> h) -> () {Fork{_}|g}~> h
#sig sched2 : (Comp({Fork: (() {Recv:a,Send:(Process ({ hear:b|_}), b) {}-> hear:a|_}, _) {}-> Process({ |_} |c ~> d) -> Comp({Fork{_}|p}, d)
open handler sched2(m) {
  case Fork(t,k) -> { var pid = spawn { channel(t) }; k(pid) }
  case Return(x) -> x
}

fun comp2() {
    var pid = fork_t(fun() { channel(fun() { print(do Recv); })(); () });
    var _   = fork_t(fun() { channel(fun() { do Send(pid,"Hello from another thread!"); })(); () } );
    ()
}
