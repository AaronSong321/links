## Randomness
# Outputs the next number in the "random" sequence and the next seed.
fun random(seed, lb, ub) {
    var p = 2147483647; # Largest prime less than (2 ^ 32)
    var j = mod(7 * seed, p);
    var r = mod(j - 1, (ub - lb)) + lb;
    (j, r)
}

# The random-effect handler is reminiscent of the state handler
# We encapsulate the "random state" inside a function which is
# passed around during the computation.
var rand = open handler(m) {
    case Rand((lb,ub),k) -> fun(s) {
                              var r = random(s, lb, ub);
			      k(second(r))(first(r))
                            }
		      
    case Return(x) -> fun(s) {
                         x
                      }
};

fun runRand(rcomp) {
    var seed = serverTime();
    rcomp(seed)
}

#fun nextInt(lb,ub) {
#    runRand(rand, fun() { do Rand(lb,ub) })    
#}

fun lookup2(n, xs) {
    switch (xs) {
       case [] -> do Fail()
       case ((i, e) :: xs) -> if (n == i) { e }
                              else { lookup2(n, xs) }
    }
}

fun dodgyLookup(n, xs) {
    if (do Rand(1,10) < 5) {
      do Fail()
    } else {
      lookup2(n,xs)
    }
}

# Coffee dispenser model in Links
fun dispenser1(n) {
    var inv = do Ask();
    do Lookup(n,inv)
}

fun dispenser2(n) {
    var inv  = do Ask();
    var item = lookup2(n, inv);
    do Tell(item)
}

fun dispenser3(n) {
    var inv  = do Ask();
    var item = dodgyLookup(n, inv);
    do Tell(item)
}


handler force(m) {
   case Return(x) -> x
}

var hreader = open handler(m) {
    case Ask(_,k)  -> k([(1,Coffee),(2,Tea)])
    case Return(x) -> x
};

#var hlookup = open handler(m) {
#    case Lookup((n,inv),k) -> lookup2(n, inv, k)
#    case Return(x) -> x
#};

#var hdodgyLookup = open handler(m) {
#    case Lookup((n,inv),k) -> if ((do Rand(1,10)) < 5) {
#                              	do Fail()
#                              } else {
#			      	lookup2(n, inv, k)
#			      }
#    case Return(x)         -> x
#};

var hwriter = open handler(m) {
    case Tell(Coffee,k) -> k("Coffee")
    case Tell(Tea,k)    -> k("Tea")
    case Return(x) -> x
};

open handler maybe(m) {
     case Fail(_,_) -> Nothing
     case Return(x) -> Just(x)
}

fun runDispenser(dispenser, n) {
    force(maybe(hreader(hwriter(fun() { dispenser(n) }))))
}

fun runDispenser2(dispenser, n) {
    runRand(force(rand(maybe(hreader(hwriter(fun() { dispenser(n) }))))))
}
