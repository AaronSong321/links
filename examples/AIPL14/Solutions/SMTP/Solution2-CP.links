# Multiple recipients.

typename Domain = String;
typename Address = String;
typename Accept = String;
typename Message = String;
typename Error = String;
typename Response = String;


#typename SMTPClient = [+| EHLO:!Domain.?Response.
#                mu outer.[+| MAIL:!Address.[&| REJECT:?Error.outer, ACCEPT:
#                  mu rcptLoop.
#                  [+| RCPT:!Address.[&| REJECT:?Error.rcptLoop, ACCEPT:
#                    mu inner.[+| RCPT:!Address.[&| REJECT:?Error.inner, ACCEPT:inner |&],
#                    DATA:!Message.outer |+] |&] |+] |&], QUIT:EndBang |+] |+];


typename SMTPServer = [&| EHLO:?Domain.!Response.
                mu outer.[&| MAIL:?Address.[+| REJECT:!Error.outer, ACCEPT:
                  mu rcptLoop.
                  [&| RCPT:?Address.[+| REJECT:!Error.rcptLoop, ACCEPT:
                    mu inner.[&| RCPT:?Address.[+| REJECT:!Error.inner, ACCEPT:inner |+],     DATA:?Message.outer |&] |+] |&] |+], QUIT:EndBang |&] |&];




sig mailServer : (SMTPServer) ~> EndBang
fun mailServer(s) {
 offer(s) {
     case EHLO(s) ->
             var (domain, s) = receive(s);
             print("S: received domain: " ^^ domain);
             var s = send("C: Session started successfully.", s);
             outer(s)
  }
}

fun outer(s) {
  offer(s) {
    case MAIL(s) ->
            var (address, s) = receive(s);
            print("S: received from: " ^^ address);
            if (valid(address)) {
              var s = select ACCEPT s;
              rcptLoop(s)
            }
            else {
              var s = send("S: Invalid address.", select REJECT s);
              outer(s)
            }

    case QUIT(s) -> s
  }
}

fun rcptLoop(s) {
  offer(s) {
    case RCPT(s) ->
            var (recipient, s) = receive(s);
            print("S: received recipient: " ^^ recipient);
            if (valid(recipient)) {
              var s = select ACCEPT s;
              inner(s)
            }
            else {
              var s = send("S: Invalid recipient.", select REJECT s);
              rcptLoop(s)
            }
  }
}


fun inner(s) {
  offer(s) {
    case RCPT(s) ->
            var (recipient, s) = receive(s);
            print("S: received recipient: " ^^ recipient);
            if (valid(recipient)) {
              var s = select ACCEPT s;
              inner(s)
            }
            else {
              var s = send("S: Invalid recipient.", select REJECT s);
              inner(s)
            }
    case DATA(s) ->
            var (message, s) = receive(s);
            print("S: received message: " ^^ message);
            outer(s)
  }
}


# Returns true, if the given String is a valid e-mail address.
sig valid : (String) ~> Bool
fun valid(address) {
  address =~ /.[a-z0-9]+.@.[a-z]+.[a-z]+/ # Regex to match 1+characters/numbers @ 1+characters . 1+characters
}


sig mailClient : (~SMTPServer, !().EndBang) ~> EndBang
fun mailClient(c, return) {
    <| EHLO c.c["mydomain.com"].c(response).{outerClient(c, return)} |>
}


fun outerClient(c, return) {

    <| MAIL c.c["starlight@domain.com"].{
            <| offer c {
                case REJECT -> c(error).{print(error); <|{outerClient(c, return)} |> }
                case ACCEPT -> {rcptLoopClient(c, return)}
            } |>
      } |>
}

fun innerClient(c, addRcpt, return) {
  # Either one more recipient or data
  if (addRcpt) {
    addRecipient(c, return)
  }
  else {
    addData(c, return)
  }
}

fun addData(c, return) {
        <| DATA c.c["Hello to bravest warriors!"].QUIT c.c().return[()].return[] |>
}

fun addRecipient(c, return) {
      <| RCPT c.c["pink@cloud"].{
            <| offer c {
                case REJECT -> c(error).{print(error); <|{innerClient(c, false, return)} |> }
                case ACCEPT -> {innerClient(c, false, return)}
            } |>
      } |>
}


fun rcptLoopClient(c, return) {
      <| RCPT c.c["friend@galaxy.com"].{
            <| offer c {
                case REJECT -> c(error).{print(error); <|{rcptLoopClient(c, return)} |> }
                case ACCEPT -> {innerClient(c, true, return)}
            } |>
      } |>
}


fun main() {
  run (fun(return){<| nu s.({mailServer(s)}|{mailClient(s, return)}) |>})
}

main()