typename Data = String;
typename Error = String;
typename Username = String;
typename Password = String;
typename User = (name:Username, password:Password);

typename Checker(s::Session) = [+|Accept:s, Reject:!Error.End|+];
typename TwoFactor = ?User.Checker(!Int.?Int.Checker(!Data.End));

# We could use this slightly more general type for reportError:
#
#   typename ErrorReporter(r::Row(Any, Session)) = [+|Reject:!Error.End|r|+];

# The unrolled type of TwoFactor:
#
#   typename TwoFactor = ?User.[+|Accept:!Int.?Int.[+|Accept:!Data.End,
#                                                     Reject:!Error.End|+],
#                                 Reject:!Error.End|+];
# and its dual:
#
#           ~TwoFactor = !User.[&|Accept:?Int.!Int.[&|Accept:?Data.End,
#                                                     Reject:?Error.End|&],
#                                 Reject:?Error.End|&];

sig validUser : (User) ~> Bool
fun validUser(user) {
  switch (user.name) {
    case "me" -> true
    case _    -> false
  }
}

sig validHash : (Int, Int) ~> Bool
fun validHash(h, nonce) {
  h == 2 * nonce
}

sig generateNonce : () ~> Int
fun generateNonce() {
  floatToInt(random() *. 65536.0)
}

sig raiseError : (Error, Checker(s::Session)) ~> ()
fun raiseError(e, s) {
  <| Reject s.s[e].{()} |>
}

sig serve : (TwoFactor, Data) ~> ()
fun serve(s, data) {
  <| s(user).{if (validUser(user)) {
                var nonce = generateNonce();
                <| Accept s.s[nonce].s(h).{if (validHash(h, nonce)) {
                                             <| Accept s.s[data].{()} |>
                                           } else {
                                             raiseError("Invalid hash", s)
                                           }} |>
              } else {
                raiseError("Invalid user name or password", s)
              }} |>
}

sig user1 : (~TwoFactor) ~> Data
fun user1(c) {
  <| c[(name="me", password="foo")].
     offer c {
       case Accept -> c(x).c[2*x].
                      offer c {
                        case Accept -> c(data).{data}
                        case Reject -> c(e).{error(e)}
                      }
       case Reject -> c(e).{error(e)}
     } |>
}

sig user2 : (~TwoFactor) ~> Data
fun user2(c) {
  <| c[(name="you", password="bar")].
     offer c {
       case Accept -> c(x).c[2*x].
                      offer c {
                        case Accept -> c(data).{data}
                        case Reject -> c(e).{error(e)}
                      }
       case Reject -> c(e).{error(e)}
     } |>
}

sig user3 : (~TwoFactor) ~> Data
fun user3(c) {
  <| c[(name="me", password="baz")].
     offer c {
       case Accept -> c(x).c[-1].
                      offer c {
                        case Accept -> c(data).{data}
                        case Reject -> c(e).{error(e)}
                      }
       case Reject -> c(e).{error(e)}
     } |>
}

sig main : () ~> Data
fun main() {
  <| nu x.({serve(x, "secret data")} | {user1(x)}) |>
}

main()
