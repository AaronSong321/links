# Selection and Choice are redundant in Links

typename Calc = [|Add:?Int.?Int.!Int.End | Mul:?Int.?Int.!Int.End|];
typename CalcSelect = !Calc.End;
typename CalcOffer  = ?Calc.End;

sig calc : (CalcOffer) ~> ()
fun calc(s) {
  switch (grab(s).1) {
    case Add(s) ->
      var (x,s) = grab(s);
      var (y,s) = grab(s);
      var _ = give(x+y,s);
      ()
    case Mul(s) ->
      var (x,s) = grab(s);
      var (y,s) = grab(s);
      var _ = give(x*y,s);
      ()
  }
}

sig sel_Add : (CalcSelect) ~> !Int.!Int.?Int.End
fun sel_Add(c) {linfork (linfun (d) {ignore(give(Add(d), c))})}

sig sel_Mul : (CalcSelect) ~> !Int.!Int.?Int.End
fun sel_Mul(c) {linfork (linfun (d) {ignore(give(Mul(d), c))})}

sig user : (CalcSelect) ~> Int
fun user(s) {
  var s = sel_Mul(s);
  grab(give(6,give(7,s))).1
}

fun main() {
  var a = new ();
  var _ = spawn { calc(accept(a)) };
  user(request(a))
}

main()


#sig sel : ((s::Session) ~e~@ c::Any) -> (!c::Any.End) ~e~> ~s::Session
#fun sel(f)(c) {fork (linfun (d) {ignore(give(f(d), c))})}
