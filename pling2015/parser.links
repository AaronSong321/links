# Parser library
typename Void = [||];

# Nodeterminism
sig choose : (a,a) {Choose:(a,a) {}-> a|_}~> a
fun choose(p,q) {do Choose(p,q)}

# Exception
sig fail : Comp({Failure:Void|_}, a)
fun fail() {switch (do Failure) { }}

# State
sig get : Comp({Get:s|_}, s)
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}~> ()
fun put(s) {do Put(s)}

sig getc : Comp({Getc:s|_}, s)
fun getc() {do Getc}

sig any : () -> Comp({Any:a|_}, a)
fun any() {fun() {do Any}}

# Parsers
sig char : (Char) -> Comp({Token:(Char) {}-> Char,Failure:Void|_}, Char)
fun char(c) {fun () {do Token(c)}}

#sig <|> : (Comp({Choose:(a,a) {}-> a|e}, a), Comp({Choose:(a,a) {}-> a|e}, a)) {Choose:(a,a) {}-> a|e}~> a
op p <|> q {fun() { choose(p,q) }}


#sig many : (mu a . Comp({Choose:(a,a) {}-> a |e}, b)) {(mu a . Choose:(a,a) {}-> a)|e}~> Comp({(mu a . Choose:(a,a) {}-> a)|e}, [b])
fun many(p) {
    fun() { [] } <|> fun() { p() :: many(p)()() }
}


sig state : (Comp({Get:s ,Put:(s) {}-> ()|e}, a)) ->
            (s) ->
             Comp({Get{_},Put{_}         |e}, a)
open handler state(m)(s) {
  case Get(k)    -> k(s)(s)
  case Put(p,k)  -> k(())(p)
  case Return(x) -> x
}

sig maybe : (Comp({Failure:Void|e},       a)) ->
             Comp({Failure{_}  |e}, Maybe(a))
open handler maybe(m) {
  case Failure(_) -> Nothing
  case Return(x)  -> Just(x)
}

sig read : (Comp({Failure:Void,Getc:s ,Get:[s],Put:([s]) {}-> ()|e}, a)) ->
	    Comp({Failure:Void,Getc{_},Get:[s],Put:([s]) {}-> ()|e}, a)
open handler read(m) {
  case Return(x) -> x
  case Getc(k)   -> {
    switch (get()) {
      case []        -> fail()
      case (c :: cs) -> put(cs); k(c)
    }
  }
}

sig parse : (mu a . Comp({Any:b ,Token:(b) {}-> b,Choose:(a,a) {}-> c,Failure:Void,Getc:b |e}, c)) ->
                    Comp({Any{_},Token{_}        ,Choose{_}          ,Failure:Void,Getc:b |e}, c)
open handler parse(m) {
  case Return(x)     -> x
  case Any(k)        -> { var c = getc(); k(c) }
  case Token(c,k)    -> {
    if (c == getc()) { k(c) }
    else { fail() }
  }
  case Failure(_)       -> fail()
  case Choose(p,q,k) -> {
      switch(maybe(parse(p))()) {
        case Just(x) -> k(x)
	case Nothing -> {
	   switch (maybe(parse(q))()) {
	      case Just(x) -> k(x)
	      case Nothing -> fail()
	   }
	}
      }
  }
}

#op p <*> q {
#   
#}
