# Parser library
typename Void = [||];

# Nodeterminism
#sig choose : (a,a) {Choose:(a,a) {}-> a|_}~> a
fun choose(p,q) {do Choose(p,q)}

# Exception
sig fail : Comp({Failure:Void|_}, a)
fun fail() {switch (do Failure) { }}

# State
sig get : Comp({Get:s|_}, s)
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}~> ()
fun put(s) {do Put(s)}

sig getc : Comp({Getc:s|_}, s)
fun getc() {do Getc}

sig any : () -> Comp({Any:a|_}, a)
fun any() {fun() {do Any}}

# Parsers
sig char : (Char) -> Comp({Token:(Char) {}-> Char|_}, Char)
fun char(c)() {do Token(c)}

#sig <|> : (Comp({Choose:(a,a) {}-> a|e}, a)
#          ,Comp({Choose:(a,a) {}-> a|e}, a)) ->
#	   Comp({Choose:(a,a) {}-> a|e}, a)
#sig <|> : (a,a) -> Comp({Choose:(a,a) {}-> a|_}, a)
op p <|> q {fun() { choose(p,q) }}


#sig many : (mu a . Comp({Choose:(a,a) {}-> a |e}, b)) {(mu a . Choose:(a,a) {}-> a)|e}~> Comp({(mu a . Choose:(a,a) {}-> a)|e}, [b])
fun many(p)() {
   choose(fun() { p() :: many(p)() }, fun() { [] })
}

fun many1(p)() {
  p() :: many(p)()
}

fun digit() {
  choose(char('1'),
	 choose(char('2'),
	        choose(char('3'),
		       choose(char('4'),
		              choose(char('5'),
			             choose(char('6'),
				            choose(char('7'),
					           choose(char('8'), char('9')))))))))
				     
}

fun foo() {
  var s = char('a')();
  Str(s)
}


sig state : (Comp({Get:s ,Put:(s) {}-> ()|e}, a)) ->
            (s) ->
             Comp({Get{_},Put{_}         |e}, a)
open handler state(m)(s) {
  case Get(k)    -> k(s)(s)
  case Put(p,k)  -> k(())(p)
  case Return(x) -> x
}

sig maybe : (Comp({Failure:Void|e},       a)) ->
             Comp({Failure{_}  |e}, Maybe(a))
open handler maybe(m) {
  case Failure(_) -> Nothing
  case Return(x)  -> Just(x)
}

sig read : (Comp({Failure:Void,Getc:s ,Get:[s],Put:([s]) {}-> ()|e}, a)) ->
	    Comp({Failure:Void,Getc{_},Get:[s],Put:([s]) {}-> ()|e}, a)
open handler read(m) {
  case Return(x) -> x
  case Getc(k)   -> {
    switch (get()) {
      case []        -> fail()
      case (c :: cs) -> put(cs); k(c)
    }
  }
}

sig parse : (mu a . Comp({Any:b ,Token:(b) {}-> b,Choose:(a,a) {}-> c,Failure:Void,Getc:b,Get:[b],Put:([b]) {}-> () |e}, c)) ->
                    Comp({Any{_},Token{_}        ,Choose{_}          ,Failure:Void,Getc:b,Get:[b],Put:([b]) {}-> () |e}, c)
open handler parse(m) {
  case Return(x)     -> x
  case Any(k)        -> { var c = getc(); k(c) }
  case Token(c,k)    -> {
    if (c == getc()) { k(c) }
    else { fail() }
  }
  case Choose(p,q,k) -> {
      var s = get();
      switch(maybe(parse(p))()) {
        case Just(x) -> k(x)
	case Nothing -> {
	   put(s);
	   switch (maybe(parse(q))()) {
	      case Just(x) -> k(x)
	      case Nothing -> fail()
	   }
	}
      }
  }
}

sig force : (Comp({}, a)) ~> a
handler force(m) {
  case Return(x) -> x
}

sig runParser : (mu p . Comp({Any:a,Choose:(p,p) {}-> b,Failure:Void,Get:[a],Getc:a,Put:([a]) {}-> (),Token:(a) {}-> a}, b)) -> ([a]) ~> Maybe(b)
fun runParser(p)(s) {
  force(state(maybe(read(parse(p))))(s))
}

#op p <*> q {
#   
#}
