# empty type
typename Void = [||];

# abstract computation over effect row e with return values of type a
typename Comp(e::Row, a) = () ~e~> a;

# helper functions for invoking Choice and Failure operations
sig choice : Comp({Choice:Bool|_}, Bool)
fun choice() {do Choice}

sig choose : (a, a) {Choose:Bool|_}~> a
fun choose(x,y) {if (do Choose) {x} else {y}}

sig fail : Comp({Failure:Void|_}, a)
fun fail() {switch (do Failure) { }}

typename Toss = [|Heads|Tails|];

sig toss : Comp({Choose:Bool|_}, Toss)
fun toss() { choose(Heads,Tails) }

sig positive : (Comp({Choose:Bool},a)) {}~> a
handler positive(m) {
  case Choose(k) -> k(true)
  case Return(x) -> x
}

sig allResults : (Comp({Choose:Bool},a)) {}~> [a]
handler allResults(m) {
	case Choose(k) -> k(true) ++ k(false)
	case Return(x) -> [x]
}

sig maybeResult : (Comp({Failure:Void|e},a)) -> Comp({Failure{_}|e},Maybe(a))
open handler maybeResult(m) {
     case Failure(_) -> Nothing
     case Return(x)  -> Just(x)
}

sig drunkToss : Comp({Choose:Bool,Failure:Void|_},Toss)
fun drunkToss() {
    if (choose(true,false)) { toss() }
    else { fail() }
}

sig rand : Comp({Rand:Float|_},Float)
fun rand() {do Rand}

sig randomResult : (Comp({Choose:Bool,Rand:Float|e},a)) ->
                    Comp({Choose{_},  Rand:Float|e},a)
open handler randomResult(m) {
     case Choose(k) -> k(rand() < 0.5)
     case Return(x) -> x
}

sig handleRandom : (Comp({Rand:Float|e},a)) ->
                    Comp({Rand{_}|e},a)
open handler handleRandom(m) {
  case Rand(k)   -> k(random())
  case Return(x) -> x
}

sig persevere : (Comp({Failure:Void|e},a)) ->
                 Comp({Failure{_}  |e},a)
open handler persevere(m) {
  case Failure(_) -> persevere(m)()
  case Return(x)  -> x
}
