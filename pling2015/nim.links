#
# Mathematical game Nim
#
# Rules:
#  - Two players: Alice and Bob; Alice always starts.
#  - One heap of N sticks
#  - A player may pick between 1-3 sticks at each turn
#  - The player, who takes the last stick, wins.
#

# Datatype modelling the players
typename Player = [|Alice|Bob|];

# String of player
sig showPlayer : (Player) -> String
fun showPlayer(player) {
  switch (player) {
    case Alice -> "Alice"
    case Bob   -> "Bob"
  }
}

# Abstract operation "Move"
sig move : (Player,Int) {Move:(Player,Int) {}-> Int|_}~> Int
fun move(player,n) {do Move(player,n)}

# We model the game as two mutual recursive functions
sig aliceTurn : (Int) {Move:(Player,Int) {}-> Int|_}~> Player
fun aliceTurn(n) {
  if (n == 0) {Bob} # Bob wins
  else {bobTurn( n - move(Alice,n) )}
}

sig bobTurn : (Int) {Move:(Player,Int) {}-> Int|_}~> Player
fun bobTurn(n) {
  if (n == 0) {Alice} # Alice wins
  else {aliceTurn( n - move(Bob,n) )}
}

# A game is parameterised by the number of starting sticks,
# moreover it enforces the rule that Alice always starts
sig game : (Int) -> Comp({Move:(Player,Int) {}-> Int|_},Player)
fun game(n)() {aliceTurn(n)}

#
# Encoding players' strategies as handlers
#

# An interpretation of Move corresponds to assigning a particular
# strategy to a given player

# Type alias for strategy handlers
typename StrategyHandler = forall a :: Type, p :: Presence . (Comp({Move:(Player,Int) {}-> Int},a)) {Move{p}}~> a;

#typename Strategy(e :: Row) = (Player,Int,(Int) ~e~> Player) ~e~> Player;
typename Strategy = forall a :: Type, p :: Presence, e :: Row . (Player,Int,(Int) {Move{p}|e}~> a) {Move{p}|e}~> a;

# A first strategy: Always pick one stick
#sig ns : (Player,Int,(Int) ~e~> Player) ~e~> Player
sig ns : Strategy
fun ns(player,n,k) { k(1) }

#sig strategy : ((Player,Int,(Int) ~e~> Player) ~e~> Player, (Player,Int,(Int) ~e~> Player) ~e~> Player) -> (() ~e~> Player) ~e~> Player
#fun strategy(s1,s2) {
#    handler(m) {
#    	  case Move(Alice,n,k) -> s1(Alice,n,k)
#	  case Move(Bob,n,k)   -> s2(Bob,n,k)
#	  case Return(x)       -> x
#    }
#}

# The naive-strategy-handler assigns the naive-strategy to both players
sig naive : StrategyHandler
handler naive(m) {
  case Move(p,n,k) -> ns(p,n,k)
  case Return(x)   -> x
}

sig max2 : (a,a) -> a
fun max2(x,y) {
  if (x > y) {x}
  else {y}
}

# The perfect strategy is to pick "max(n `mod` 4, 1)" sticks
#sig ps : (Player,Int,(Int) ~e~> Player) ~e~> Player
#sig ps : Strategy({Move:(Player,Int) {}-> Int|_})
sig ps : Strategy
fun ps(p,n,k) {
    k(max2(n `mod` 4, 1))
}

# The perfect handler assigns the perfect strategy to both players
sig perfect : StrategyHandler
handler perfect(m) {
    case Move(p,n,k) -> ps(p,n,k)
    case Return(x)   -> x
}

# Observation: Alice wins whenever the starting number of sticks are not divisible by 4
# under the interpretation of perfect.

# Auxiliary function. Given the number of sticks n it returns a list of valid moves.
sig validMoves : (Int) -> [Int]
fun validMoves(n) {
    filter(fun(m) { m <= n }, [1,2,3])
}

# The brute force strategy enumerates all future plays
# if any particular play leads to a win, then play that strategy
sig bfs : Strategy
fun bfs(player,n,k) {
  # Map the continuation over all possible moves
  # this effectively determines all potential winners
  var winners = map(k, validMoves(n));
  # Ask whether 'player' is among the potential winners
  var hasPlayerWon = elemIndex(player, winners);
  switch (hasPlayerWon) {
    case Nothing -> k(1)   # Not winning.
    case Just(i) -> k(i+1) # Among winners; play the winning-strategy.
  }
}

# The perfect vs brute force handler assigns 
# Alice the perfect strategy and Bob the brute force strategy
sig pvb : StrategyHandler
handler pvb(m) {
  case Move(Alice,n,k) -> ps(Alice,n,k)
  case Move(Bob,n,k)   -> bfs(Bob,n,k)
  case Return(x)       -> x
}

#
# Computing game data
#
# Instead of simply evaluating the winner according to some strategy,
# we can also compute other data. For instance, we can compute a tree
# representing the possible moves of each player.

# Game tree data type
typename GameTree =
  [| Take   : (Player, [(Int, GameTree)])
   | Winner : Player
   |];

# Reify a move as part of the move tree
sig reifyMove : (Player, Int, (Int) ~e~> GameTree) ~e~> GameTree
fun reifyMove(player, n, k) {
  var moves = map(k, validMoves(n));
  var subgames = zip([1..length(moves)], moves);
  Take(player, subgames)
}

# Complete game tree generator
# The Return-case lifts the result of the computation, m, into a leaf in the game tree
sig gametree : (Comp({Move:(Player, Int) {}-> Int}, Player)) {Move{_}}~> GameTree
handler gametree(m) {
  case Return(x)          -> Winner(x)
  case Move(player, n, k) -> reifyMove(player, n, k)
}

# links> gametree(game(3))
#  Take((Alice, [(1, Take((Bob, [(1, Take((Alice, [(1, Winner(Alice))]))),
#                                (2, Winner(Bob))]))),
#                  (2, Take((Bob, [(1, Winner(Bob))]))),
#                  (3, Winner(Alice))]))

#
# Generate a game tree in which Bob plays the perfect strategy
#
sig forwardBob : (Comp({Move:(Player, Int) {}-> Int|e}, Player)) -> Comp({Move:(Player,Int) {}-> Int|e},GameTree)
open handler forwardBob(m) {
     case Return(x) -> Winner(x)
     case Move(Bob, n, k)    -> {
     	  var take = move(Bob,n); # Explicit forwarding of move
     	  var tree = k(take);
	  Take(Bob, [(take, tree)])
     }
     case Move(player, n, k) -> reifyMove(player, n, k)
}

# Handler composition operator
# Data flows from right to left (or inside-out)
sig -<- : ((a) -e-> b, (c) -e-> a) -> (c) -e-> b
op g -<- f {fun (x) {g(f(x))}}

# Combine a sequence of handlers with a computation m
sig -< : ((a) -e-> b, a) -e-> b
op f -< m  {f(m)}

# Alternative pipeline operator; data flows from left-to-right
# Maybe more natural?
op m >> f {f(m)}

# We can reuse our closed handler perfect to interpret the forwarded move-operation.
# Note, the handler composition order matters here, because perfect is defined for Alice,
# we wish only to play the perfect strategy for Bob, therefore perfect must be on top of
# the handler stack.
# links> (perfect -<- forwardBob) -< game(3)
#  Take((Alice, [(1, Take((Bob, [(2, Winner(Bob))]))),
#                (2, Take((Bob, [(1, Winner(Bob))]))),
#                (3, Winner(Alice))]))

#
# Returning to strategies
#

# Using open handlers we can give an interpretation of randomness
# thus we can encode mixed strategies.

sig rand : () {Rand:a|_}~> a
fun rand() {do Rand}

sig ms : (Player,Int, (Int) {Rand:Float|e}~> a) {Rand:Float|e}~> a
fun ms(p,n,k) {
  var r = floatToInt(rand() *. 1000.0);
  var take = (r `mod` 3) + 1; # Make sure take is in {1,2,3}
  if (take <= n) {k(take)}    # Make sure it is a legal move...
  else {k(1)}                 # ... otherwise just pick one (might be suboptimal)
}

# mixed strategy handler assigns a random strategy to both players
sig mixed : (Comp({Move:(Player,Int) {}-> Int,Rand:Float|e}, a)) -> Comp({Move{_},Rand:Float|e}, a)
open handler mixed(m) {
  case Move(p,n,k) -> ms(p,n,k)
  case Return(x)   -> x
}

# randomFloat handler uses Links' builtin random number generator
sig randomFloat : (Comp({Rand:Float|e}, a)) ->
                   Comp({Rand{_}|e}, a)
open handler randomFloat(m) {
  case Return(x) -> x
  case Rand(k)   -> k(random())
}

# notReallyRandom is entirely deterministic; it always returns 3.0
sig notReallyRandom : (Comp({Rand:Float|e}, a)) ->
                       Comp({Rand{_}|e}, a)
open handler notReallyRandom(m) {
  case Return(x) -> x
  case Rand(k)   -> k(3.0)
}

#
# Power of Composition
#

#
# Extending the game with a cheat detection mechanism
#

# Abstract operation cheat
# Invoked when a player cheats.
sig cheat : (Player,Int) {Cheat:(Player,Int) {}-> Zero|_}~> a
fun cheat(player, n) {switch(do Cheat(player,n)) { } }

# Cheater's strategy is to take all sticks and thereby win in one move
sig cheater : Strategy
fun cheater(p,n,k) {k(n)}

# checkMove checks whether a given player p has cheated
sig checkMove : Strategy
fun checkMove(p,n,k) {
  var take = move(p,n);
  if (take < 1 || 3 < take) { # Cheater detected!
     cheat(p, n)
  } else {
     k(take)                  # Otherwise OK
  }
}

# The check handler detects cheating
sig check : (Comp({Move:(Player,Int) {}-> Int, Cheat:(Player,Int) {}-> Zero|e}, a)) ->
             Comp({Move:(Player,Int) {}-> Int, Cheat:(Player,Int) {}-> Zero|e}, a)
open handler check(m) {
  case Return(x)          -> x
  case Move(player, n, k) -> checkMove(player, n, k)
}

# Checked game
sig checkedGame : (Int) -> Comp ({Move:(Player, Int) {}-> Int, Cheat:(Player, Int) {}-> Zero|e}, Player)
fun checkedGame(n) { check(game(n)) }

# aliceCheats assigns Alice the cheater's strategy
sig aliceCheats : (Comp({Move:(Player,Int) {}-> Int|e}, a)) ->
                   Comp({Move:(Player,Int) {}-> Int|e}, a)
open handler aliceCheats(m) {
  case Move(Alice,n,k) -> cheater(Alice,n,k)
  case Move(Bob,n,k)   -> k(move(Bob,n))     # Explicit forwarding is required if we insist on using type signatures
  case Return(x)       -> x
}

# links> perfect -<- aliceCheats -< game(36)
#  Alice

# Interpreting cheating
# Abandon the game and report the cheater
sig cheatReport : (Comp({Cheat:(Player,Int) {}-> Zero|e}, a)) ->
                   Comp({Cheat{_}|e}, a)
open handler cheatReport(m) {
  case Cheat(p,n,_) -> error("Cheater " ^^ showPlayer(p) ^^ " took " ^^ intToString(n) ^^ " sticks!")
  case Return(x)   -> x
}

# Alternatively, upon cheating the opponent is given the victory
sig cheatLose : (Comp({Cheat:(Player,Int) {}-> Zero|e}, Player)) ->
                 Comp({Cheat{_}|e}, Player)
open handler cheatLose(m) {
  case Cheat(Alice,_,_) -> Bob
  case Cheat(Bob,_,_)   -> Alice
  case Return(x)        -> x
}

# Alice cheats against Bob's perfect strategy
#
# (If n < 4 then Alice wins, otherwise the game is abandoned because
# Alices cheats.)
sig cpReport : (Int) {Move{_}}~> Player
fun cpReport(n) {
    perfect(cheatReport(aliceCheats(checkedGame(n))))
}

# Alice cheats against Bob's perfect strategy
# 
# (If n < 4 then Alice wins, otherwise Bob wins because Alice
# cheats.)
sig cpLose : (Int) {Move{_}}~> Player
fun cpLose(n) {
  perfect(aliceCheats(cheatLose(checkedGame(n))))
}


#
# A stateful game
#

typename GameState = [(Player,Int)];
var initialState = [(Alice,0),(Bob,0)] : GameState;

sig get : (Comp({Get:s|_}, s))
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}~> ()
fun put(s) {do Put(s)}

sig state : (Comp({Get:s,Put:(s) {}-> ()|e}, a)) ->
    	    (s) ->
	    Comp({Get{_},Put{_}|e}, a)
open handler state(m)(s) {
     case Get(k)    -> k(s)(s)
     case Put(p,k)  -> k(())(p)
     case Return(x) -> x
}

sig updateScore : (Player, GameState) {Put:(GameState) {}-> ()|_}~> ()
fun updateScore(p,s) {
  put(map(fun(e) {
    if (p == first(e)) {
       (p, second(e)+1)
    } else { e }
  }, s))
}

sig track : (Comp({Get:GameState,Put:(GameState) {}-> ()|e}, Player)) ->
             Comp({Get:GameState,Put:(GameState) {}-> ()|e}, Player)
open handler track(m) {
     case Return(x) -> {
     	  updateScore(x, get());
	  x
     }
}

sig makeWhitespace : (Int) ~> String
fun makeWhitespace(n) {
    implode(replicate(n, ' '))
}

sig printBoard : (GameState) ~> ()
fun printBoard(s) {
    var xs = map(fun(p) {
    	var player = showPlayer(first(p));
	var wins   = intToString(second(p));
	var ws_c1 = 12 - strlen(player);
	var ws_c2 = 10 - strlen(wins);
	"| " ^^ player ^^ makeWhitespace(11 - strlen(player)) ^^ "|" ^^ makeWhitespace(8 - strlen(wins)) ^^ wins ^^ " |"
    }, s);

    print("/======================\\");
    print("|     NIM HIGHSCORE    |");
    print("|======================|");
    print("|   Player   |  #Wins  |");
    print("|============|=========|");
    print(hd(xs));
    print("|============|=========|");
    print(hd(tl(xs)));
    print("\\======================/");
}

sig boardPrinter : (Comp({Get:GameState|e}, a)) ->
                    Comp({Get:GameState|e}, ())
open handler boardPrinter(m) {
     case Return(x) -> printBoard(get())
}


# Strategy handler factory
sig strategy : (Strategy, Strategy) ->
               (Comp({Move:(Player,Int) {}-> Int |e}, a)) ->
	        Comp({Move{_} | e}, a)
fun strategy(s1, s2) {
    open handler(m) {
    	 case Move(Alice,n,k) -> s1(Alice,n,k)
	 case Move(Bob,n,k)   -> s2(Bob,n,k)
	 case Return(x)       -> x
    }
}

fun repeatGame(r, m)() {
    for (_ <- [1..r]) {
    	[m()]
    }
}

# (state -<- boardPrinter -<- randomFloat -< strategy(ms,ms)(repeatGame(10, track -< game(33))))(initialState)();
