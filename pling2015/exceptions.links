# 
# Exception handlers
#

# Abstract Fail operation
sig fail : Comp({Fail:a|_}, a)
fun fail() {do Fail}

# Try handler interprets computations that might fail (throw exceptions)
sig try : (Comp({Fail:_},a)) ~> a
handler try(m) {
	case Fail(_)   -> error("An error occurred")
	case Return(x) -> x
}

# Throw a descriptive exception
sig throw : (String) {Exception:(String) {}-> a|_}~> a
fun throw(msg) {do Exception(msg)}

# Try-catch handler interprets computations that might fail
sig tryCatch : (Comp({Exception:(String) {}-> a},a)) ~> a
handler tryCatch(m) {
	case Exception(msg,_) -> error(msg)
	case Return(x)        -> x
}


# Out of bounds
sig get : (Int, [a]) {Exception:(String) {}-> a}~> a
fun get(i, xs) {
    if (i >= 0 && i < length(xs)) {
       xs !! i
    } else {throw("Out of bounds!")}
}

# The functional approach to exception handling
# 
typename Maybe(a) = [|Just:a|Nothing|];

# Maybe handler
sig maybe : (Comp({Fail:_},a)) ~> Maybe(a)
handler maybe(m) {
	case Fail(_)   -> Nothing
	case Return(x) -> Just(x)
}
