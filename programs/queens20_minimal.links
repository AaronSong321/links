sig choose : ([a]) {Choose:([a]) {}-> a |_}-> a
fun choose(xs) { do Choose(xs) }

fun for_all(p, xs) {
  switch (xs) {
    case [] -> true
    case x :: xs -> if (p(x)) for_all(p, xs) else false
  }
}

sig showPair : forall a, b . ((a) -e-> String, (b) -e-> String) -> ((a,b)) -e-> String
fun showPair(showX,showY)(p) {
    var x = p.1; var y = p.2;
    "(" ^^ showX(x) ^^ ", " ^^ showY(y) ^^ ")"
}

fun noAttack(p1)(p2) {
  var a = p1.1; var b = p1.2;
  var c = p2.1; var d = p2.2;
  a <> c && b <> d && abs(a - c) <> abs(b - d)
}

fun available(a, qs, l) {
  filter(fun(b) { for_all(noAttack((a,b)), qs) }
        , l)
}

fun chooseHandler(m) {
    handle(m) {
      case Return(x) -> Just(x)
      case Choose(xs,k) -> {
           fun loop(xs) {
              switch(xs) {
                case []      -> Nothing
                case x :: xs ->
                  switch (k(x)) {
                    case Nothing -> loop(xs)
                    case Just(x) -> Just(x)
                  }
              }
           }
           loop(xs)
      }
    }
}

fun findSolution(n)() {
    var l = intRange(1,n);

    fun place(x, qs) {
        if (x == n+1) qs
        else {
          var y = choose(available(x, qs, l));
          place(x+1, (x,y) :: qs)
        }
    }

    place(1, [])
}


fun main() {
  var n = 20;  
  var showSolution = showMaybe(showList(showPair(intToString,intToString)));
  var solution = showSolution(chooseHandler(findSolution(n)));
  print(solution)
}

main()
