# Mandelbrot
# let mandelbrot xMin xMax yMin yMax xPixels yPixels maxIter =
#   let rec mandelbrotIterator z c n =
#     if (Complex.norm z) > 2.0 then false else
#       match n with
#       | 0 -> true
#       | n -> let z' = Complex.add (Complex.mul z z) c in
#              mandelbrotIterator z' c (n-1) in
#   Graphics.open_graph
#     (" "^(string_of_int xPixels)^"x"^(string_of_int yPixels));
#   let dx = (xMax -. xMin) /. (float_of_int xPixels) 
#   and dy = (yMax -. yMin) /. (float_of_int yPixels) in
#   for xi = 0 to xPixels - 1 do
#     for yi = 0 to yPixels - 1 do
#       let c = {Complex.re = xMin +. (dx *. float_of_int xi);
#                Complex.im = yMin +. (dy *. float_of_int yi)} in
#       if (mandelbrotIterator Complex.zero c maxIter) then
#         (Graphics.set_color Graphics.white;
#          Graphics.plot xi yi )
#       else
#         (Graphics.set_color Graphics.black;
#          Graphics.plot xi yi )
#     done
#   done;;
 
# mandelbrot (-1.5) 0.5 (-1.0) 1.0 500 500 200;;

typename Complex = (re:Float,im:Float);

sig complex : (Float,Float) -> Complex
fun complex(a,b) { (re=a,im=b) }

sig :+. : (Complex, Complex) -> Complex
op (re=a,im=b) :+. (re=c,im=d) {  complex(a +. c, b +. d) }

sig :*. : (Complex, Complex) -> Complex
op (re=a,im=b) :*. (re=c,im=d) {
  var ac = a *. c;
  var bd = b *. d;
  complex(ac -. bd, (a +. b) *. (c +. d) -. ac -. bd)
}

sig norm : (Complex) -> Float
fun norm((re=a,im=b)) {
    sqrt((a ^. 2.0) +. (b ^. 2.0))
}

var width = 75;
var height = 25;
var xMin = negatef(1.5);
var xMax = 0.5;
var yMin = negatef(1.0);
var yMax = 1.0;
var cunit = complex(0.0, 0.0);

# fun mandelIter(c, jmax, bailout) {
#   fun mandelIter_aux(z, j) {
#      if (j > jmax || floatToInt(norm(z)) > bailout) j
#      else mandelIter_aux((z :*. z) :+. c, j+1)
#   }
#   mandelIter_aux(cunit, 0)
# }

# fun foreach(f, i, imax) {
#     if (i < imax) {
#        var _ = f(i);
#        foreach(f, i+1, imax)
#     } else ()
# }

# fun mandelbrot() {
#     var cx = (xMax -. xMin) /. intToFloat(width);
#     var cy = (yMax -. yMin) /. intToFloat(height);
#     for (y <- intRange(0, height)) {
#        [for (x <- intRange(0, width)) {
#           var z = complex(xMin +. intToFloat(x) *. cx, yMin +. intToFloat(y) +. cy);
#           var iter = mandelIter(z, 1000, 4);
#           [if (iter > 1000) '*' else 'o']
#        }]
#     }
# }

var max_iterations = 200;
var bailout = 16.0;

fun mandelbrot(x, y) {
  var cr = y -. 0.5;
  var ci = x;
  var zi = 0.0;
  var zr = 0.0;
  var i = 0;
  fun loop(zr, zi, i) {
      var i = i + 1;
      var temp = zr *. zi;
      var zr2 = zr *. zr;
      var zi2 = zi *. zi;
      var zr = zr2 -. zi2 +. cr;
      var zi = temp +. temp +. ci;
      if (zi2 +. zr2 > bailout)  i
      else if (i > max_iterations) 0
      else loop(zr, zi, i)
  }
  loop(zr, zi, i)
}

fun range(f, to) {
  if (f >= to) []
  else f :: range(f+1, to)
}

fun iterate() {
  for (y <- range(-39, 39)) {
#    ignore(
    var x = (for (x <- range(-39,39)) {
                if (mandelbrot(intToFloat(x)/.40.0, intToFloat(y)/.40.0) == 0) ['#']
                else ['.']
             });
     [x]
#    }); []
  }
}



fun transpose(xss) {
  switch(xss) {
     case []                 -> []
     case [] :: xss          -> transpose(xss)
     case (x :: xs) :: xss   -> (x :: map(hd, xss)) :: transpose (xs :: map(tl, xss))
  }
}

# implode(concatMap(fun(x) { ['\n'] ++ x }, transpose(iterate())))
