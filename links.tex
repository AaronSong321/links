\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[colorlinks=true]{hyperref}
\usepackage{mathrsfs}
\usepackage{geometry}
%\usepackage{fullpage}
\usepackage{listings}
\usepackage{xcolor,graphicx}
\usepackage{xspace}
\usepackage{verbatim}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{syntax}
\usepackage{amssymb}

\title{Compiling queries in \links}
\author{Gabriel \textsc{Radanne}}
\date{\today}

\newcommand\mysc[1]{{\rmfamily\textsc{#1}}\xspace}
\newcommand\links{\mysc{Links}}
\newcommand\sql{\mysc{SQL}}
\newcommand\js{\mysc{Javascript}}
\newcommand\ocaml{\mysc{Ocaml}}

\newcommand\refsec[1]{\hyperref[#1]{section \ref*{#1}}}

\lstset{
  tabsize=4,
  basicstyle=\scriptsize,
  % upquote=true,
  aboveskip={0.5\baselineskip},
  columns=fixed,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  identifierstyle=\ttfamily,
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\newcommand\sig[1]{{\tt\bf #1}}
\newcommand\code[1]{{\tt #1}}
\newcommand\linkslst[1]{{\tt #1}}
\newcommand\effect[1]{{\em #1}}

\newcommand\ocamlc[1]{\lstinline[language=ML]{#1}}

\newcommand\module[1]{{\bf #1}}

%comment inside bnf
\renewcommand\comment[1]{{\color{gray} $//$ #1}}

\begin{document}

\begin{titlepage}
  \maketitle
  \thispagestyle{empty} % remove page number
  
\end{titlepage}



\section{A quick introduction to Links}

\subsection{What is Links ?}
In a nutshell, Links is a web functional programming language. We can define Links by two goals.

\links aim to avoid code separation between the client, the server and the database. In usual web programming, you keep those three component separated : for example, the client is written in \js, the client in \mysc{PHP} and queries are in \sql. 
These separation lead to what's called {\it the independence mismatch} problem : How to be sure than the type of data get by the \sql query fit what the server expect ? 

One of the first \links' related article \cite{links:tiers} was called ``web programming without tiers'' : In \links, there is only one language for the client, the server and the queries. 
The strong type system ensure that data traveling between those three parts will properly work together. 
The language itself will decide if the function should be on the server or the client side, ensuring data availability.

In \links, the client part is compiled in \js and the server part is evaluated.
\\

Another goal of \links is to use the functional paradigm and a strong type system to ease web programming with usefull abstractions. \cite{links:formlets} and \cite{links:effect} introduce new concepts to manipulate form components and queries in a strongly typed way.\\

During a previous project \cite{links:comp}, a compiler for the server part as been done, but this compiler is incomplete since it don't handle queries. The goal of this internship is to allow queries in \links to be compiled.\\

The next section will present the query system of \links in more details.

\subsection{The Query system\label{intro:query}}

Queries in \links are integrated as an element of the language. As opposed to most server-side languages, you don't write sql strings : you just write usual code and it will be translated into an \sql query at runtime.
For example, here is a simple query: \linkslst{simplequery.links}
You can also make a function which take a predicate and construct a query with it, like in the following example : \linkslst{query_predicat.links}

In usual \sql, the output of a query is a table, that is a list of rows where each row is made of named fields : the columns. Each field can only be a simple type like string, float, integer or boolean.\\
The natural translation in \links' typesystem is a list of records.\\

This tight integration between queries and the programming language has two consequences :
\begin{itemize}
\item The language must ensure than every functions that appear inside a query can actually be translated. For example you can't translate recursive functions to \sql.
\item Each function can have up to two meanings : a \effect{query} meaning and a \effect{language} meaning.
\end{itemize}

Effects, as described in \cite{links:effect}, allow \links' type system to handle those specificity nicely.\\

Effects can be described as a way to characterize what a function is doing during its computation. 

For exemple, let's loot at the \code{print(s)} function. Its type is \sig{(String) -\{wild\}-> ()}. \sig{wild} is an effect which indicate that this function cannot be run in a query. This make sens since \sql don't have any printing function.

Let's now look at the \code{curry(f)} function with the type \sig{((a, b) -c-> d) -> ((a) -> (b) -c-> d)}. If the function \code{f} passed to \code{curry} have an effect \sig{c}, the application of the curryfied will also get this effect.\\

This will allow us to know if a function can be used inside a query or not.

\section{\links' insides}

\links' compiler and evaluator are implemented in \ocaml. 
The code can be separate into two parts. 
The front-end takes care of various static analysis including type inference and removing any syntactic sugar. 
At the end of this first stage, the code is in an internal representation defined in the \module{Ir} module and which will be presented in \refsec{ir}. 

Then, the backend will transform this internal representation into different forms.\\
The client side code will be extracted from it and compile to \js by the \module{Irtojs} module.\\
The server side will be evaluated by the \module{Evalir} module or compiled to \ocaml by the \module{Irtoml} module that will be presented \refsec{irtoml}.\\
In case the server side is evaluated, the \module{Query} module handle the query normalization that will be explained \refsec{querynorm}.

\subsection{The internal representation \label{ir}}

The internal representation of \links is in ANF\footnote{A normal form}. This a representation of a program where every argument is trivial and don't need any computation to be evaluated. 

For exemple this program :
\begin{lstlisting}[language=ML]
f(g(x),h(y))
\end{lstlisting}
Can be converted in ANF :
\begin{lstlisting}[language=ML]
let x'=g(x) in
let y'=h(y) in
f(x',y')
\end{lstlisting}

ANF is a very simple representation that transform usually complex transformations to very simple ones. It is also isomorphic to CPS\footnote{Continuation Passing Style} (see \hyperref[cps]{the annex} for details).\\

Here is a simplified representation of the internal representation :

\begin{grammar}
<computation> ::= <binding>* <tail_computation>

<binding> ::= \
\alt "let" <binder> "=" <tail_computation>
\alt "fun" <binder> "(" <binder>* ")" "=" <computation>
\alt "rec" (<binder> "(" <binder>* ")" "=" <computation>)* \comment{mutually recursive functions}

<tail_computation> ::= \ 
\alt "return" <value>
\alt <value>"(" <value>* ")" \comment{function application}
\alt "match" <value> "with" \ 
  ("case" <binder> "->" <computation>)+ \ 
  ("case" "default" "->" <computation>)?
\alt "if" <value> "then" <computation> "else" <computation>
\alt <special>

<special> ::= <database> | <table>
\alt "query" <computation>

<value> ::= <constant> | <variable>
\alt "{" (<string> "=" <value>)* ("with" <value>)? "}" \comment{record extension}
\alt <value>"."<string> \comment{record projection}
\alt "erase" <value>"."<string> \comment{record suppression}
\alt <string> <value> \comment{Constructor for sum datatype}
\end{grammar}


A program is of the type \sig{computation} with is formed by a list of \sig{binding} followed by a \sig{tail\_computation}.\\
Each binding contains a left-hand side with variable name and a right-and side with the possible arguments and the value of the variable. \\
The type \sig{value} contains usual values like constant and variable, but also record and algebraic type construction.\\
A \sig{binder} contains information about a variable like it name, it unique Id, the location in the source file and so on.\\
Finally \sig{special} mostly contains query related values like database, tables and queries.\\

At this point, the type inference is done, so the type of every variable can be easily reconstruct. Every variable also get a unique name. In combination with the ANF, it makes the control flow of the whole program completely explicit.\\

It's also inside the \module{Ir} module that's some classic program transformation are defined, such as dead variables elimination or inlining.

\subsection{Query normalization \label{querynorm}}

As explained in the introduction, query are composed with functions and values of the language. This mean we need a way to translate it into actual sql. This is done in the \module{Query} module in two steps.

During the first step, we transform the internal representation of the query into another representation. Then we transform this query representation into an \sql subset ready to be printed as an \sql string.

Here is a simple form of the query representation :

\begin{grammar}
<query> ::= "for" (<ident> "<-\--" <table>)+ ("where" <body>)* "return" <tail>

<body> ::= \ 
\alt <constant> | <variable>
\alt "if" <base> "then" <base> "else" <base>
\alt "{" (<string>"="<body>)* "}" \comment{record declaration}
\alt <body>"."<string> \comment{record projection}
\alt <string>"(" <body>* ")" \comment{function application}

<tail> ::= "[" <body> "]"
\end{grammar}

During the first step, the expression is simplified, mostly by $\beta$-reduction. Only primitives functions present in \sql ( like ``and'' for exemple) are left. Then for comprehension and where clauses are gather to be put together as specified in the \synt{query} rule.

The details of the query normalisation procedure are a bit too complex to be explained in details here but they are avaible in \cite{links:querycomp}.

\subsection{The Irtoml module and the runtime library \label{irtoml}}

A previous internship \cite{links:comp} has been done by Steven Holmes several years ago on compiling the server-side of \links. The target choose was \ocaml which make the compilation of some high level features of \links far easier than if the target was a lower level language. 

In fact, the target of the compiler is a subset of the \ocaml language described in \hyperref[ocamlsubset]{the annex}. You notice that this is not in ANF anymore. Keeping the code in ANF may be possible but would involve extra work and is not needed to output valid ocaml code.

The compilation itself is done it two steps : first, the internal representation is translated into this subset, then this subset is printed as \ocaml code. The first is also when others smaller tasks are done such as handle boxing.

As opposed to \ocaml, \links handle first-class continuation. This mean that the continuation of the program can be manipulate as a regular function. This is not possible in usual programming style in \ocaml, but it is possible in CPS. 
As said \refsec{ir}, ANF is isomorphic to CPS, so transforming one to another is very easy. This task is also done during the first step.\\
There is still an option to output code in direct style, first-class continuation and some client-server communication features will not be available, but the debugging is far easier due to the increased readability of the output code for human eyes.

\subsection{The runtime library\label{runtime}}

The runtime library is presented in \cite{links:comp}. It's mostly composed by standard functions and by the boxing system. 

Since \links' typesystem is more complex than standard \ocaml's one, values need to be boxed and then unboxed. This also allow to create a polymorphic printint function, used to print the value returned by the program.

Standard functions are composeded by built-in operators (like $+$, $-$, ...), conversion functions and web interaction.

\section{Query compilation in Links}

As said in the introduction, the goal of this project is to compiler queries. We will first explain why this is difficult and wasn't handle in the first place. We will then show the theoretical solutions and finally the implementation of those solutions.

\subsection{Issues raised by query compilation}

To correctly understand the issues raised by query during the compilation, we first need to emphasize the differences between evaluation and compilation. \\

To evaluate some code, you construct a program that will do some actions according to this code. If you want to change the meaning of the code, you can simply change the actions triggered by the code. 

This is how is evaluated \links' code : A first evaluator, in the \module{Eval} module, is evaluating the internal representation, and when a query is involved, the \module{Eval} module transmit the concerned part of the code to the \module{Query} module presented \refsec{querynom} which is basically another evaluator.

This allow to have multiple meaning for the same piece of code without actually modifying the code.\\

A compiler translate the code from a language to another language. This other language have a known fixed meaning and will be later evaluated or compiled to a third language. This mean we can't change the meaning of the code without modifying the code. However, as said \refsec{intro:query}, every non-wild function in \links have two meanings.

Therefor, the compilation of query in \links can't be done in a straightforward way.

\subsection{Doubleling and splicing}

To handle those two meanings, the adopted solution is in fact very simple : duplicate every non-wild function. We will then deal with the interface between those two worlds.

We will explain the global principle of these in two steps : \emph{doubleling} and \emph{splicing}.

\subsubsection{Duplication of functions}

For every function, we create a database-only function and a programming language-only function. This transformation, called \emph{doubleling}, can be done in a typesafe way inside \links by using the effect system : 
\begin{itemize}
\item A programming language-only function is a function with the \effect{wild} effect, also called \effect{pl} effect. Only \effect{pl} functions can be called outside a query.
\item A database-only function is a function with a new effect : the \effect{db} effect. Only \effect{db} functions can be called inside a query.
\item A non wild function from the \links' code before applying the transformation is considered to have both \effect{pl} and \effect{db} effect : that's the \effect{any} effect.
\end{itemize}

However, a \effect{any} function can be passed as an argument of another function. We can't know in advance if that's the \effect{pl} or the \effect{db} aspect of the function that will be used. There is multiple way to solve this problem, here we will just pass the couple with both functions.

So, after this transformation, every non-wild function is, in fact, a couple of function : a \effect{db} one and a \effect{pl} one. We just need to project the right member of the couple when applying the function, according to the context.

\subsubsection{Converting values}

Now that functions have been duplicated, we have two worlds inside our to-be-compiled program : the programming-language world and the database one. The representation of values in this two worlds are different and the typesystem in the database world is much more simple since it's limited by \sql's typesytem. 

Database values can only involve the following types :
\begin{itemize}
\item Base types, that's integer, float, string, boolean;
\item Lists;
\item Records;
\item Variants.
\end{itemize}

However this two worlds will coexist in the compiled program. More specifically, piece of the \effect{db} worlds will exist into the \effect{pl} program and some \effect{pl} variables will be used inside \effect{db} queries. 

The only \effect{db} element inside a \effect{pl} program is a whole query. This query is introduced using a \emph{quotation}. This quotation emphasis the fact the inside of a query is in the \effect{db} world. This will also translate back the output of the query. As said earlier, a query is a list of records of base type so the translation to the \effect{pl} world is easy.\\

The other way, using \effect{pl} variables inside \effect{db} functions, is much more common and can involve many types of values. 
The operation converting \effect{pl} value to \effect{db} is called \emph{splicing}. For most values, the transformation is trivial.\\
 The real corner case here is when splicing a \effect{pl} function. A \effect{pl} function can never be used inside a query. We know since the program is correctly typed that this function will never be used. Hence we can simply replace it by the empty record.

\subsubsection{From effects to quotations}

After applying this two transformation, we don't need effects information anymore :
\begin{itemize}
\item There is no \effect{any} functions anymore, only \effect{pl} and \effect{db} functions.
\item In the \effect{pl} world, all elements of the \effect{db} world are introduced by an explicit \emph{quotation}.
\item In the \effect{db} world, all variables from the \effect{pl} world are introduced by the \emph{splicing} operator.
\end{itemize}

This new way of representing query inside a regular program is called a quotation-based language as opposed to \links which is an effect-based language. 
This is for example the case of {\tt LINQ}, a Microsoft language to use queries in a .NET environment (like F\# or C\#). 

This translation from an effect-based language to a quotation-based language is introduced and formalized in \cite{links:querycomp} by using two very simple languages, an effect-based one and a quotation-based one, and by showing a translation from the first to the later.

\section{Implementation}

The implementation has been done in four steps :
\begin{itemize}
\item Implement the \emph{doubleling} and the \emph{splicing} as transformation over the internal representation;
\item Make a new representation based on the IR to be put inside the runtime and make the normalisation procedure to work on this new representation;
\item Modify the \module{Irtoml} module to also print quoted code;
\item Modify the runtime library accordingly. 
\end{itemize}

\subsection{\emph{Doubleling} and \emph{Splicing}}

\subsubsection{New constructors in the IR}

Before actualy implementing those two tranformations, we need to modify the internal representation. We only need four new constructors : Three to handle doubleling and one for splicing. The \emph{quotation} operator is allready in the IR, it's the \ocamlc{Query} constructor from the type \sig{special}.\\

The query function constructor \ocamlc{FunQ} is exactly the same as the \ocamlc{Fun}. We will use native \links records to create the couple of functions so we don't need a constructor for these, but we do need two other constructors : \ocamlc{ApplyPL} and \ocamlc{ApplyDB}. They will replace the \ocamlc{Apply} constructor for duplicated function in \effect{pl} and \effect{db} context.

Thanks to the ANF of the internal representation, splicing we only occurs on variable. This way, we can simply add the constructor \ocamlc{SplicedVariable} with the same signature as \ocamlc{Variable}.\\

Now, we got all the tool we need to actually implement those transformations.

\subsubsection{Implementation of those transformation}

In \links' back-end, visiting the IR is a recurrent job. In order to avoid too much boiler plate, we use a functional version of the so-called ``visitor'' pattern from object-oriented programming. It has been implemented as the \ocamlc{visitor} class.

This class only visit the IR without modifying it. It also recheck type consistency and variable declarations. This is very easy since the IR is mostly annotated.

The implementation of \emph{Doubleling} and \emph{Splicing} are only objects that inherit from the \ocamlc{visitor} class. This reduce the code needed by the implementation to only the useful part.

Two modules, \module{Doubleling} and \module{Splicing}, have been created that deliver only the meaningful functions, the actual visitor is not accessible.\\
In order to preserve the property of the IR of variable identifiers unicity during doubleling, another module, \module{RenameVariable}, has been implemented that get trough the given element of the IR and rename all the variables.

\subsection{A new runtime representation}



\subsection{Extension of \module{Irtoml}}


\subsection{The new runtime}



\section{Tests \& benchmarks}

\subsection{Examples}

\subsection{Benchmarks}

\section{Conclusion}

\begin{thebibliography}{99}
\bibitem{links:tiers} \href{http://groups.inf.ed.ac.uk/links/papers/links-fmco06.pdf}{Links: web programming without tiers} Ezra Cooper, Sam Lindley, Philip Wadler and Jeremy Yallop
\bibitem{links:formlets} \href{http://groups.inf.ed.ac.uk/links/papers/formlets-essence.pdf}{The essence of form abstraction} Ezra Cooper, Sam Lindley, Philip Wadler and Jeremy Yallop
\bibitem{links:effect} \href{http://homepages.inf.ed.ac.uk/slindley/papers/corelinks.pdf}{Row-based effect types for database integration} Sam Lindley and James Cheney
\bibitem{links:comp} \href{http://groups.inf.ed.ac.uk/links/papers/undergrads/steven.pdf}{Compiling Links server-side code}. Steven Holmes
\bibitem{links:querycomp}
\end{thebibliography}

\section*{Annex}

\subsection*{Continuation Passing Style\label{cps}}

\subsection*{The targeted \ocaml subset\label{ocamlsubset}}
\begin{lstlisting}[language=ML]
type code =
  | Unit
  | Bool of bool
  | Int of num
  | Char of char
  | NativeString of string
  | Float of float
  | Var of string
  | Rec of (string * string list * code) list * code
  | Fun of string list * code 
  | LetFunQ of string * query_value * code
  | Let of string * code * code
  | If of (code * code * code)
  | Call of (code * code list)
  | Pair of code * code
  | Triple of code * code * code
  | Lst of code list
  | Case of code * ((code * code) list) * ((code * code) option)
  | Die of code
  | Query of query_computation
  | Table of code * code * (string * base_type) list
  | Tail of code
  | Empty
\end{lstlisting}

\end{document}
